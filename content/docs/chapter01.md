---
title: "Chapter 1: 백테스팅 시작하기"
weight: 1
bookToc: true
---

# Chapter 1: 백테스팅 시작하기

이 챕터에서는 백테스팅의 기본 개념을 이해하고, 개발 환경을 구축하여 첫 번째 Python 스크립트를 실행해보겠습니다. 이 책의 여정을 시작하는 첫 걸음입니다.

## 1.1 백테스팅이란 무엇인가?

### 백테스팅의 정의

**백테스팅(Backtesting)**은 과거의 시장 데이터를 사용하여 투자 전략의 성과를 시뮬레이션하는 과정입니다. 실제 자금을 투입하기 전에 전략의 유효성을 검증할 수 있는 핵심적인 도구입니다.

예를 들어, "주가가 20일 이동평균선을 상향 돌파하면 매수하고, 하향 돌파하면 매도한다"는 전략을 생각해봅시다. 이 전략이 과거 5년간 어떤 성과를 냈을지 궁금하다면? 백테스팅을 통해 답을 찾을 수 있습니다.

### Trading vs. Investing

투자(Investing)와 트레이딩(Trading)은 다릅니다:

- **투자(Investing)**: 장기간 자산을 보유하며 가치 상승을 기대합니다. 보통 수개월에서 수년 단위입니다.
- **트레이딩(Trading)**: 단기적인 가격 변동을 이용해 수익을 추구합니다. 수일에서 수주 단위의 거래가 일반적입니다.

이 책에서는 두 가지 접근법을 모두 다루며, 백테스팅은 두 경우 모두에 필수적입니다.

### 백테스팅의 기본 수학

백테스팅의 핵심은 **수익률(Return)**을 계산하는 것입니다. 시점 $t$에서의 수익률은:

$$R_t = \frac{P_t - P_{t-1}}{P_{t-1}} = \frac{P_t}{P_{t-1}} - 1$$

여기서:
- $R_t$: 시점 $t$에서의 수익률
- $P_t$: 시점 $t$에서의 가격
- $P_{t-1}$: 이전 시점의 가격

예를 들어, 어제 주가가 100달러였고 오늘 110달러라면:

$$R_t = \frac{110 - 100}{100} = 0.10 = 10\%$$

**누적 수익률(Cumulative Return)**은 여러 기간의 수익률을 결합합니다:

$$R_{cumulative} = \prod_{t=1}^{n}(1 + R_t) - 1$$

예를 들어, 첫째 날 +10%, 둘째 날 +5%의 수익을 얻었다면:

$$R_{cumulative} = (1 + 0.10) \times (1 + 0.05) - 1 = 1.155 - 1 = 0.155 = 15.5\%$$

단순히 10% + 5% = 15%가 아닌 **복리 효과**로 15.5%입니다.

## 1.2 퀀트 트레이딩의 현실: 수익성에 대한 진실

### 백테스팅을 시작하기 전에 알아야 할 것

이 책을 읽는 여러분은 아마도 **"퀀트 트레이딩으로 수익을 내고 싶다"**는 목표를 가지고 계실 것입니다. 그러나 시작하기 전에 반드시 알아야 할 중요한 진실이 있습니다.

**진실 #1: 대부분의 기술적 지표 전략은 강세장에서 Buy & Hold를 이기지 못합니다**

이 책의 Chapter 5-7에서 배우게 될 실제 백테스트 결과를 미리 보겠습니다 (AAPL 2019-2024):

| 전략 | 수익률 | vs Buy & Hold |
|------|--------|---------------|
| Buy & Hold (그냥 보유) | **+408%** | 기준 |
| RSI(30/70) 전략 | +113% | -72% 낮음 |
| Bollinger Bands | +103% | -75% 낮음 |
| SMA(50/200) 골든크로스 | +11% | **-97% 낮음** |

**충격적이지 않나요?** 유명한 골든크로스 전략이 단순히 주식을 사서 보유하는 것보다 97%나 낮은 수익을 냈습니다!

**진실 #2: 그렇다면 왜 퀀트 트레이딩을 배워야 하는가?**

1. **하락장과 횡보장에서의 우위**
   - Buy & Hold는 강세장에서만 유리합니다
   - 2008년 금융위기, 2020년 코로나 폭락 시 Buy & Hold는 -50% 이상 하락
   - 적절한 전략은 하락을 피하고 현금을 보유할 수 있습니다

2. **리스크 조정 수익률**
   - 수익률보다 **위험 대비 수익**이 더 중요합니다
   - Sharpe Ratio (위험 조정 수익률):
     - RSI 전략: 1.230 (우수)
     - Bollinger Bands: 1.232 (우수)
     - Buy & Hold: Sharpe 계산 불가 (거래 없음, 최대 낙폭 -35% 추정)

3. **포지션 사이징과 리스크 관리**
   - 전략의 진정한 가치는 **"언제 얼마나 투자할 것인가"**에 있습니다
   - Chapter 9-11에서 배울 포지션 사이징이 신호 생성보다 더 중요합니다

4. **다양한 시장 환경 대응**
   - 강세장: Buy & Hold
   - 약세장: 방어적 전략 (현금 보유)
   - 횡보장: 평균 회귀 전략
   - **시장 상황을 인식하고 전략을 전환하는 것이 핵심입니다**

**진실 #3: 퀀트 트레이딩의 진짜 목표**

| ❌ 잘못된 기대 | ✅ 현실적인 목표 |
|---------------|-----------------|
| 모든 시장에서 최고 수익 | 하락장에서 손실 최소화 |
| Buy & Hold를 항상 이김 | 위험 조정 수익률 개선 |
| 완벽한 타이밍 | 큰 손실 회피 |
| 빠른 부자 | 꾸준한 복리 성장 |

### 이 책의 진정한 가치

이 책은 다음을 가르칩니다:

1. ✅ **백테스팅 기술**: 어떤 전략이든 검증할 수 있는 능력
2. ✅ **비판적 사고**: 전략의 장단점을 객관적으로 평가
3. ✅ **시장 체제 인식**: 언제 어떤 전략을 사용할지 판단
4. ✅ **리스크 관리**: 수익보다 중요한 손실 통제
5. ✅ **현실적 기대**: 과대광고가 아닌 실제 데이터 기반 의사결정

**핵심 메시지**: 이 책은 "항상 수익 내는 성배 전략"을 찾는 책이 아닙니다. 대신 **시장 상황에 따라 적절한 전략을 선택하고, 리스크를 관리하며, 장기적으로 안정적인 수익을 추구하는 방법**을 가르칩니다.

## 1.3 백테스팅의 필요성

### 왜 백테스팅이 중요한가?

1. **리스크 관리**: 전략이 과거에 얼마나 큰 손실을 입었는지 확인하여 미래의 리스크를 예측할 수 있습니다.

2. **전략 검증**: "좋은 아이디어"가 실제로 수익을 낼 수 있는지 객관적으로 판단합니다.

3. **심리적 준비**: 예상되는 손실폭(Drawdown)을 미리 경험하면, 실전에서 패닉에 빠지지 않을 수 있습니다.

4. **매개변수 최적화**: 전략의 설정값(예: 이동평균 기간)을 조정하여 최적의 성과를 찾습니다.

5. **시장 체제 파악**: 어떤 시장 환경에서 전략이 작동하는지 이해합니다 (강세장 vs 약세장 vs 횡보장).

### 구체적인 예시

다음 시나리오를 생각해봅시다:

**전략**: "S&P 500이 50일 이동평균보다 높으면 주식에 투자, 낮으면 현금 보유"

백테스팅을 하지 않으면:
- 이 전략이 효과적인지 알 수 없습니다
- 얼마나 큰 손실이 발생할 수 있는지 모릅니다
- 최악의 시기에 전략을 포기할 수 있습니다

백테스팅을 하면:
- 과거 20년간 연평균 8%의 수익을 냈다는 것을 확인
- 최대 낙폭이 -25%였음을 알고 대비
- 전략이 효과를 발휘하기까지 평균 3개월이 걸린다는 것을 인지

## 1.4 백테스팅의 한계와 함정

백테스팅은 강력한 도구지만, 몇 가지 함정이 있습니다. 이를 이해하지 못하면 잘못된 결론에 도달할 수 있습니다.

### 1. 과최적화 (Overfitting)

**문제**: 과거 데이터에만 완벽하게 맞춘 전략은 미래에 작동하지 않습니다.

**예시**:
- "2010년부터 2020년까지 S&P 500 데이터로 테스트하여 완벽한 전략을 찾았습니다!"
- 하지만 2021년에 실행하면 손실이 발생합니다.
- 왜? 과거의 특정 패턴에만 맞춰진 전략이기 때문입니다.

**해결책**: Out-of-sample 테스트, Walk-forward 분석 (Chapter 14에서 다룹니다)

### 2. 생존자 편향 (Survivorship Bias)

**문제**: 상장폐지된 종목을 제외하면 실제보다 좋은 결과가 나옵니다.

**예시**:
- 2000년대 닷컴 버블 시기를 백테스팅한다고 가정합시다.
- 현재까지 살아남은 기술주만 사용하면 → 높은 수익률
- 실제로는 많은 기술주가 파산했고, 그 손실을 반영하지 못함

**해결책**: 과거 특정 시점에 존재했던 모든 종목을 포함 (상장폐지 종목 포함)

### 3. 전진 편향 (Look-ahead Bias)

**문제**: 과거 시점에서는 알 수 없었던 미래 정보를 사용합니다.

**예시**:
```python
# 잘못된 코드 - 미래 데이터 사용
df['returns'] = df['Close'].pct_change()
df['signal'] = df['returns'].rolling(20).mean()  # 미래 20일 평균 사용!
```

올바른 방법은 과거 데이터만 사용하는 것입니다:
```python
# 올바른 코드 - 과거 데이터만 사용
df['signal'] = df['Close'].rolling(20).mean().shift(1)  # 전날까지의 평균
```

**해결책**: 각 시점에서 실제로 알 수 있는 정보만 사용

### 4. 거래비용 미반영

**문제**: 수수료, 슬리피지, 세금 등의 비용을 무시하면 과도하게 낙관적인 결과가 나옵니다.

**예시**:
- 백테스팅 결과: 연 20% 수익
- 수수료 0.1%를 고려하면: 연 15% 수익
- 슬리피지까지 고려하면: 연 12% 수익

**해결책**: 현실적인 거래비용을 항상 포함 (Chapter 17에서 자세히 다룹니다)

## 1.5 개발 환경 구축

이제 실습을 시작해봅시다. Python과 필요한 라이브러리를 설치하겠습니다.

### Python 설치 확인

먼저 Python이 설치되어 있는지 확인합니다:

```bash
python3 --version
```

Python 3.8 이상이 필요합니다. 설치되어 있지 않다면 [python.org](https://www.python.org)에서 다운로드하세요.

### uv 패키지 관리자 설치

이 책에서는 **uv**라는 최신 Python 패키지 관리자를 사용합니다. uv는 pip보다 빠르고 효율적입니다.

**macOS/Linux 설치**:
```bash
curl -LsSf https://astral.sh/uv/install.sh | sh
```

**macOS (Homebrew)**:
```bash
brew install uv
```

**Windows**:
```powershell
powershell -c "irm https://astral.sh/uv/install.ps1 | iex"
```

설치 확인:
```bash
uv --version
```

### 프로젝트 구조

이 책의 코드는 다음과 같은 구조로 되어 있습니다:

```
intro-to-backtesting/
├── content/docs/          # 책 내용 (markdown)
│   ├── chapter01.md
│   ├── chapter02.md
│   └── ...
├── codes/                 # Python 코드
│   ├── chapter01/
│   │   └── 01_hello_trading.py
│   ├── chapter02/
│   ├── data/              # 다운로드한 데이터
│   └── pyproject.toml     # 의존성 관리
└── references/            # 라이브러리 문서
```

### 의존성 설치

`codes` 디렉토리로 이동하여 필요한 패키지를 설치합니다:

```bash
cd codes
uv sync
```

이 명령어는 `pyproject.toml` 파일에 명시된 모든 패키지를 자동으로 설치합니다.

### 주요 패키지 소개

이 책에서 사용할 핵심 라이브러리들:

1. **yfinance**: Yahoo Finance에서 주식 데이터를 무료로 다운로드
   ```python
   import yfinance as yf
   data = yf.download('AAPL', start='2020-01-01', end='2023-12-31')
   ```

2. **pandas**: 데이터 조작 및 분석을 위한 필수 도구
   ```python
   import pandas as pd
   df = pd.DataFrame({'price': [100, 110, 105, 115]})
   ```

3. **matplotlib**: 차트 생성 및 데이터 시각화
   ```python
   import matplotlib.pyplot as plt
   plt.plot(data['Close'])
   ```

4. **backtrader**: 백테스팅 전문 프레임워크 (Chapter 4부터 본격 사용)
   ```python
   import backtrader as bt
   ```

5. **numpy**: 수치 계산 및 통계 분석
   ```python
   import numpy as np
   returns = np.diff(prices) / prices[:-1]
   ```

## 1.6 첫 번째 Python 스크립트: Hello Trading

이제 첫 번째 코드를 작성하고 실행해봅시다. 이 스크립트는 환경이 올바르게 설정되었는지 확인하고, 간단한 금융 계산을 수행합니다.

### 코드 실행하기

```bash
cd codes
uv run chapter01/01_hello_trading.py
```

### 스크립트 설명

이 스크립트는 다음 작업을 수행합니다:

1. **환경 검증**: 모든 필수 라이브러리가 설치되었는지 확인
2. **간단한 수익률 계산**: 주어진 가격 데이터로 수익률 계산
3. **기본 통계**: 평균, 표준편차, 최대/최소 수익률 계산
4. **시각화**: 간단한 차트 생성

### 예상 출력

```
==========================================
   파이썬으로 배우는 백테스팅 입문
   Chapter 1: 백테스팅 시작하기
==========================================

환경 검증 중...
✓ Python 3.11.5
✓ pandas 2.1.3
✓ numpy 1.26.2
✓ matplotlib 3.8.2
✓ yfinance 0.2.32
✓ backtrader 1.9.78.123

모든 라이브러리가 정상적으로 설치되었습니다!

==========================================
간단한 수익률 계산 예제
==========================================

가상의 주가 데이터:
Day 1: $100.00
Day 2: $105.00 (수익률: +5.00%)
Day 3: $103.00 (수익률: -1.90%)
Day 4: $108.00 (수익률: +4.85%)
Day 5: $112.00 (수익률: +3.70%)

==========================================
통계 분석
==========================================
평균 일일 수익률: 2.91%
수익률 표준편차: 2.91%
최대 일일 수익률: +5.00%
최소 일일 수익률: -1.90%
총 누적 수익률: 12.00%

차트가 저장되었습니다: chapter01/images/hello_trading.png

==========================================
축하합니다! 첫 번째 스크립트 실행 완료!
==========================================
```

### 코드 분석

생성된 차트를 살펴봅시다:

![Hello Trading 차트](/images/chapter01/hello_trading.png)

차트는 세 부분으로 구성됩니다:

1. **상단 (Price Trend)**: 주가 추이 - 시간에 따른 가격 변화
   - 5일간 $100에서 $112로 상승하는 모습을 확인할 수 있습니다
   - Day 2에서 고점을 찍고 Day 3에 조정, 이후 다시 상승 추세를 보입니다

2. **중단 (Daily Returns)**: 일일 수익률 - 각 날짜별 수익률 (%)
   - 녹색 막대: 상승한 날 (Day 2: +5%, Day 4: +4.85%, Day 5: +3.70%)
   - 빨간색 막대: 하락한 날 (Day 3: -1.90%)
   - 3일 중 1일 하락으로 승률 75%를 보입니다

3. **하단 (Cumulative Returns)**: 누적 수익률 - 초기 투자금 대비 총 수익
   - 시간이 지날수록 누적 수익이 증가하는 모습
   - Day 3의 하락에도 불구하고 전체적으로는 우상향
   - 최종 누적 수익률: +12%

**핵심 인사이트**: 단기적인 하락(Day 3)이 있어도 전체적인 추세가 상승이면 누적 수익률은 증가합니다. 이것이 바로 백테스팅으로 확인하고자 하는 전략의 **지속성(Persistence)**입니다.

이러한 시각화는 백테스팅 결과를 분석할 때 매우 유용합니다.

### 실전 데이터 예제: NVIDIA (NVDA)

이제 실제 주식 데이터로 분석해봅시다. `01_basic_data_download.py` 스크립트의 실행 결과입니다:

```
=== NVIDIA 주식 데이터 다운로드 ===
회사명: NVIDIA Corporation
섹터: Technology
산업: Semiconductors
시가총액: $4,241,004,167,168

최근 1년 데이터 다운로드 중...
데이터 기간: 2025-02-05 ~ 2026-02-04
총 데이터 포인트: 251개

=== OHLCV 데이터 분석 ===
평균 일일 수익률: 0.0017 (0.17%)
일일 수익률 표준편차: 0.0278 (2.78%)
최대 일일 수익률: 0.1872 (18.72%)
최소 일일 수익률: -0.0869 (-8.69%)

평균 True Range: $5.55
평균 몸통 크기: $2.33
상승 캔들 비율: 52.59%
```

![NVIDIA 가격 차트](/images/chapter01/nvda_price_volume.png)

**차트 해석**:
- **상단**: NVIDIA 주가는 최근 1년간 $87~$212 범위에서 변동했습니다
  - 2025년 3월 큰 하락 후 지속적인 상승 추세
  - 2025년 10월 고점 $212 기록
  - 2026년 2월 현재 약 $179 수준
- **하단**: 거래량은 가격 변동성이 클 때 증가하는 패턴을 보입니다
  - 2025년 3월 폭락 시 거래량 폭발
  - 가격 급등/급락 시 거래량 증가는 전형적인 시장 패턴입니다

**수익률 분석**: 평균 일일 수익률 +0.17%는 연간으로 환산하면 약 +50% 이상의 수익률을 의미합니다 ($252 \times 0.17\%$). 하지만 일일 변동성이 2.78%로 높아 리스크도 큰 종목임을 알 수 있습니다.

## 1.7 프로젝트 구조 설계

백테스팅 프로젝트를 체계적으로 관리하는 방법을 알아봅시다.

### 권장 프로젝트 구조

```
my_backtesting_project/
├── data/                  # 원시 데이터 (CSV, JSON 등)
│   ├── stocks/
│   ├── etfs/
│   └── crypto/
├── notebooks/             # Jupyter 노트북 (실험용)
├── strategies/            # 전략 코드
│   ├── moving_average.py
│   ├── mean_reversion.py
│   └── momentum.py
├── backtests/             # 백테스트 결과
│   ├── results/
│   └── reports/
├── utils/                 # 유틸리티 함수
│   ├── data_loader.py
│   ├── metrics.py
│   └── visualization.py
└── main.py               # 메인 실행 파일
```

### 데이터 관리 원칙

1. **원시 데이터 보존**: 다운로드한 원본 데이터는 절대 수정하지 않습니다.
2. **처리된 데이터 분리**: 전처리된 데이터는 별도 폴더에 저장합니다.
3. **버전 관리**: 중요한 데이터셋은 날짜를 포함한 파일명으로 저장합니다.
   ```
   SPY_2020_2023_raw.csv
   SPY_2020_2023_processed_20240115.csv
   ```

### 코드 작성 원칙

1. **모듈화**: 각 기능을 독립적인 함수나 클래스로 분리
2. **문서화**: 함수에 docstring 추가
3. **재사용성**: 자주 사용하는 코드는 유틸리티 모듈로 분리

예시:
```python
def calculate_returns(prices):
    """
    Calculate simple returns from price series.

    Parameters:
    -----------
    prices : pd.Series or np.array
        Price data

    Returns:
    --------
    returns : pd.Series or np.array
        Simple returns
    """
    return prices.pct_change()
```

## 1.8 다음 단계

### 이 챕터에서 배운 것

✅ **백테스팅의 정의**: 과거 데이터로 전략을 시뮬레이션하는 과정
✅ **퀀트 트레이딩의 현실**: 대부분의 전략은 강세장에서 Buy & Hold를 이기지 못함
✅ **진정한 목표**: 하락장 방어, 위험 조정 수익률, 시장 체제별 전략 선택
✅ **백테스팅의 필요성**: 리스크 관리, 전략 검증, 심리적 준비, 시장 체제 파악
✅ **주요 함정**: 과최적화, 생존자 편향, 전진 편향, 거래비용
✅ **개발 환경 구축**: Python, uv, 필수 라이브러리 설치
✅ **첫 Python 스크립트**: 환경 검증 및 간단한 수익률 계산
✅ **프로젝트 구조**: 체계적인 코드 및 데이터 관리

### 실습 과제

1. **환경 검증**: `01_hello_trading.py`를 실행하고 모든 라이브러리가 정상 작동하는지 확인하세요.

2. **수익률 계산 연습**: 다음 주가 데이터로 수익률을 수동 계산해보세요:
   - Day 1: $50
   - Day 2: $55
   - Day 3: $52
   - Day 4: $58

   총 누적 수익률은 얼마인가요?

3. **프로젝트 구조 생성**: 자신만의 백테스팅 프로젝트 폴더 구조를 만들어보세요.

### 다음 챕터 미리보기

**Chapter 2: 금융 데이터 다운로드와 이해**에서는:
- yfinance를 사용한 실제 주식 데이터 다운로드
- OHLCV 데이터 구조의 상세 분석
- 다중 종목 및 다중 타임프레임 데이터 처리
- 배당금 및 주식 분할 조정 방법

---

**💡 핵심 메시지**

백테스팅은 강력한 도구지만 만능은 아닙니다. 과거의 성과가 미래를 보장하지 않습니다.

**가장 중요한 것은**: 이 책을 통해 "항상 수익 내는 완벽한 전략"을 찾으려고 하지 마세요. 그런 것은 존재하지 않습니다. 대신:

1. **시장 환경을 인식하는 능력** (강세장 vs 약세장 vs 횡보장)
2. **각 환경에 맞는 전략을 선택하는 지혜**
3. **리스크를 통제하는 규율**
4. **꾸준히 학습하고 개선하는 자세**

이것들이 진정한 퀀트 트레이더의 자질입니다. 실전 트레이딩에서는 시장 상황, 리스크 관리, 심리적 요인을 종합적으로 고려해야 합니다.

다음 챕터에서 실제 시장 데이터를 다운로드하고 분석하면서, 백테스팅의 실전 여정을 시작해봅시다!
