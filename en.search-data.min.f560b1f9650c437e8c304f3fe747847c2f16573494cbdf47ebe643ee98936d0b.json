[{"id":0,"href":"/intro-to-backtesting/docs/chapter01/","title":"Chapter 1: 백테스팅 시작하기","section":"Docs","content":"Chapter 1: 백테스팅 시작하기# 이 챕터에서는 백테스팅의 기본 개념을 이해하고, 개발 환경을 구축하여 첫 번째 Python 스크립트를 실행해보겠습니다. 이 책의 여정을 시작하는 첫 걸음입니다.\n1.1 백테스팅이란 무엇인가?# 백테스팅의 정의# **백테스팅(Backtesting)**은 과거의 시장 데이터를 사용하여 투자 전략의 성과를 시뮬레이션하는 과정입니다. 실제 자금을 투입하기 전에 전략의 유효성을 검증할 수 있는 핵심적인 도구입니다.\n예를 들어, \u0026ldquo;주가가 20일 이동평균선을 상향 돌파하면 매수하고, 하향 돌파하면 매도한다\u0026quot;는 전략을 생각해봅시다. 이 전략이 과거 5년간 어떤 성과를 냈을지 궁금하다면? 백테스팅을 통해 답을 찾을 수 있습니다.\nTrading vs. Investing# 투자(Investing)와 트레이딩(Trading)은 다릅니다:\n투자(Investing): 장기간 자산을 보유하며 가치 상승을 기대합니다. 보통 수개월에서 수년 단위입니다. 트레이딩(Trading): 단기적인 가격 변동을 이용해 수익을 추구합니다. 수일에서 수주 단위의 거래가 일반적입니다. 이 책에서는 두 가지 접근법을 모두 다루며, 백테스팅은 두 경우 모두에 필수적입니다.\n백테스팅의 기본 수학# 백테스팅의 핵심은 **수익률(Return)**을 계산하는 것입니다. 시점 $t$에서의 수익률은:\n$$R_t = \\frac{P_t - P_{t-1}}{P_{t-1}} = \\frac{P_t}{P_{t-1}} - 1$$여기서:\n$R_t$: 시점 $t$에서의 수익률 $P_t$: 시점 $t$에서의 가격 $P_{t-1}$: 이전 시점의 가격 예를 들어, 어제 주가가 100달러였고 오늘 110달러라면:\n$$R_t = \\frac{110 - 100}{100} = 0.10 = 10\\%$$**누적 수익률(Cumulative Return)**은 여러 기간의 수익률을 결합합니다:\n$$R_{cumulative} = \\prod_{t=1}^{n}(1 + R_t) - 1$$예를 들어, 첫째 날 +10%, 둘째 날 +5%의 수익을 얻었다면:\n$$R_{cumulative} = (1 + 0.10) \\times (1 + 0.05) - 1 = 1.155 - 1 = 0.155 = 15.5\\%$$단순히 10% + 5% = 15%가 아닌 복리 효과로 15.5%입니다.\n1.2 퀀트 트레이딩의 현실: 수익성에 대한 진실# 백테스팅을 시작하기 전에 알아야 할 것# 이 책을 읽는 여러분은 아마도 **\u0026ldquo;퀀트 트레이딩으로 수익을 내고 싶다\u0026rdquo;**는 목표를 가지고 계실 것입니다. 그러나 시작하기 전에 반드시 알아야 할 중요한 진실이 있습니다.\n진실 #1: 대부분의 기술적 지표 전략은 강세장에서 Buy \u0026amp; Hold를 이기지 못합니다\n이 책의 Chapter 5-7에서 배우게 될 실제 백테스트 결과를 미리 보겠습니다 (AAPL 2019-2024):\n전략 수익률 vs Buy \u0026amp; Hold Buy \u0026amp; Hold (그냥 보유) +408% 기준 RSI(30/70) 전략 +113% -72% 낮음 Bollinger Bands +103% -75% 낮음 SMA(50/200) 골든크로스 +11% -97% 낮음 충격적이지 않나요? 유명한 골든크로스 전략이 단순히 주식을 사서 보유하는 것보다 97%나 낮은 수익을 냈습니다!\n진실 #2: 그렇다면 왜 퀀트 트레이딩을 배워야 하는가?\n하락장과 횡보장에서의 우위\nBuy \u0026amp; Hold는 강세장에서만 유리합니다 2008년 금융위기, 2020년 코로나 폭락 시 Buy \u0026amp; Hold는 -50% 이상 하락 적절한 전략은 하락을 피하고 현금을 보유할 수 있습니다 리스크 조정 수익률\n수익률보다 위험 대비 수익이 더 중요합니다 Sharpe Ratio (위험 조정 수익률): RSI 전략: 1.230 (우수) Bollinger Bands: 1.232 (우수) Buy \u0026amp; Hold: Sharpe 계산 불가 (거래 없음, 최대 낙폭 -35% 추정) 포지션 사이징과 리스크 관리\n전략의 진정한 가치는 **\u0026ldquo;언제 얼마나 투자할 것인가\u0026rdquo;**에 있습니다 Chapter 9-11에서 배울 포지션 사이징이 신호 생성보다 더 중요합니다 다양한 시장 환경 대응\n강세장: Buy \u0026amp; Hold 약세장: 방어적 전략 (현금 보유) 횡보장: 평균 회귀 전략 시장 상황을 인식하고 전략을 전환하는 것이 핵심입니다 진실 #3: 퀀트 트레이딩의 진짜 목표\n❌ 잘못된 기대 ✅ 현실적인 목표 모든 시장에서 최고 수익 하락장에서 손실 최소화 Buy \u0026amp; Hold를 항상 이김 위험 조정 수익률 개선 완벽한 타이밍 큰 손실 회피 빠른 부자 꾸준한 복리 성장 이 책의 진정한 가치# 이 책은 다음을 가르칩니다:\n✅ 백테스팅 기술: 어떤 전략이든 검증할 수 있는 능력 ✅ 비판적 사고: 전략의 장단점을 객관적으로 평가 ✅ 시장 체제 인식: 언제 어떤 전략을 사용할지 판단 ✅ 리스크 관리: 수익보다 중요한 손실 통제 ✅ 현실적 기대: 과대광고가 아닌 실제 데이터 기반 의사결정 핵심 메시지: 이 책은 \u0026ldquo;항상 수익 내는 성배 전략\u0026quot;을 찾는 책이 아닙니다. 대신 시장 상황에 따라 적절한 전략을 선택하고, 리스크를 관리하며, 장기적으로 안정적인 수익을 추구하는 방법을 가르칩니다.\n1.3 백테스팅의 필요성# 왜 백테스팅이 중요한가?# 리스크 관리: 전략이 과거에 얼마나 큰 손실을 입었는지 확인하여 미래의 리스크를 예측할 수 있습니다.\n전략 검증: \u0026ldquo;좋은 아이디어\u0026quot;가 실제로 수익을 낼 수 있는지 객관적으로 판단합니다.\n심리적 준비: 예상되는 손실폭(Drawdown)을 미리 경험하면, 실전에서 패닉에 빠지지 않을 수 있습니다.\n매개변수 최적화: 전략의 설정값(예: 이동평균 기간)을 조정하여 최적의 성과를 찾습니다.\n시장 체제 파악: 어떤 시장 환경에서 전략이 작동하는지 이해합니다 (강세장 vs 약세장 vs 횡보장).\n구체적인 예시# 다음 시나리오를 생각해봅시다:\n전략: \u0026ldquo;S\u0026amp;P 500이 50일 이동평균보다 높으면 주식에 투자, 낮으면 현금 보유\u0026rdquo;\n백테스팅을 하지 않으면:\n이 전략이 효과적인지 알 수 없습니다 얼마나 큰 손실이 발생할 수 있는지 모릅니다 최악의 시기에 전략을 포기할 수 있습니다 백테스팅을 하면:\n과거 20년간 연평균 8%의 수익을 냈다는 것을 확인 최대 낙폭이 -25%였음을 알고 대비 전략이 효과를 발휘하기까지 평균 3개월이 걸린다는 것을 인지 1.4 백테스팅의 한계와 함정# 백테스팅은 강력한 도구지만, 몇 가지 함정이 있습니다. 이를 이해하지 못하면 잘못된 결론에 도달할 수 있습니다.\n1. 과최적화 (Overfitting)# 문제: 과거 데이터에만 완벽하게 맞춘 전략은 미래에 작동하지 않습니다.\n예시:\n\u0026ldquo;2010년부터 2020년까지 S\u0026amp;P 500 데이터로 테스트하여 완벽한 전략을 찾았습니다!\u0026rdquo; 하지만 2021년에 실행하면 손실이 발생합니다. 왜? 과거의 특정 패턴에만 맞춰진 전략이기 때문입니다. 해결책: Out-of-sample 테스트, Walk-forward 분석 (Chapter 14에서 다룹니다)\n2. 생존자 편향 (Survivorship Bias)# 문제: 상장폐지된 종목을 제외하면 실제보다 좋은 결과가 나옵니다.\n예시:\n2000년대 닷컴 버블 시기를 백테스팅한다고 가정합시다. 현재까지 살아남은 기술주만 사용하면 → 높은 수익률 실제로는 많은 기술주가 파산했고, 그 손실을 반영하지 못함 해결책: 과거 특정 시점에 존재했던 모든 종목을 포함 (상장폐지 종목 포함)\n3. 전진 편향 (Look-ahead Bias)# 문제: 과거 시점에서는 알 수 없었던 미래 정보를 사용합니다.\n예시:\n# 잘못된 코드 - 미래 데이터 사용 df[\u0026#39;returns\u0026#39;] = df[\u0026#39;Close\u0026#39;].pct_change() df[\u0026#39;signal\u0026#39;] = df[\u0026#39;returns\u0026#39;].rolling(20).mean() # 미래 20일 평균 사용!올바른 방법은 과거 데이터만 사용하는 것입니다:\n# 올바른 코드 - 과거 데이터만 사용 df[\u0026#39;signal\u0026#39;] = df[\u0026#39;Close\u0026#39;].rolling(20).mean().shift(1) # 전날까지의 평균해결책: 각 시점에서 실제로 알 수 있는 정보만 사용\n4. 거래비용 미반영# 문제: 수수료, 슬리피지, 세금 등의 비용을 무시하면 과도하게 낙관적인 결과가 나옵니다.\n예시:\n백테스팅 결과: 연 20% 수익 수수료 0.1%를 고려하면: 연 15% 수익 슬리피지까지 고려하면: 연 12% 수익 해결책: 현실적인 거래비용을 항상 포함 (Chapter 17에서 자세히 다룹니다)\n1.5 개발 환경 구축# 이제 실습을 시작해봅시다. Python과 필요한 라이브러리를 설치하겠습니다.\nPython 설치 확인# 먼저 Python이 설치되어 있는지 확인합니다:\npython3 --versionPython 3.8 이상이 필요합니다. 설치되어 있지 않다면 python.org에서 다운로드하세요.\nuv 패키지 관리자 설치# 이 책에서는 uv라는 최신 Python 패키지 관리자를 사용합니다. uv는 pip보다 빠르고 효율적입니다.\nmacOS/Linux 설치:\ncurl -LsSf https://astral.sh/uv/install.sh | shmacOS (Homebrew):\nbrew install uvWindows:\npowershell -c \u0026#34;irm https://astral.sh/uv/install.ps1 | iex\u0026#34;설치 확인:\nuv --version프로젝트 구조# 이 책의 코드는 다음과 같은 구조로 되어 있습니다:\nintro-to-backtesting/ ├── content/docs/ # 책 내용 (markdown) │ ├── chapter01.md │ ├── chapter02.md │ └── ... ├── codes/ # Python 코드 │ ├── chapter01/ │ │ └── 01_hello_trading.py │ ├── chapter02/ │ ├── data/ # 다운로드한 데이터 │ └── pyproject.toml # 의존성 관리 └── references/ # 라이브러리 문서의존성 설치# codes 디렉토리로 이동하여 필요한 패키지를 설치합니다:\ncd codes uv sync이 명령어는 pyproject.toml 파일에 명시된 모든 패키지를 자동으로 설치합니다.\n주요 패키지 소개# 이 책에서 사용할 핵심 라이브러리들:\nyfinance: Yahoo Finance에서 주식 데이터를 무료로 다운로드\nimport yfinance as yf data = yf.download(\u0026#39;AAPL\u0026#39;, start=\u0026#39;2020-01-01\u0026#39;, end=\u0026#39;2023-12-31\u0026#39;) pandas: 데이터 조작 및 분석을 위한 필수 도구\nimport pandas as pd df = pd.DataFrame({\u0026#39;price\u0026#39;: [100, 110, 105, 115]}) matplotlib: 차트 생성 및 데이터 시각화\nimport matplotlib.pyplot as plt plt.plot(data[\u0026#39;Close\u0026#39;]) backtrader: 백테스팅 전문 프레임워크 (Chapter 4부터 본격 사용)\nimport backtrader as bt numpy: 수치 계산 및 통계 분석\nimport numpy as np returns = np.diff(prices) / prices[:-1] 1.6 첫 번째 Python 스크립트: Hello Trading# 이제 첫 번째 코드를 작성하고 실행해봅시다. 이 스크립트는 환경이 올바르게 설정되었는지 확인하고, 간단한 금융 계산을 수행합니다.\n코드 실행하기# cd codes uv run chapter01/01_hello_trading.py스크립트 설명# 이 스크립트는 다음 작업을 수행합니다:\n환경 검증: 모든 필수 라이브러리가 설치되었는지 확인 간단한 수익률 계산: 주어진 가격 데이터로 수익률 계산 기본 통계: 평균, 표준편차, 최대/최소 수익률 계산 시각화: 간단한 차트 생성 예상 출력# ========================================== 파이썬으로 배우는 백테스팅 입문 Chapter 1: 백테스팅 시작하기 ========================================== 환경 검증 중... ✓ Python 3.11.5 ✓ pandas 2.1.3 ✓ numpy 1.26.2 ✓ matplotlib 3.8.2 ✓ yfinance 0.2.32 ✓ backtrader 1.9.78.123 모든 라이브러리가 정상적으로 설치되었습니다! ========================================== 간단한 수익률 계산 예제 ========================================== 가상의 주가 데이터: Day 1: $100.00 Day 2: $105.00 (수익률: +5.00%) Day 3: $103.00 (수익률: -1.90%) Day 4: $108.00 (수익률: +4.85%) Day 5: $112.00 (수익률: +3.70%) ========================================== 통계 분석 ========================================== 평균 일일 수익률: 2.91% 수익률 표준편차: 2.91% 최대 일일 수익률: +5.00% 최소 일일 수익률: -1.90% 총 누적 수익률: 12.00% 차트가 저장되었습니다: chapter01/images/hello_trading.png ========================================== 축하합니다! 첫 번째 스크립트 실행 완료! ==========================================코드 분석# 생성된 차트를 살펴봅시다:\n차트는 세 부분으로 구성됩니다:\n상단 (Price Trend): 주가 추이 - 시간에 따른 가격 변화\n5일간 $100에서 $112로 상승하는 모습을 확인할 수 있습니다 Day 2에서 고점을 찍고 Day 3에 조정, 이후 다시 상승 추세를 보입니다 중단 (Daily Returns): 일일 수익률 - 각 날짜별 수익률 (%)\n녹색 막대: 상승한 날 (Day 2: +5%, Day 4: +4.85%, Day 5: +3.70%) 빨간색 막대: 하락한 날 (Day 3: -1.90%) 3일 중 1일 하락으로 승률 75%를 보입니다 하단 (Cumulative Returns): 누적 수익률 - 초기 투자금 대비 총 수익\n시간이 지날수록 누적 수익이 증가하는 모습 Day 3의 하락에도 불구하고 전체적으로는 우상향 최종 누적 수익률: +12% 핵심 인사이트: 단기적인 하락(Day 3)이 있어도 전체적인 추세가 상승이면 누적 수익률은 증가합니다. 이것이 바로 백테스팅으로 확인하고자 하는 전략의 **지속성(Persistence)**입니다.\n이러한 시각화는 백테스팅 결과를 분석할 때 매우 유용합니다.\n실전 데이터 예제: NVIDIA (NVDA)# 이제 실제 주식 데이터로 분석해봅시다. 01_basic_data_download.py 스크립트의 실행 결과입니다:\n=== NVIDIA 주식 데이터 다운로드 === 회사명: NVIDIA Corporation 섹터: Technology 산업: Semiconductors 시가총액: $4,241,004,167,168 최근 1년 데이터 다운로드 중... 데이터 기간: 2025-02-05 ~ 2026-02-04 총 데이터 포인트: 251개 === OHLCV 데이터 분석 === 평균 일일 수익률: 0.0017 (0.17%) 일일 수익률 표준편차: 0.0278 (2.78%) 최대 일일 수익률: 0.1872 (18.72%) 최소 일일 수익률: -0.0869 (-8.69%) 평균 True Range: $5.55 평균 몸통 크기: $2.33 상승 캔들 비율: 52.59%\n차트 해석:\n상단: NVIDIA 주가는 최근 1년간 $87~$212 범위에서 변동했습니다 2025년 3월 큰 하락 후 지속적인 상승 추세 2025년 10월 고점 $212 기록 2026년 2월 현재 약 $179 수준 하단: 거래량은 가격 변동성이 클 때 증가하는 패턴을 보입니다 2025년 3월 폭락 시 거래량 폭발 가격 급등/급락 시 거래량 증가는 전형적인 시장 패턴입니다 수익률 분석: 평균 일일 수익률 +0.17%는 연간으로 환산하면 약 +50% 이상의 수익률을 의미합니다 ($252 \\times 0.17\\%$). 하지만 일일 변동성이 2.78%로 높아 리스크도 큰 종목임을 알 수 있습니다.\n1.7 프로젝트 구조 설계# 백테스팅 프로젝트를 체계적으로 관리하는 방법을 알아봅시다.\n권장 프로젝트 구조# my_backtesting_project/ ├── data/ # 원시 데이터 (CSV, JSON 등) │ ├── stocks/ │ ├── etfs/ │ └── crypto/ ├── notebooks/ # Jupyter 노트북 (실험용) ├── strategies/ # 전략 코드 │ ├── moving_average.py │ ├── mean_reversion.py │ └── momentum.py ├── backtests/ # 백테스트 결과 │ ├── results/ │ └── reports/ ├── utils/ # 유틸리티 함수 │ ├── data_loader.py │ ├── metrics.py │ └── visualization.py └── main.py # 메인 실행 파일데이터 관리 원칙# 원시 데이터 보존: 다운로드한 원본 데이터는 절대 수정하지 않습니다. 처리된 데이터 분리: 전처리된 데이터는 별도 폴더에 저장합니다. 버전 관리: 중요한 데이터셋은 날짜를 포함한 파일명으로 저장합니다. SPY_2020_2023_raw.csv SPY_2020_2023_processed_20240115.csv 코드 작성 원칙# 모듈화: 각 기능을 독립적인 함수나 클래스로 분리 문서화: 함수에 docstring 추가 재사용성: 자주 사용하는 코드는 유틸리티 모듈로 분리 예시:\ndef calculate_returns(prices): \u0026#34;\u0026#34;\u0026#34; Calculate simple returns from price series. Parameters: ----------- prices : pd.Series or np.array Price data Returns: -------- returns : pd.Series or np.array Simple returns \u0026#34;\u0026#34;\u0026#34; return prices.pct_change()1.8 다음 단계# 이 챕터에서 배운 것# ✅ 백테스팅의 정의: 과거 데이터로 전략을 시뮬레이션하는 과정 ✅ 퀀트 트레이딩의 현실: 대부분의 전략은 강세장에서 Buy \u0026amp; Hold를 이기지 못함 ✅ 진정한 목표: 하락장 방어, 위험 조정 수익률, 시장 체제별 전략 선택 ✅ 백테스팅의 필요성: 리스크 관리, 전략 검증, 심리적 준비, 시장 체제 파악 ✅ 주요 함정: 과최적화, 생존자 편향, 전진 편향, 거래비용 ✅ 개발 환경 구축: Python, uv, 필수 라이브러리 설치 ✅ 첫 Python 스크립트: 환경 검증 및 간단한 수익률 계산 ✅ 프로젝트 구조: 체계적인 코드 및 데이터 관리\n실습 과제# 환경 검증: 01_hello_trading.py를 실행하고 모든 라이브러리가 정상 작동하는지 확인하세요.\n수익률 계산 연습: 다음 주가 데이터로 수익률을 수동 계산해보세요:\nDay 1: $50 Day 2: $55 Day 3: $52 Day 4: $58 총 누적 수익률은 얼마인가요?\n프로젝트 구조 생성: 자신만의 백테스팅 프로젝트 폴더 구조를 만들어보세요.\n다음 챕터 미리보기# Chapter 2: 금융 데이터 다운로드와 이해에서는:\nyfinance를 사용한 실제 주식 데이터 다운로드 OHLCV 데이터 구조의 상세 분석 다중 종목 및 다중 타임프레임 데이터 처리 배당금 및 주식 분할 조정 방법 💡 핵심 메시지\n백테스팅은 강력한 도구지만 만능은 아닙니다. 과거의 성과가 미래를 보장하지 않습니다.\n가장 중요한 것은: 이 책을 통해 \u0026ldquo;항상 수익 내는 완벽한 전략\u0026quot;을 찾으려고 하지 마세요. 그런 것은 존재하지 않습니다. 대신:\n시장 환경을 인식하는 능력 (강세장 vs 약세장 vs 횡보장) 각 환경에 맞는 전략을 선택하는 지혜 리스크를 통제하는 규율 꾸준히 학습하고 개선하는 자세 이것들이 진정한 퀀트 트레이더의 자질입니다. 실전 트레이딩에서는 시장 상황, 리스크 관리, 심리적 요인을 종합적으로 고려해야 합니다.\n다음 챕터에서 실제 시장 데이터를 다운로드하고 분석하면서, 백테스팅의 실전 여정을 시작해봅시다!\n"},{"id":1,"href":"/intro-to-backtesting/docs/chapter02/","title":"Chapter 2: 금융 데이터 다운로드와 이해","section":"Docs","content":"Chapter 2: 금융 데이터 다운로드와 이해# 이 챕터에서는 백테스팅의 필수 재료인 금융 데이터를 다루는 방법을 배웁니다. yfinance 라이브러리를 사용하여 실제 주식 데이터를 다운로드하고, OHLCV 데이터 구조를 이해하며, 배당금과 주식 분할을 처리하는 방법을 알아봅니다.\n2.1 OHLCV 데이터 구조# OHLCV란?# 금융 시장 데이터의 표준 형식인 OHLCV는 다음 5가지 정보로 구성됩니다:\nOpen (시가): 해당 기간의 첫 거래 가격 High (고가): 해당 기간의 최고 거래 가격 Low (저가): 해당 기간의 최저 거래 가격 Close (종가): 해당 기간의 마지막 거래 가격 Volume (거래량): 해당 기간의 총 거래된 주식 수 시간 프레임 (Timeframe)# OHLCV 데이터는 다양한 시간 단위로 제공됩니다:\n1분봉 (1-minute): 매 1분마다의 OHLCV 1시간봉 (1-hour): 매 1시간마다의 OHLCV 일봉 (Daily): 매 거래일마다의 OHLCV 주봉 (Weekly): 매 주마다의 OHLCV 월봉 (Monthly): 매 월마다의 OHLCV 캔들스틱 해석# 하나의 OHLCV 데이터는 **캔들스틱(Candlestick)**으로 시각화됩니다:\nHigh (고가) | |------- Close (종가가 시가보다 높으면 상승 캔들) | | | | |------- Open (시가) | Low (저가)상승 캔들 (Bullish Candle):\nClose \u0026gt; Open (종가가 시가보다 높음) 보통 녹색 또는 흰색으로 표시 매수 압력이 강했음을 의미 하락 캔들 (Bearish Candle):\nClose \u0026lt; Open (종가가 시가보다 낮음) 보통 빨간색 또는 검은색으로 표시 매도 압력이 강했음을 의미 캔들스틱의 수학적 특성# 각 캔들스틱에서 계산할 수 있는 유용한 지표들:\n1. 몸통 크기 (Body Size): $$\\text{Body} = |Close - Open|$$큰 몸통은 강한 추세를 의미합니다.\n2. 위 꼬리 길이 (Upper Shadow): $$\\text{Upper Shadow} = High - \\max(Open, Close)$$긴 위 꼬리는 상승 시도가 거부당했음을 의미합니다.\n3. 아래 꼬리 길이 (Lower Shadow): $$\\text{Lower Shadow} = \\min(Open, Close) - Low$$긴 아래 꼬리는 하락 시도가 거부당했음을 의미합니다.\n4. True Range (진정한 변동폭): $$TR = \\max(High - Low, |High - Close_{prev}|, |Low - Close_{prev}|)$$True Range는 갭(Gap)을 고려한 실제 변동성을 측정합니다.\n2.2 yfinance로 데이터 다운로드# yfinance란?# yfinance는 Yahoo Finance에서 금융 데이터를 무료로 다운로드할 수 있는 Python 라이브러리입니다.\n장점:\n✅ 완전 무료 ✅ 수천 개의 주식, ETF, 인덱스 지원 ✅ 과거 데이터 제공 (최대 수십 년) ✅ 배당금 및 주식 분할 자동 조정 ✅ 간단한 API 단점:\n⚠️ 실시간 데이터 아님 (15-20분 지연) ⚠️ 일부 소형주는 데이터가 없을 수 있음 ⚠️ API 변경 가능성 (Yahoo에서 공식 지원하지 않음) 기본 사용법# 단일 종목 다운로드:\nimport yfinance as yf # 애플 주식 데이터 다운로드 ticker = yf.Ticker(\u0026#34;AAPL\u0026#34;) data = ticker.history(period=\u0026#34;1y\u0026#34;) # 최근 1년 print(data.head())결과:\nOpen High Low Close Volume Dividends Stock Splits Date 2024-01-02 187.15 188.44 185.83 185.64 82488400 0.0 0.0 2024-01-03 185.89 186.67 183.43 184.25 58414400 0.0 0.0 2024-01-04 184.35 186.40 183.92 185.59 54480100 0.0 0.0 ...다양한 기간 옵션# # 방법 1: 기간(period) 지정 data = ticker.history(period=\u0026#34;1mo\u0026#34;) # 최근 1개월 data = ticker.history(period=\u0026#34;1y\u0026#34;) # 최근 1년 data = ticker.history(period=\u0026#34;5y\u0026#34;) # 최근 5년 data = ticker.history(period=\u0026#34;max\u0026#34;) # 모든 데이터 # 방법 2: 시작일과 종료일 지정 data = ticker.history(start=\u0026#34;2020-01-01\u0026#34;, end=\u0026#34;2023-12-31\u0026#34;)다양한 시간 프레임# # 일봉 (기본값) data = ticker.history(period=\u0026#34;1y\u0026#34;, interval=\u0026#34;1d\u0026#34;) # 주봉 data = ticker.history(period=\u0026#34;2y\u0026#34;, interval=\u0026#34;1wk\u0026#34;) # 월봉 data = ticker.history(period=\u0026#34;5y\u0026#34;, interval=\u0026#34;1mo\u0026#34;) # 1시간봉 (최근 60일까지만 가능) data = ticker.history(period=\u0026#34;1mo\u0026#34;, interval=\u0026#34;1h\u0026#34;) # 1분봉 (최근 7일까지만 가능) data = ticker.history(period=\u0026#34;1d\u0026#34;, interval=\u0026#34;1m\u0026#34;)2.3 배당금과 주식 분할 조정# Adjusted Close의 중요성# 문제 상황:\n2020년 1월 1일: Apple 주가 $300 2020년 8월 31일: 4:1 주식 분할 실행 2020년 9월 1일: Apple 주가 $100 (분할 후) 만약 조정하지 않으면, 8월 31일에서 9월 1일로 넘어갈 때 -66%의 손실이 발생한 것처럼 보입니다! 하지만 실제로는 가치가 변하지 않았습니다.\nAdjusted Close란?# **Adjusted Close (조정 종가)**는 다음을 고려하여 과거 가격을 조정한 값입니다:\n배당금 (Dividends): 배당금 지급으로 인한 가격 하락 반영 주식 분할 (Stock Splits): 주식 분할로 인한 가격 변화 반영 조정 공식# 주식 분할 조정:\n4:1 분할이 발생하면, 분할 이전의 모든 가격을 1/4로 조정 배당금 조정: $$P_{adjusted} = P_{actual} \\times \\frac{Close_{today}}{Close_{today} + Dividend}$$yfinance의 자동 조정# yfinance는 기본적으로 조정된 가격을 제공합니다:\ndata = ticker.history(period=\u0026#34;5y\u0026#34;) # Close: 조정된 종가 (Adjusted Close) # 이미 배당금과 주식 분할이 반영되어 있음 print(data[\u0026#39;Close\u0026#39;])중요: 백테스팅에서는 반드시 Adjusted Close를 사용해야 합니다. 그렇지 않으면 잘못된 수익률을 계산하게 됩니다.\n2.4 다중 종목 데이터 다운로드# 여러 종목 동시 다운로드# import yfinance as yf # 여러 종목을 한 번에 다운로드 tickers = [\u0026#34;AAPL\u0026#34;, \u0026#34;MSFT\u0026#34;, \u0026#34;GOOGL\u0026#34;, \u0026#34;TSLA\u0026#34;] data = yf.download(tickers, start=\u0026#34;2020-01-01\u0026#34;, end=\u0026#34;2023-12-31\u0026#34;) # 결과는 MultiIndex DataFrame print(data[\u0026#39;Close\u0026#39;]) # 모든 종목의 종가결과:\nTicker AAPL MSFT GOOGL TSLA Date 2020-01-02 73.06 158.78 67.42 29.53 2020-01-03 72.34 157.32 67.11 29.17 ...개별 종목 추출# # 단일 종목 추출 aapl_close = data[\u0026#39;Close\u0026#39;][\u0026#39;AAPL\u0026#39;] # 여러 종목 추출 tech_stocks = data[\u0026#39;Close\u0026#39;][[\u0026#39;AAPL\u0026#39;, \u0026#39;MSFT\u0026#39;, \u0026#39;GOOGL\u0026#39;]]2.5 다중 타임프레임 분석# 왜 다중 타임프레임인가?# 큰 그림 파악: 일봉에서는 하락 추세지만, 주봉에서는 상승 추세일 수 있습니다.\n트레이딩 전략 예시:\n주봉: 전체 추세 파악 (상승 추세인가?) 일봉: 진입 시점 찾기 (언제 매수할까?) 1시간봉: 정확한 타이밍 (지금 바로 매수할까?) 다중 타임프레임 데이터 수집# ticker = yf.Ticker(\u0026#34;SPY\u0026#34;) # 여러 타임프레임 데이터 daily = ticker.history(period=\u0026#34;1y\u0026#34;, interval=\u0026#34;1d\u0026#34;) weekly = ticker.history(period=\u0026#34;2y\u0026#34;, interval=\u0026#34;1wk\u0026#34;) monthly = ticker.history(period=\u0026#34;5y\u0026#34;, interval=\u0026#34;1mo\u0026#34;)타임프레임 간 전환# pandas의 resample() 함수로 타임프레임 변환:\n# 일봉 → 주봉 weekly_from_daily = daily.resample(\u0026#39;W\u0026#39;).agg({ \u0026#39;Open\u0026#39;: \u0026#39;first\u0026#39;, # 주의 첫 거래일 시가 \u0026#39;High\u0026#39;: \u0026#39;max\u0026#39;, # 주 중 최고가 \u0026#39;Low\u0026#39;: \u0026#39;min\u0026#39;, # 주 중 최저가 \u0026#39;Close\u0026#39;: \u0026#39;last\u0026#39;, # 주의 마지막 거래일 종가 \u0026#39;Volume\u0026#39;: \u0026#39;sum\u0026#39; # 주간 총 거래량 })2.6 종목 정보 조회# 기본 정보# ticker = yf.Ticker(\u0026#34;AAPL\u0026#34;) # 회사 정보 info = ticker.info print(f\u0026#34;회사명: {info[\u0026#39;longName\u0026#39;]}\u0026#34;) print(f\u0026#34;섹터: {info[\u0026#39;sector\u0026#39;]}\u0026#34;) print(f\u0026#34;산업: {info[\u0026#39;industry\u0026#39;]}\u0026#34;) print(f\u0026#34;시가총액: ${info[\u0026#39;marketCap\u0026#39;]:,}\u0026#34;) print(f\u0026#34;직원 수: {info[\u0026#39;fullTimeEmployees\u0026#39;]:,}\u0026#34;)재무 데이터# # 재무제표 income_stmt = ticker.income_stmt # 손익계산서 balance_sheet = ticker.balance_sheet # 재무상태표 cash_flow = ticker.cashflow # 현금흐름표 # 배당금 이력 dividends = ticker.dividends print(dividends.tail()) # 주식 분할 이력 splits = ticker.splits print(splits)2.7 실습: 주식 데이터 탐색# 이제 실제 코드를 실행해봅시다.\n코드 실행# cd codes uv run chapter02/01_download_and_explore.py스크립트 개요# 이 스크립트는 다음을 수행합니다:\n단일 종목 다운로드: Apple (AAPL) 주식 데이터 OHLCV 분석: 기본 통계 및 캔들스틱 패턴 다중 종목 비교: AAPL, MSFT, GOOGL, NVDA 타임프레임 비교: 일봉 vs. 주봉 vs. 월봉 시각화: 가격 차트, 거래량, 캔들스틱 차트 실행 결과# 실제로 스크립트를 실행한 결과입니다:\n========================================== Chapter 2: 금융 데이터 다운로드와 이해 ========================================== === AAPL 데이터 다운로드 === 기간: 2021-02-06 ~ 2026-02-05 (5년) 총 데이터 포인트: 1254개 회사 정보: - 이름: Apple Inc. - 섹터: Technology - 시가총액: $4,063,829,426,176 ========================================== === OHLCV 기본 통계 === ========================================== 평균 종가: $181.96 최고가: $288.62 (2025-12-03) 최저가: $113.29 (2021-03-08) 일일 변동폭 (High-Low): - 평균: $3.75 (2.09%) - 최대: $28.62 (14.44%) ========================================== === 캔들스틱 패턴 분석 === ========================================== 상승 캔들: 671개 (53.5%) 하락 캔들: 583개 (46.5%) 평균 몸통 크기: $1.86 평균 위 꼬리: $0.95 평균 아래 꼬리: $0.94 ========================================== === 다중 종목 비교 (최근 1y) === ========================================== AAPL: +19.5% MSFT: +1.0% GOOGL: +74.7% NVDA: +39.6% ========================================== === SPY 타임프레임 비교 === ========================================== 일봉 (1년): 데이터 포인트: 251개 수익률: +14.9% 변동성 (일일): 1.22% 주봉 (2년): 데이터 포인트: 105개 수익률: +40.3% 변동성 (일일): 2.07% 월봉 (5년): 데이터 포인트: 60개 수익률: +85.5% 변동성 (일일): 4.44% 차트 저장 완료: chapter02/images/data_exploration.png결과 분석: 수익성 관점에서의 핵심 발견# ⚠️ 중요한 수익성 교훈: 실행 결과를 다시 보겠습니다:\nAAPL: +19.5% MSFT: +1.0% GOOGL: +74.7% ← 가장 높음! NVDA: +39.6%핵심 교훈 #1: 종목 선택 \u0026gt; 타이밍 전략\n만약 복잡한 트레이딩 전략으로 AAPL에서 19.5% → 25%로 개선했다고 해도 (30% 개선!), GOOGL을 단순히 사서 보유하는 것(+74.7%)보다 훨씬 못한 성과입니다.\n이것이 의미하는 것:\n✅ 좋은 종목을 선택하는 것이 복잡한 타이밍 전략보다 중요합니다 ✅ 백테스팅으로 여러 종목을 비교하여 최고 성과 종목을 찾아야 합니다 ✅ 다양한 종목에 분산 투자하면 GOOGL 같은 승자를 잡을 확률이 높아집니다 ⚠️ 하지만! 과거 성과가 미래를 보장하지 않습니다 (생존자 편향 주의) 핵심 교훈 #2: 데이터 품질 = 수익성\n평균 일일 변동폭: 2.09% 최대 변동폭: 14.44% 만약 데이터에 오류가 있어서 14.44% 변동일을 -50%로 잘못 기록했다면? 백테스트는 그날 손절매를 트리거하고 전략이 완전히 망가집니다 데이터 품질 확인은 선택이 아닌 필수입니다 핵심 교훈 #3: 타임프레임과 수익성\n일봉 (1년): +14.9%, 변동성 1.22% 주봉 (2년): +40.3%, 변동성 2.07% 월봉 (5년): +85.5%, 변동성 4.44% 장기 보유할수록 더 높은 수익률 (복리 효과) 하지만 변동성도 증가 (심리적 부담) 당신의 트레이딩 스타일이 타임프레임을 결정해야 합니다: 데이 트레이더: 1분/5분봉, 빠른 진입/청산 스윙 트레이더: 1시간/일봉, 며칠 보유 포지션 트레이더: 일봉/주봉, 몇 주~몇 달 보유 장기 투자자: 주봉/월봉, 몇 년 보유 생성된 차트는 6개의 서브플롯으로 구성되어 있으며, 각각 다른 측면의 데이터를 보여줍니다:\n1. AAPL 가격 추세 (좌상단)# 5년간 추세: $113 (2021년 최저점) → $288 (2025년 최고점) 주요 구간: 2021-2022: 완만한 상승 ($113 → $175) 2023: 횡보 구간 2024-2025: 급격한 상승 ($175 → $288) 2026년 초: 소폭 조정 거래량: 가격이 급변할 때 거래량도 함께 증가하는 패턴 2. 캔들스틱 차트 60일 (우상단)# 최근 60일간의 상세 가격 변동 녹색 캔들: 상승일 (종가 \u0026gt; 시가) 빨간색 캔들: 하락일 (종가 \u0026lt; 시가) 긴 위/아래 꼬리는 장중 변동성이 컸음을 의미 3. 다중 종목 비교 (좌하단)# 정규화된 비교 (시작점을 100으로 통일) GOOGL이 가장 높은 성과: 초기 대비 180% 상승 NVDA도 강한 상승세: 약 140% 상승 AAPL과 MSFT: 상대적으로 안정적인 상승 (120% 수준) 핵심 인사이트: 같은 기술 섹터라도 종목별 성과는 크게 다릅니다 4. 타임프레임 비교 (우하단)# 일봉 (파란색): 노이즈가 많지만 단기 트렌드 파악 가능 주봉 (녹색): 더 부드러운 추세선, 중기 추세 명확 월봉 (주황색): 가장 부드러운 곡선, 장기 추세만 보임 전략 적용: 장기 투자자는 월봉, 단기 트레이더는 일봉 활용 데이터 품질 관찰# 캔들스틱 패턴 분석 결과:\n상승 캔들 비율 53.5%는 장기적으로 상승 추세임을 의미 평균 몸통 크기 $1.86는 일일 평균 변동폭 위/아래 꼬리가 비슷하다는 것은 매수/매도 압력이 균형적임을 의미 일일 변동폭:\n평균 2.09%는 AAPL이 안정적인 대형주임을 보여줍니다 최대 변동폭 14.44%는 극단적 시장 상황(실적 발표, 시장 폭락 등) 이러한 이상치는 리스크 관리에서 중요한 고려사항입니다 2.8 데이터 저장 및 관리# CSV로 저장# # 데이터 저장 data.to_csv(\u0026#39;data/AAPL_daily_2020_2023.csv\u0026#39;) # 데이터 불러오기 import pandas as pd data = pd.read_csv(\u0026#39;data/AAPL_daily_2020_2023.csv\u0026#39;, index_col=\u0026#39;Date\u0026#39;, parse_dates=True)데이터 캐싱 전략# 문제: yfinance로 매번 다운로드하면 시간이 걸립니다.\n해결책: 로컬에 저장하고 재사용\nfrom pathlib import Path import pandas as pd import yfinance as yf def get_stock_data(ticker, start, end, force_download=False): \u0026#34;\u0026#34;\u0026#34; 주식 데이터를 가져오는 함수 (캐싱 포함) Parameters: ----------- ticker : str 종목 심볼 start : str 시작일 end : str 종료일 force_download : bool True면 항상 새로 다운로드 Returns: -------- pd.DataFrame OHLCV 데이터 \u0026#34;\u0026#34;\u0026#34; cache_dir = Path(\u0026#39;data\u0026#39;) cache_dir.mkdir(exist_ok=True) cache_file = cache_dir / f\u0026#34;{ticker}_{start}_{end}.csv\u0026#34; # 캐시 파일이 있고, 강제 다운로드가 아니면 캐시 사용 if cache_file.exists() and not force_download: print(f\u0026#34;캐시에서 {ticker} 데이터 로드 중...\u0026#34;) return pd.read_csv(cache_file, index_col=\u0026#39;Date\u0026#39;, parse_dates=True) # 새로 다운로드 print(f\u0026#34;Yahoo Finance에서 {ticker} 다운로드 중...\u0026#34;) data = yf.download(ticker, start=start, end=end, progress=False) # 캐시 저장 data.to_csv(cache_file) print(f\u0026#34;캐시 저장 완료: {cache_file}\u0026#34;) return data사용 예:\n# 첫 실행: 다운로드 후 저장 data = get_stock_data(\u0026#34;AAPL\u0026#34;, \u0026#34;2020-01-01\u0026#34;, \u0026#34;2023-12-31\u0026#34;) # 두 번째 실행: 캐시에서 즉시 로드 data = get_stock_data(\u0026#34;AAPL\u0026#34;, \u0026#34;2020-01-01\u0026#34;, \u0026#34;2023-12-31\u0026#34;)2.9 데이터 품질 확인# 결측치 확인# # 결측치 확인 print(data.isnull().sum()) # 결측치 비율 missing_pct = (data.isnull().sum() / len(data)) * 100 print(f\u0026#34;결측치 비율: {missing_pct:.2f}%\u0026#34;)데이터 연속성 확인# # 거래일 간 간격 확인 date_diff = data.index.to_series().diff() # 3일 이상 간격이 있는 경우 찾기 (주말 제외) gaps = date_diff[date_diff \u0026gt; pd.Timedelta(days=3)] if len(gaps) \u0026gt; 0: print(f\u0026#34;데이터 간격 발견: {len(gaps)}개\u0026#34;) print(gaps)이상치 탐지# # 일일 수익률 계산 returns = data[\u0026#39;Close\u0026#39;].pct_change() # 극단적 수익률 (±10% 이상) extreme_returns = returns[abs(returns) \u0026gt; 0.10] print(f\u0026#34;극단적 변동: {len(extreme_returns)}일\u0026#34;) print(extreme_returns)2.10 다음 단계# 이 챕터에서 배운 것# ✅ OHLCV 데이터 구조: Open, High, Low, Close, Volume의 의미 ✅ yfinance 사용법: 단일/다중 종목, 다양한 기간과 타임프레임 ✅ Adjusted Close: 배당금과 주식 분할 조정의 중요성 ✅ 다중 타임프레임: 일봉, 주봉, 월봉 데이터 활용 ✅ 데이터 관리: 저장, 캐싱, 품질 확인\n실습 과제# 다른 종목 탐색: Tesla (TSLA), Amazon (AMZN) 데이터를 다운로드하고 비교해보세요.\nETF 분석: S\u0026amp;P 500 ETF (SPY)와 Nasdaq ETF (QQQ)의 최근 5년 성과를 비교해보세요.\n타임프레임 비교: 같은 종목의 일봉과 월봉 차트를 그려보고, 어떤 차이가 있는지 관찰하세요.\n주식 분할 탐색: Apple이나 Tesla의 주식 분할 이력을 조회하고, Adjusted vs. Unadjusted Close를 비교해보세요.\n다음 챕터 미리보기# Chapter 3: 데이터 전처리와 수익률에서는:\n결측치 및 이상치 처리 방법 데이터 정합성 검증 기법 단순 수익률 vs. 로그 수익률 비교 벤치마크 대비 초과 수익률 계산 완전한 데이터 전처리 파이프라인 구축 💡 핵심 메시지: 수익성 관점에서의 데이터\n데이터는 백테스팅의 기초입니다. 양질의 데이터 없이는 신뢰할 수 있는 백테스트 결과를 얻을 수 없습니다.\n수익성에 직접 영향을 미치는 데이터 요소:\nAdjusted Close 미사용 → 주식 분할 시 -66% 손실로 오인 → 잘못된 손절매 → 실제 손실 결측치 처리 실패 → 전략이 잘못된 신호 생성 → 불필요한 거래 → 수수료 낭비 이상치 미탐지 → 극단적 변동을 정상으로 간주 → 과도한 리스크 → 예상치 못한 손실 잘못된 타임프레임 → 노이즈에 반응하는 전략 → 잦은 거래 → 수수료로 수익 감소 실용적 조언:\n✅ 항상 Adjusted Close 사용 (배당금, 주식 분할 자동 반영) ✅ 데이터 품질 확인 루틴 구축 (결측치, 이상치, 연속성) ✅ 여러 종목 비교하여 상대적 성과 확인 ✅ 적절한 타임프레임 선택 (트레이딩 스타일에 맞게) ✅ 데이터 캐싱으로 반복 작업 효율화 다음 챕터에서는 다운로드한 데이터를 정제하고 수익률을 계산하는 방법을 배워봅시다!\n"},{"id":2,"href":"/intro-to-backtesting/docs/chapter03/","title":"Chapter 3: 데이터 전처리와 수익률","section":"Docs","content":"Chapter 3: 데이터 전처리와 수익률# 이 챕터에서는 다운로드한 금융 데이터를 백테스팅에 적합한 형태로 전처리하는 방법을 배웁니다. 결측치 처리, 이상치 탐지, 데이터 정합성 검증을 다루고, 단순 수익률과 로그 수익률의 차이를 이해합니다.\n3.1 데이터 전처리의 필요성# 왜 전처리가 중요한가?# 다운로드한 원시 데이터(Raw Data)는 다음과 같은 문제를 가질 수 있습니다:\n결측치 (Missing Values): 휴장일, 상장폐지, 데이터 수집 오류 이상치 (Outliers): 비현실적인 가격 변동, 데이터 입력 오류 중복 데이터: 동일한 날짜의 중복 레코드 데이터 불일치: 논리적으로 맞지 않는 관계 (예: High \u0026lt; Low) 타임존 문제: 서로 다른 타임존의 데이터 혼재 이러한 문제들을 해결하지 않으면:\n❌ 잘못된 백테스팅 결과 ❌ 비현실적인 수익률 계산 ❌ 전략 실행 오류 (NaN, Inf 등) 3.2 결측치 처리# 결측치 확인# import pandas as pd # 데이터 로드 data = pd.read_csv(\u0026#39;data/AAPL_5y.csv\u0026#39;, index_col=\u0026#39;Date\u0026#39;, parse_dates=True) # 결측치 확인 print(data.isnull().sum()) # 결측치 비율 missing_pct = (data.isnull().sum() / len(data)) * 100 print(f\u0026#34;\\n결측치 비율:\u0026#34;) print(missing_pct)결측치 처리 방법# 방법 1: 삭제 (Deletion)\n# 결측치가 있는 행 삭제 data_clean = data.dropna() # 특정 컬럼의 결측치만 삭제 data_clean = data.dropna(subset=[\u0026#39;Close\u0026#39;, \u0026#39;Volume\u0026#39;])장점: 간단하고 명확 단점: 데이터 손실, 시계열 연속성 깨짐\n방법 2: 전방 채우기 (Forward Fill)\n# 이전 값으로 채우기 data_filled = data.fillna(method=\u0026#39;ffill\u0026#39;) # 또는 data_filled = data.ffill()장점: 시계열 연속성 유지 단점: 장기간 결측 시 부정확\n방법 3: 보간 (Interpolation)\n# 선형 보간 data_interpolated = data.interpolate(method=\u0026#39;linear\u0026#39;) # 시계열 보간 data_interpolated = data.interpolate(method=\u0026#39;time\u0026#39;)장점: 더 정확한 추정 단점: 실제 데이터 아님\n권장 사항# 금융 데이터의 경우:\n가격 데이터: Forward fill 사용 (주말/휴장일은 이전 종가 유지) 거래량: 0으로 채우거나 삭제 긴 공백: 삭제 권장 (데이터 신뢰성 문제) 3.3 이상치 탐지# 이상치란?# **이상치(Outlier)**는 다른 데이터와 크게 다른 값입니다. 금융 데이터에서:\n정상적 이상치: 실제 극단적 시장 상황 (블랙 먼데이, 플래시 크래시) 비정상적 이상치: 데이터 오류, 입력 실수 이상치 탐지 방법# 방법 1: 통계적 방법 (Z-Score)\n$$Z = \\frac{X - \\mu}{\\sigma}$$$|Z| \u003e 3$ 이면 이상치로 간주\n방법 2: IQR (Interquartile Range)\n$$IQR = Q3 - Q1$$ $$Outlier: X \u003c Q1 - 1.5 \\times IQR \\text{ or } X \u003e Q3 + 1.5 \\times IQR$$중요: 금융 데이터에서는 이상치를 삭제하지 않는 것이 원칙입니다!\n이유:\n실제 시장 상황 반영 극단적 상황에서의 전략 테스트 필요 리스크 관리 검증 3.4 데이터 정합성 검증# 가격 논리 검증# OHLCV 데이터는 다음 관계를 만족해야 합니다:\n$$High \\geq \\max(Open, Close)$$ $$Low \\leq \\min(Open, Close)$$ $$High \\geq Low$$ $$Volume \\geq 0$$3.5 수익률 계산# 단순 수익률 (Simple Returns)# 정의: $$R_t = \\frac{P_t - P_{t-1}}{P_{t-1}} = \\frac{P_t}{P_{t-1}} - 1$$특징:\n✅ 직관적이고 이해하기 쉬움 ✅ 실제 손익과 직접 연결 ❌ 시간 가산성 없음 (여러 기간 합산 불가) # Pandas로 계산 simple_returns = data[\u0026#39;Close\u0026#39;].pct_change() # 수동 계산 simple_returns = (data[\u0026#39;Close\u0026#39;] / data[\u0026#39;Close\u0026#39;].shift(1)) - 1로그 수익률 (Log Returns)# 정의: $$r_t = \\ln\\left(\\frac{P_t}{P_{t-1}}\\right) = \\ln(P_t) - \\ln(P_{t-1})$$특징:\n✅ 시간 가산성: $r_{total} = r_1 + r_2 + ... + r_n$ ✅ 대칭성: 상승 10%, 하락 10%가 대칭적 ✅ 통계적 특성 우수 (정규분포에 가까움) ❌ 직관적이지 않음 # Pandas로 계산 log_returns = np.log(data[\u0026#39;Close\u0026#39;] / data[\u0026#39;Close\u0026#39;].shift(1)) # 또는 log_returns = np.log(data[\u0026#39;Close\u0026#39;]).diff()단순 vs. 로그 수익률 비교# 언제 무엇을 사용할까?\n용도 권장 일반 백테스팅 단순 수익률 통계 분석 로그 수익률 포트폴리오 최적화 로그 수익률 사용자 리포트 단순 수익률 리스크 모델링 로그 수익률 누적 수익률 계산# 단순 수익률의 누적: $$R_{cumulative} = \\prod_{t=1}^{n}(1 + R_t) - 1$$# 방법 1: cumprod cumulative_returns = (1 + simple_returns).cumprod() - 1 # 방법 2: 가격 비율 cumulative_returns = data[\u0026#39;Close\u0026#39;] / data[\u0026#39;Close\u0026#39;].iloc[0] - 1로그 수익률의 누적: $$r_{cumulative} = \\sum_{t=1}^{n} r_t$$cumulative_log_returns = log_returns.cumsum() # 단순 수익률로 변환 cumulative_simple_from_log = np.exp(cumulative_log_returns) - 13.6 벤치마크 비교# 벤치마크란?# **벤치마크(Benchmark)**는 전략 성과를 평가하기 위한 비교 기준입니다.\n일반적인 벤치마크:\nS\u0026amp;P 500 (SPY): 미국 대형주 Nasdaq 100 (QQQ): 미국 기술주 Russell 2000 (IWM): 미국 소형주 국채 ETF (TLT): 채권 개별 종목: 해당 종목의 Buy \u0026amp; Hold 초과 수익률 (Excess Returns)# 전략의 실제 가치는 벤치마크 대비 초과 수익률로 측정됩니다.\n$$\\text{Excess Return} = R_{strategy} - R_{benchmark}$$3.7 실습: 데이터 전처리 파이프라인# 이제 완전한 데이터 전처리 파이프라인을 실행해봅시다.\n코드 실행# cd codes uv run chapter03/01_data_preprocessing.py실행 결과 분석# 스크립트를 실행한 결과입니다:\n========================================== Chapter 3: 데이터 전처리와 수익률 ========================================== === 원시 데이터 로드 === 데이터 기간: 2021-02-08 ~ 2026-02-04 총 데이터 포인트: 1254개 ========================================== === 데이터 품질 분석 === ========================================== 결측치: Open : 0 High : 0 Low : 0 Close : 0 Volume : 0 Dividends : 0 Stock Splits: 0 중복 날짜: 0개 시간 순 정렬: ✓ 평균 거래일 간격: 1 days 08:58:42 ========================================== === 가격 논리 검증 === ========================================== High \u0026gt;= Close: ✓ High \u0026gt;= Open: ✓ Low \u0026lt;= Close: ✓ Low \u0026lt;= Open: ✓ High \u0026gt;= Low: ✓ Volume \u0026gt;= 0: ✓ 전체 검증: 통과 ✓ ========================================== === 이상치 탐지 (Z-Score) === ========================================== 발견된 이상치: 14개 이상치 날짜 (처음 5개): 2021-03-01: +0.0539 (+5.39%) 2022-01-28: +0.0698 (+6.98%) 2022-05-05: -0.0557 (-5.57%) 2022-05-11: -0.0518 (-5.18%) 2022-05-18: -0.0564 (-5.64%) ========================================== === 수익률 계산 === ========================================== 단순 수익률: - 평균: 0.0007 (0.07%) - 표준편차: 0.0174 (1.74%) - 최대: +0.1533 (+15.33%) - 최소: -0.0925 (-9.25%) 로그 수익률: - 평균: 0.0006 (0.06%) - 표준편차: 0.0174 (1.74%) - 최대: +0.1426 (+14.26%) - 최소: -0.0970 (-9.70%) 누적 수익률: - 단순 수익률: +1.0715 (+107.15%) - 로그 수익률: +1.0715 (+107.15%) ========================================== === 벤치마크 비교 (vs SPY) === ========================================== AAPL 수익률: +107.15% SPY 수익률: +89.15% 초과 수익률: +17.99%\n차트 해석# 생성된 차트는 6개의 서브플롯으로 구성되어 있습니다:\n1. AAPL 가격 추세 (좌상단)# 5년간 $113 → $234로 약 2배 상승 2022년 하반기와 2024년 말 두 차례 큰 조정 구간 전반적으로 우상향 추세 유지 2. 단순 수익률 분포 (우상단)# 정규분포에 가까운 형태: 대부분의 일일 수익률은 ±2% 이내 평균 0.07%: 약간의 양의 편향 (장기 상승 추세 반영) 빨간 선 (평균선): 0에 가까움 긴 꼬리: 극단적 수익률(±10% 이상)도 존재 3. 로그 수익률 분포 (좌중단)# 단순 수익률과 거의 동일한 분포 일일 수익률이 작을 때는 두 수익률의 차이가 미미 대칭성이 더 좋음: 평균 주변으로 더 균등한 분포 4. 누적 수익률 비교 (우중단)# 보라색 선 (단순 수익률): 복리 효과로 계산 주황색 점선 (로그 수익률): 두 선이 거의 일치 핵심 인사이트: 일일 수익률 기준에서는 두 방법이 동일한 결과 최종 누적 수익률: +107.15% 5. AAPL vs SPY 비교 (좌하단)# AAPL (파란색): 더 높은 수익률과 변동성 SPY (주황색): 더 안정적이지만 낮은 수익률 정규화된 비교에서 AAPL이 SPY를 약 18% 초과 달성 2022년 조정: 두 자산 모두 하락했지만 AAPL이 더 크게 하락 6. 일일 수익률 시계열 (우하단)# 시간에 따른 변동성 변화 관찰 2022년 중반: 변동성 증가 (±5% 이상 움직임 빈번) 2023년: 변동성 감소 (안정적인 구간) 최근: 다시 변동성 증가 추세 평균선 (빨간색): 장기 평균 수익률 +0.07% 데이터 품질 인사이트# 결측치 없음 (0개):\nyfinance에서 다운로드한 데이터는 품질이 우수합니다 추가 전처리가 거의 필요 없습니다 이상치 14개 발견:\n전체 1254개 중 14개 (1.1%) 대부분 실제 시장 이벤트 (실적 발표, 시장 폭락) 중요: 이러한 이상치를 제거하지 않았습니다 이유: 실제 트레이딩에서도 발생할 수 있는 상황 백테스팅은 현실을 반영해야 함 단순 vs 로그 수익률:\n일일 수익률에서는 거의 차이가 없음 극단적 수익률에서만 미미한 차이 발생 백테스팅에서는 단순 수익률 선호 (직관적) 통계 분석에서는 로그 수익률 선호 (시간 가산성) 벤치마크 대비 성과와 수익성 교훈:\nAAPL: +107.15% (변동성: 1.74%) SPY: +89.15% (변동성: ?) 초과 수익: +17.99%⚠️ 수익성 함정 주의: 이 결과를 보고 \u0026ldquo;AAPL이 SPY보다 17.99% 더 좋다!\u0026ldquo;라고 결론내리면 안 됩니다!\n수익성 분석 체크리스트:\n절대 수익률만 보지 마세요 ❌\nAAPL: +107% 좋아 보임 하지만 SPY: +89%도 충분히 좋음 차이는 18%p인데 이것이 의미 있는 차이인가? 리스크를 고려하세요 ✅\nAAPL 변동성: 1.74% (일일) SPY는 아마도 ~1.0% (더 낮음) AAPL은 74% 더 높은 변동성을 가짐 높은 변동성 = 더 큰 손실 가능성 리스크 조정 수익률이 진실 ✅\n같은 리스크를 감수했을 때 어느 것이 더 나은가? Sharpe Ratio = (수익률 - 무위험 수익률) / 변동성 다음 챕터들에서 이를 계산할 예정 실용적 의미 ✅\n만약 당신이 10% 하락을 견딜 수 없다면: AAPL 최대 하락: -9.25% (하루에!) 이런 변동성을 견딜 수 있습니까? 만약 못 견디면, 낮은 수익률이라도 SPY가 더 나은 선택 진정한 수익성 질문:\n❌ \u0026ldquo;어느 것이 더 많이 벌었나?\u0026rdquo; (절대 수익) ✅ \u0026ldquo;같은 리스크로 어느 것이 더 효율적인가?\u0026rdquo; (리스크 조정 수익) ✅ \u0026ldquo;내가 감당할 수 있는 리스크 범위에서 최선의 선택은?\u0026rdquo; (개인화) 핵심 교훈: 백테스팅에서 \u0026ldquo;초과 수익률\u0026quot;을 발견했다면, 항상 \u0026ldquo;그 초과 수익이 추가 리스크를 감수할 가치가 있는가?\u0026ldquo;를 물어야 합니다. 다음 챕터에서 리스크 조정 수익률(Sharpe Ratio)로 제대로 비교할 예정입니다.\n이 스크립트는 다음을 수행합니다:\n원시 데이터 로드: Chapter 2에서 다운로드한 AAPL 데이터 데이터 품질 분석: 결측치, 중복, 이상치 확인 전처리 실행: 결측치 처리, 정합성 검증 수익률 계산: 단순 및 로그 수익률 벤치마크 비교: S\u0026amp;P 500 (SPY) 대비 성과 시각화: 전처리 전후 비교, 수익률 분포, 벤치마크 비교 3.8 다음 단계# 이 챕터에서 배운 것# ✅ 결측치 처리: Forward fill, 삭제, 보간 방법 ✅ 이상치 탐지: Z-Score, IQR 방법 ✅ 데이터 검증: 가격 논리, 시계열 연속성 ✅ 수익률 계산: 단순 vs. 로그 수익률 ✅ 벤치마크 비교: 초과 수익률, 상대 성과 ✅ 전처리 파이프라인: 완전한 데이터 정제 프로세스\n실습 과제# 다른 종목 전처리: Tesla (TSLA) 또는 Microsoft (MSFT) 데이터를 전처리하고 AAPL과 비교해보세요.\n이상치 영향 분석: 이상치를 포함한 경우와 제외한 경우의 통계를 비교해보세요.\n다양한 벤치마크: SPY 외에 QQQ, IWM 등 다른 벤치마크와 비교해보세요.\n수익률 변환: 단순 수익률과 로그 수익률의 차이가 큰 경우를 찾아보세요.\n다음 챕터 미리보기# Chapter 4: Backtrader 프레임워크 기초에서는:\nBacktrader 아키텍처 이해 (Cerebro, Strategy, Data Feeds) 첫 번째 전략: Buy \u0026amp; Hold 구현 주문 실행과 포지션 관리 기본 성과 분석 (Analyzers 사용) 실전 백테스팅 시작 💡 핵심 메시지: 수익성과 데이터 전처리\n깨끗한 데이터는 신뢰할 수 있는 백테스팅의 기초입니다. 하지만 데이터를 \u0026ldquo;너무 깨끗하게\u0026rdquo; 만들면 위험합니다!\n실전 수익성에 영향을 주는 데이터 처리 결정:\n이상치를 제거하면? ❌\n백테스트: +150% (이상적인 결과) 실전: -30% (극단적 상황에서 전략 붕괴) 교훈: 이상치는 리스크 테스트의 핵심 결측치를 보간으로 채우면? ⚠️\n백테스트: 부드러운 수익 곡선 실전: 거래 불가능한 시점에 진입 시도 → 실패 교훈: Forward fill이 더 현실적 벤치마크를 안 보면? ❌\n전략: +100% (와! 대박!) 벤치마크: +150% (그냥 사서 보유가 나았음) 교훈: 절대 수익이 아닌 상대 성과가 중요 변동성을 무시하면? ❌\n높은 수익 = 좋은 전략? No! 높은 수익 + 낮은 변동성 = 좋은 전략 Yes! 교훈: 리스크 조정 수익률이 진짜 지표 실용적 조언: 데이터 전처리는 \u0026ldquo;이상적인 데이터\u0026quot;를 만드는 것이 아니라 \u0026ldquo;현실을 정확히 반영하는 데이터\u0026quot;를 만드는 것입니다. 극단적 상황, 결측치, 변동성을 제거하면 백테스트는 좋아 보이지만 실전에서 실패합니다.\n다음 챕터에서는 드디어 Backtrader를 사용하여 실제 트레이딩 전략을 구현해봅시다!\n"},{"id":3,"href":"/intro-to-backtesting/docs/chapter04/","title":"Chapter 4: Backtrader 프레임워크 기초","section":"Docs","content":"Chapter 4: Backtrader 프레임워크 기초# 이 챕터에서는 Python의 대표적인 백테스팅 프레임워크인 Backtrader를 본격적으로 사용합니다. Backtrader의 아키텍처를 이해하고, 첫 번째 실전 전략인 Buy \u0026amp; Hold를 구현하며, 기본적인 성과 분석 방법을 배웁니다.\n4.1 Backtrader란?# Backtrader 소개# Backtrader는 Python으로 작성된 오픈소스 백테스팅 프레임워크입니다.\n주요 특징:\n✅ 완전한 기능: Strategy, Indicators, Analyzers, Observers 등 ✅ 유연성: 다양한 전략과 지표를 쉽게 구현 ✅ 성능: 효율적인 데이터 처리 ✅ 시각화: 내장 플로팅 기능 ✅ 활발한 커뮤니티: 풍부한 문서와 예제 공식 사이트: https://www.backtrader.com/\n왜 Backtrader인가?# 다른 백테스팅 라이브러리와 비교:\n라이브러리 장점 단점 Backtrader 완전한 기능, 유연성 학습 곡선 Zipline Quantopian 출신, 강력 유지보수 중단 Backtesting.py 간단함, 빠름 제한적 기능 VectorBT 빠른 속도, 벡터화 복잡한 전략 어려움 Backtrader는 기능의 완전성과 유연성에서 최고의 선택입니다.\n4.2 Backtrader 아키텍처# 핵심 구성 요소# Backtrader는 다음 4가지 핵심 요소로 구성됩니다:\n┌─────────────────────────────────────┐ │ Cerebro (엔진) │ │ ┌───────────────────────────────┐ │ │ │ Strategy (전략) │ │ │ │ - __init__: 초기화 │ │ │ │ - next: 매 바마다 실행 │ │ │ │ - notify_order: 주문 알림 │ │ │ │ - notify_trade: 거래 알림 │ │ │ └───────────────────────────────┘ │ │ ┌───────────────────────────────┐ │ │ │ Data Feeds (데이터) │ │ │ │ - CSV, Pandas, Yahoo, 등 │ │ │ └───────────────────────────────┘ │ │ ┌───────────────────────────────┐ │ │ │ Analyzers (분석기) │ │ │ │ - Sharpe, Drawdown, Returns │ │ │ └───────────────────────────────┘ │ └─────────────────────────────────────┘1. Cerebro (대뇌)# 역할: 전체 백테스팅 엔진의 중앙 컨트롤러\nimport backtrader as bt cerebro = bt.Cerebro() # Cerebro 인스턴스 생성 # 설정 cerebro.addstrategy(MyStrategy) # 전략 추가 cerebro.adddata(data) # 데이터 추가 cerebro.broker.setcash(10000) # 초기 자본금 cerebro.broker.setcommission(0.001) # 수수료 0.1% # 실행 results = cerebro.run()2. Strategy (전략)# 역할: 트레이딩 로직을 정의하는 클래스\nclass MyStrategy(bt.Strategy): def __init__(self): \u0026#34;\u0026#34;\u0026#34;초기화: 지표 계산 등\u0026#34;\u0026#34;\u0026#34; self.sma = bt.indicators.SMA(self.data.close, period=20) def next(self): \u0026#34;\u0026#34;\u0026#34;매 바(일)마다 실행되는 메인 로직\u0026#34;\u0026#34;\u0026#34; if not self.position: # 포지션이 없으면 if self.data.close[0] \u0026gt; self.sma[0]: self.buy() # 매수 else: # 포지션이 있으면 if self.data.close[0] \u0026lt; self.sma[0]: self.sell() # 매도주요 메서드:\n__init__(): 전략 초기화, 지표 생성 next(): 매 바마다 실행 (핵심 로직) notify_order(): 주문 상태 변경 알림 notify_trade(): 거래 완료 알림 stop(): 백테스트 종료 시 호출 3. Data Feeds (데이터 피드)# 역할: 전략에 시장 데이터 제공\n# Pandas DataFrame에서 데이터 로드 data = bt.feeds.PandasData(dataname=df) # CSV 파일에서 데이터 로드 data = bt.feeds.GenericCSVData( dataname=\u0026#39;AAPL_5y.csv\u0026#39;, datetime=0, open=1, high=2, low=3, close=4, volume=5 ) cerebro.adddata(data)4. Analyzers (분석기)# 역할: 백테스트 성과 분석\n# Analyzer 추가 cerebro.addanalyzer(bt.analyzers.SharpeRatio, _name=\u0026#39;sharpe\u0026#39;) cerebro.addanalyzer(bt.analyzers.DrawDown, _name=\u0026#39;drawdown\u0026#39;) cerebro.addanalyzer(bt.analyzers.Returns, _name=\u0026#39;returns\u0026#39;) # 실행 후 결과 확인 results = cerebro.run() strat = results[0] print(f\u0026#34;Sharpe Ratio: {strat.analyzers.sharpe.get_analysis()[\u0026#39;sharperatio\u0026#39;]:.3f}\u0026#34;) print(f\u0026#34;Max Drawdown: {strat.analyzers.drawdown.get_analysis()[\u0026#39;max\u0026#39;][\u0026#39;drawdown\u0026#39;]:.2f}%\u0026#34;)4.3 데이터 접근 방법# 인덱싱 규칙# Backtrader는 0-based indexing을 사용하지만 역순입니다:\nself.data.close[0] # 현재 종가 self.data.close[-1] # 이전 종가 self.data.close[-2] # 2일 전 종가 self.data.high[0] # 현재 고가 self.data.low[0] # 현재 저가 self.data.volume[0] # 현재 거래량주의: [0]이 현재, [-1]이 과거입니다!\nLines 개념# Backtrader는 Lines 개념을 사용합니다:\n# OHLCV는 기본 Lines self.data.close # Close line self.data.open # Open line self.data.high # High line self.data.low # Low line self.data.volume # Volume line # 지표도 Lines self.sma = bt.indicators.SMA(period=20) self.sma[0] # 현재 SMA 값4.4 주문 실행# 기본 주문 메서드# # 매수 self.buy() # 시장가 전량 매수 self.buy(size=100) # 100주 매수 self.buy(price=150.0) # 지정가 매수 # 매도 self.sell() # 포지션 전량 매도 self.sell(size=50) # 50주 매도 self.close() # 포지션 청산 (매도와 동일)주문 추적# class MyStrategy(bt.Strategy): def __init__(self): self.order = None def next(self): # 대기 중인 주문이 있으면 건너뛰기 if self.order: return if not self.position: self.order = self.buy() def notify_order(self, order): \u0026#34;\u0026#34;\u0026#34;주문 상태 변경 알림\u0026#34;\u0026#34;\u0026#34; if order.status in [order.Completed]: if order.isbuy(): print(f\u0026#39;매수 체결: {order.executed.price:.2f}\u0026#39;) elif order.issell(): print(f\u0026#39;매도 체결: {order.executed.price:.2f}\u0026#39;) self.order = None # 주문 완료, 초기화 elif order.status in [order.Canceled, order.Margin, order.Rejected]: print(\u0026#39;주문 취소/거부\u0026#39;) self.order = None포지션 관리# # 현재 포지션 확인 if self.position: print(f\u0026#39;보유 주식: {self.position.size}주\u0026#39;) print(f\u0026#39;평균 매수가: {self.position.price:.2f}\u0026#39;) # 포지션 여부 if not self.position: # 포지션 없음 self.buy() if self.position: # 포지션 있음 self.sell()4.5 첫 번째 전략: Buy \u0026amp; Hold# Buy \u0026amp; Hold 전략이란?# **Buy \u0026amp; Hold (매수 후 보유)**는 가장 간단한 투자 전략입니다:\n백테스트 시작 시점에 매수 끝까지 보유 종료 시점에 매도 이 전략은 벤치마크로 자주 사용됩니다.\n전략 구현# class BuyAndHoldStrategy(bt.Strategy): \u0026#34;\u0026#34;\u0026#34; Buy \u0026amp; Hold 전략 첫 거래일에 매수하고 끝까지 보유 \u0026#34;\u0026#34;\u0026#34; def __init__(self): \u0026#34;\u0026#34;\u0026#34;초기화\u0026#34;\u0026#34;\u0026#34; self.order = None self.buy_price = None self.buy_comm = None def next(self): \u0026#34;\u0026#34;\u0026#34;매 바마다 실행\u0026#34;\u0026#34;\u0026#34; # 이미 주문이 있으면 대기 if self.order: return # 포지션이 없으면 매수 if not self.position: # 사용 가능한 모든 자금으로 매수 self.order = self.buy() print(f\u0026#39;{self.data.datetime.date(0)}: 매수 주문 실행\u0026#39;) def notify_order(self, order): \u0026#34;\u0026#34;\u0026#34;주문 상태 변경 알림\u0026#34;\u0026#34;\u0026#34; if order.status in [order.Submitted, order.Accepted]: # 주문 제출/접수 - 아무것도 하지 않음 return if order.status in [order.Completed]: if order.isbuy(): self.buy_price = order.executed.price self.buy_comm = order.executed.comm print(f\u0026#39;매수 체결: 가격 ${order.executed.price:.2f}, \u0026#39; f\u0026#39;수수료 ${order.executed.comm:.2f}\u0026#39;) self.order = None def notify_trade(self, trade): \u0026#34;\u0026#34;\u0026#34;거래 완료 알림\u0026#34;\u0026#34;\u0026#34; if trade.isclosed: print(f\u0026#39;거래 종료: 손익 ${trade.pnl:.2f}\u0026#39;) def stop(self): \u0026#34;\u0026#34;\u0026#34;백테스트 종료 시 호출\u0026#34;\u0026#34;\u0026#34; print(f\u0026#39;\\n최종 포트폴리오 가치: ${self.broker.getvalue():.2f}\u0026#39;)4.6 실습: Buy \u0026amp; Hold 백테스트# 이제 실제로 Buy \u0026amp; Hold 전략을 백테스트해봅시다.\n코드 실행# cd codes uv run chapter04/01_buy_and_hold.py스크립트 개요# 이 스크립트는 다음을 수행합니다:\n데이터 로드: Chapter 2에서 저장한 AAPL 데이터 Cerebro 설정: 초기 자금, 수수료 설정 전략 실행: Buy \u0026amp; Hold 전략 백테스트 성과 분석: Analyzers를 사용한 상세 분석 시각화: 포트폴리오 가치, 거래 기록 차트 실행 결과 분석# 실제 스크립트를 실행한 결과입니다:\n========================================== Chapter 4: Backtrader 프레임워크 기초 ========================================== === Buy \u0026amp; Hold 전략 백테스트 === 초기 설정: - 초기 자금: $10,000.00 - 수수료: 0.10% - 데이터: AAPL 백테스트 실행 중... 2021-02-08: 매수 주문 실행 2021-02-09: 매수 체결: 가격 $133.19, 비용 $9479.88, 수수료 $9.48 2026-02-04: 최종 포트폴리오 가치: $20189.72 ========================================== === 성과 분석 === ========================================== 기본 지표: - 초기 자금: $10,000.00 - 최종 자금: $20,189.72 - 총 수익률: +101.90% Sharpe Ratio: 0.603 최대 낙폭: - Max Drawdown: 32.46% - DD Duration: 354 days 수익률: - Total Return: +70.26% - Annualized Return: +15.16% 거래 통계: - 총 거래: 1 - 승: 0, 패: 0 - 승률: 0.0% ========================================== === 벤치마크 비교 (vs SPY) === ========================================== AAPL Buy \u0026amp; Hold: +101.90% SPY: +89.15% 초과 수익: +12.74% 차트 저장 완료: chapter04/images/buy_and_hold.png\n결과 해석# 차트 분석# 상단 패널: AAPL 주가 차트\n녹색 삼각형 (▲): 매수 시점 (2021-02-09, $133.19) 5년간 주가는 $133 → $248로 약 86% 상승 두 차례 큰 조정 구간: 2022년 하반기: $170 → $123 (-27.6%) 2024년 말: $250 → $174 (-30.4%) 최종 주가: $248 (2026-02-04) 하단 패널: 포트폴리오 가치\n보라색 실선: 백테스트 포트폴리오 가치 점선: 초기 자금 $10,000 주가 움직임과 정확히 일치하는 모습 최종 가치: $20,189.72 (약 2배) 성과 지표 분석# 1. 총 수익률: +101.90%\n초기 $10,000 → 최종 $20,189.72 5년간 약 2배 수익 복리 효과를 포함한 실제 수익률 2. 연간 수익률: +15.16%\n5년간 평균 연 15.16% 수익 S\u0026amp;P 500 장기 평균 (약 10%)보다 높은 수치 계산: $(20189.72 / 10000)^{1/5} - 1 = 0.1516$ 3. Sharpe Ratio: 0.603\n위험 대비 수익률 측정 일반적 해석: \u0026lt; 1.0: 보통 1.0~2.0: 좋음 2.0: 매우 좋음\n0.603은 보통 수준: 수익은 있지만 변동성도 상당함 4. Maximum Drawdown: -32.46%\n고점 대비 최대 낙폭 2024년 말 조정 시 발생 ($250 → $174) 의미: 최악의 경우 자산이 32% 하락할 수 있음 투자자는 이 정도의 손실을 견딜 수 있어야 함 5. Drawdown Duration: 354일\n고점 회복에 걸린 최장 기간 약 1년간 손실 상태 지속 심리적 압박: 장기간 손실 상태는 투자자의 인내심을 시험 벤치마크 비교# AAPL vs SPY:\nAAPL: +101.90% SPY: +89.15% 초과 수익: +12.74% 해석:\nAAPL이 시장(SPY)을 13% 초과 달성 하지만 개별 주식은 더 높은 리스크(변동성)를 동반 Sharpe Ratio로 비교하면 리스크 조정 후 차이는 더 작을 것 거래 비용 영향# 수수료 분석:\n매수 비용: $9,479.88 수수료: $9.48 (0.1%) 수수료 비율: 전체 수익의 약 0.05% 인사이트:\nBuy \u0026amp; Hold는 거래가 1회뿐이므로 수수료 영향 최소 빈번한 거래 전략은 수수료가 수익률에 큰 영향 다음 챕터에서 다룰 이동평균 전략에서 이를 확인할 예정 실전 적용 고려사항# 장점:\n✅ 간단한 전략 (매수 후 보유만) ✅ 거래 비용 최소화 ✅ 장기적으로 시장 상승 추세 활용 ✅ 감정적 결정 배제 단점:\n❌ 큰 낙폭 (-32%) 견뎌야 함 ❌ 조정 구간에서 손실 축소 불가 ❌ 하락장에서 무력함 ❌ 타이밍의 중요성 (매수 시점) 누가 사용해야 하는가?\n장기 투자자 (5년 이상) 높은 변동성을 견딜 수 있는 투자자 시장 타이밍을 잡기 어렵다고 생각하는 투자자 적극적 관리 시간이 없는 투자자 백테스팅의 가치# 이 간단한 Buy \u0026amp; Hold 백테스트를 통해 우리는:\n실제 성과 확인: 5년간 +101.9% 수익 (이론이 아닌 실제) 리스크 파악: 최대 -32% 하락 가능성 인지 심리적 준비: 1년간 손실 상태를 견뎌야 할 수도 있음 벤치마크 비교: SPY 대비 +13% 초과 수익 확인 전략 개선 방향: 조정 구간에서 손실을 줄일 방법 필요 수익성의 진실: Buy \u0026amp; Hold가 이기기 어려운 벤치마크다# ⚠️ 가장 중요한 수익성 교훈: 이 단순한 Buy \u0026amp; Hold 결과가 바로 당신이 개발할 모든 복잡한 전략이 넘어야 할 최소 기준입니다.\nBuy \u0026amp; Hold 성과: - 총 수익률: +101.90% - 연간 수익률: +15.16% - Sharpe Ratio: 0.603 - 최대 낙폭: -32.46% - 거래 횟수: 1회 - 거래 비용: $9.48현실 체크: Chapter 5의 이동평균 전략 미리보기\n다음 챕터에서 배울 SMA(50/200) 골든크로스 전략의 실제 결과:\nSMA 전략 성과: - 총 수익률: +11.07% ← Buy \u0026amp; Hold보다 -90.8% 낮음! - Sharpe Ratio: 0.266 ← Buy \u0026amp; Hold의 절반도 안 됨 - 최대 낙폭: -14.41% ← 이것만 더 나음 - 거래 횟수: 2회 - 거래 비용: ~$30-40충격적인 사실: 복잡한 이동평균 전략이 단순히 사서 보유하는 것보다 90% 이상 낮은 수익을 냈습니다!\n왜 이런 일이 발생하는가?\n강세장에서는 계속 보유가 최선\n2021-2026년 AAPL은 강한 상승 추세 매도 신호로 현금 전환 시 상승 놓침 재진입 시점은 이미 가격이 올라간 후 신호 지연 (Signal Lag)\n이동평균은 과거 데이터 기반 200일 이동평균은 200일 전 ~ 오늘까지의 평균 트렌드가 이미 진행된 후에야 신호 발생 거래 비용 누적\nBuy \u0026amp; Hold: 1회 거래, $9.48 수수료 SMA 전략: 2회 거래, $30-40 수수료 거래가 많을수록 수수료가 수익 잠식 타이밍 불일치\n매도 신호: 종종 너무 늦음 (이미 많이 하락한 후) 매수 신호: 종종 너무 늦음 (이미 많이 상승한 후) 그렇다면 왜 복잡한 전략을 배우는가?\n이것이 이 책의 핵심 질문입니다. 답은:\n✅ 시장 환경이 다를 때를 대비\n2008 금융위기: -50% 하락 (Buy \u0026amp; Hold 참담) 2000 닷컴 버블: -80% 하락 (Buy \u0026amp; Hold 파멸) 횡보장: 10년간 제자리 (Buy \u0026amp; Hold 무의미) ✅ 리스크 조정 후 더 나을 수 있음\nSMA는 최대 낙폭 -14% (vs -32%) 심리적으로 견디기 쉬움 일부 투자자는 높은 수익보다 낮은 변동성 선호 ✅ 여러 전략 조합\n강세장: Buy \u0026amp; Hold 비중 높임 약세장: 방어적 전략 비중 높임 시장 체제 감지가 핵심 수익성 체크리스트: 전략 평가 시 필수 질문\n질문 Buy \u0026amp; Hold 당신의 전략 절대 수익률이 더 높은가? 101.90% ? 리스크 조정 수익률(Sharpe)이 더 높은가? 0.603 ? 최대 낙폭이 더 낮은가? -32.46% ? 거래 비용을 고려했는가? $9.48 ? 다양한 시장 환경에서 테스트했는가? 강세장만 ? 모든 칸에서 \u0026ldquo;Yes\u0026quot;가 아니면, 그 전략은 실전에서 실패할 가능성이 높습니다.\n실용적 조언:\n먼저 Buy \u0026amp; Hold 백테스트를 항상 실행하세요 새 전략은 반드시 Buy \u0026amp; Hold와 비교하세요 수익률만 보지 말고 Sharpe Ratio, Max DD도 비교하세요 강세장에서 이기지 못해도 괜찮습니다 - 약세장에서 방어가 목표일 수 있습니다 \u0026ldquo;이기기\u0026rdquo; 위해 필요한 것: 더 높은 Sharpe Ratio 또는 더 낮은 Max DD 다음 챕터에서는 이동평균을 활용하여 조정 구간에서 현금으로 전환하는 전략을 배워봅시다! (단, 현실적인 기대치를 가지고 접근합니다)\n4.7 Analyzers를 사용한 성과 분석# 주요 Analyzers# Backtrader는 다양한 내장 Analyzers를 제공합니다:\n1. SharpeRatio (샤프 비율)\n위험 대비 수익률:\n$$\\text{Sharpe Ratio} = \\frac{E[R - R_f]}{\\sigma}$$cerebro.addanalyzer(bt.analyzers.SharpeRatio, _name=\u0026#39;sharpe\u0026#39;, riskfreerate=0.01) # 무위험 이자율 1% sharpe = results[0].analyzers.sharpe.get_analysis() print(f\u0026#34;Sharpe Ratio: {sharpe[\u0026#39;sharperatio\u0026#39;]:.3f}\u0026#34;)2. DrawDown (낙폭)\n최대 손실폭:\n$$\\text{MDD} = \\max_{t}\\left(\\frac{Peak - Trough}{Peak}\\right)$$cerebro.addanalyzer(bt.analyzers.DrawDown, _name=\u0026#39;drawdown\u0026#39;) dd = results[0].analyzers.drawdown.get_analysis() print(f\u0026#34;Max Drawdown: {dd[\u0026#39;max\u0026#39;][\u0026#39;drawdown\u0026#39;]:.2f}%\u0026#34;) print(f\u0026#34;DD Duration: {dd[\u0026#39;max\u0026#39;][\u0026#39;len\u0026#39;]} days\u0026#34;)3. Returns (수익률)\ncerebro.addanalyzer(bt.analyzers.Returns, _name=\u0026#39;returns\u0026#39;) rets = results[0].analyzers.returns.get_analysis() print(f\u0026#34;Total Return: {rets[\u0026#39;rtot\u0026#39;]:.2%}\u0026#34;) print(f\u0026#34;Average Return: {rets[\u0026#39;ravg\u0026#39;]:.2%}\u0026#34;)4. TradeAnalyzer (거래 분석)\ncerebro.addanalyzer(bt.analyzers.TradeAnalyzer, _name=\u0026#39;trades\u0026#39;) trades = results[0].analyzers.trades.get_analysis() print(f\u0026#34;Total Trades: {trades[\u0026#39;total\u0026#39;][\u0026#39;total\u0026#39;]}\u0026#34;) print(f\u0026#34;Won: {trades[\u0026#39;won\u0026#39;][\u0026#39;total\u0026#39;]}\u0026#34;) print(f\u0026#34;Lost: {trades[\u0026#39;lost\u0026#39;][\u0026#39;total\u0026#39;]}\u0026#34;)커스텀 Analyzer# 필요하면 직접 Analyzer를 만들 수 있습니다:\nclass MyAnalyzer(bt.Analyzer): def __init__(self): self.rets = [] def notify_cashvalue(self, cash, value): \u0026#34;\u0026#34;\u0026#34;포트폴리오 가치 변경 시 호출\u0026#34;\u0026#34;\u0026#34; self.rets.append(value) def get_analysis(self): \u0026#34;\u0026#34;\u0026#34;분석 결과 반환\u0026#34;\u0026#34;\u0026#34; return { \u0026#39;final_value\u0026#39;: self.rets[-1], \u0026#39;max_value\u0026#39;: max(self.rets), \u0026#39;min_value\u0026#39;: min(self.rets) }4.8 브로커 설정# 초기 자본금# cerebro.broker.setcash(100000) # $100,000수수료# # 비율 기반 (0.1%) cerebro.broker.setcommission(commission=0.001) # 주당 고정 ($0.01/주) cerebro.broker.setcommission(commission=0.01, commtype=bt.CommInfoBase.COMM_FIXED)슬리피지 (Slippage)# # 고정 슬리피지 cerebro.broker.set_slippage_fixed(0.05, slip_open=True, slip_out=True) # 비율 슬리피지 cerebro.broker.set_slippage_perc(0.001) # 0.1%포지션 사이징# # 전략에서 크기 지정 self.buy(size=100) # 100주 # 브로커에서 기본 크기 설정 cerebro.addsizer(bt.sizers.FixedSize, stake=100) # 자금 비율 기반 cerebro.addsizer(bt.sizers.PercentSizer, percents=95) # 95% 투자4.9 다음 단계# 이 챕터에서 배운 것# ✅ Backtrader 아키텍처: Cerebro, Strategy, Data Feeds, Analyzers ✅ 전략 구현: __init__(), next(), notify_order() 메서드 ✅ 주문 실행: buy(), sell(), close() 메서드 ✅ Buy \u0026amp; Hold 전략: 가장 기본적인 벤치마크 전략 ✅ 성과 분석: Analyzers를 사용한 상세 분석 ✅ 브로커 설정: 자본금, 수수료, 슬리피지\n실습 과제# 다른 종목: Tesla (TSLA) 또는 Microsoft (MSFT)로 Buy \u0026amp; Hold를 실행해보세요.\n초기 자금 변경: $50,000, $100,000으로 변경하여 결과를 비교해보세요.\n수수료 영향: 수수료를 0%, 0.05%, 0.2%로 변경하여 영향을 분석해보세요.\n기간 변경: 1년, 3년, 10년 데이터로 백테스트해보세요.\n다음 챕터 미리보기# **Chapter 5: 이동평균 전략 (Part 2 시작!)**에서는:\n단순 이동평균 (SMA)과 지수 이동평균 (EMA) Golden Cross / Death Cross 크로스오버 전략 파라미터 최적화 실전 이동평균 전략 백테스팅 💡 핵심 메시지: 수익성 벤치마크의 설정\nBacktrader는 강력하고 유연한 백테스팅 프레임워크입니다. Cerebro, Strategy, Data Feeds, Analyzers의 4가지 핵심 요소를 이해하면, 어떤 복잡한 전략도 구현할 수 있습니다.\n하지만 기술보다 더 중요한 것: Buy \u0026amp; Hold (+101.90%, Sharpe 0.603, Max DD -32%)는 가장 간단한 전략이지만, 모든 커스텀 전략이 넘어야 할 최소 기준입니다.\n명심하세요:\n복잡한 전략 ≠ 더 높은 수익 90% 이상의 기술적 지표 전략은 강세장에서 Buy \u0026amp; Hold를 이기지 못함 전략의 가치는 \u0026ldquo;다른 시장 환경에서의 방어력\u0026quot;에 있습니다 Sharpe Ratio와 Max DD를 함께 봐야 진정한 성과를 알 수 있습니다 다음 챕터부터는 Part 2로 진입하여 실전 기술적 분석 전략들을 하나씩 구현해봅시다! (그리고 대부분이 Buy \u0026amp; Hold를 이기지 못한다는 냉혹한 현실도 함께 배웁니다)\n"},{"id":4,"href":"/intro-to-backtesting/docs/chapter05/","title":"Chapter 5: 이동평균 전략","section":"Docs","content":"Chapter 5: 이동평균 전략# 이동평균(Moving Average)은 가장 기본적이면서도 널리 사용되는 기술적 지표입니다. 이번 챕터에서는 이동평균의 원리를 이해하고, 골든 크로스(Golden Cross)와 데드 크로스(Death Cross) 전략을 구현해봅니다.\n5.1 이동평균의 종류# 5.1.1 단순 이동평균 (Simple Moving Average, SMA)# 단순 이동평균은 일정 기간 동안의 가격을 산술 평균한 값입니다:\n$$ \\text{SMA}_n(t) = \\frac{1}{n} \\sum_{i=0}^{n-1} P_{t-i} $$여기서:\n$n$은 기간 (예: 20일, 50일, 200일) $P_t$는 시점 $t$의 종가 $t$는 현재 시점 특징:\n모든 데이터에 동일한 가중치 부여 계산이 간단하고 해석이 쉬움 오래된 데이터가 갑자기 평균에서 빠지면서 \u0026ldquo;계단 효과\u0026rdquo; 발생 가능 5.1.2 지수 이동평균 (Exponential Moving Average, EMA)# 지수 이동평균은 최근 데이터에 더 큰 가중치를 부여합니다:\n$$ \\text{EMA}_n(t) = \\alpha \\cdot P_t + (1 - \\alpha) \\cdot \\text{EMA}_n(t-1) $$여기서 평활 계수(smoothing factor) $\\alpha$는:\n$$ \\alpha = \\frac{2}{n + 1} $$특징:\n최근 데이터에 더 민감하게 반응 계단 효과가 없어 부드러운 곡선 트렌드 변화를 빠르게 포착 5.2 골든 크로스와 데드 크로스# 5.2.1 골든 크로스 (Golden Cross)# 매수 신호: 단기 이동평균이 장기 이동평균을 상향 돌파\n일반적으로 사용되는 조합:\n50일 SMA가 200일 SMA를 상향 돌파 50일 EMA가 200일 EMA를 상향 돌파 의미: 단기 추세가 장기 추세보다 강해지고 있으며, 상승 추세가 시작될 가능성\n5.2.2 데드 크로스 (Death Cross)# 매도 신호: 단기 이동평균이 장기 이동평균을 하향 돌파\n의미: 단기 추세가 장기 추세보다 약해지고 있으며, 하락 추세가 시작될 가능성\n5.2.3 전략의 장단점# 장점:\n명확한 진입/청산 신호 주요 트렌드를 따라가는 추세 추종 전략 구현이 간단하고 이해하기 쉬움 장기적으로 큰 수익 기회 포착 가능 단점:\n횡보장(sideways market)에서 빈번한 거짓 신호(whipsaw) 신호 지연(lag): 트렌드가 이미 상당히 진행된 후 신호 발생 진입/청산 시점이 늦어 초기 이익 놓치거나 손실 확대 가능 5.3 실전 구현# 이번 챕터의 코드에서는 다음을 구현합니다:\nSMA 크로스오버 전략: 50일/200일 SMA를 사용한 골든/데드 크로스 EMA 크로스오버 전략: 50일/200일 EMA를 사용한 크로스오버 성과 비교: Buy \u0026amp; Hold vs. SMA 전략 vs. EMA 전략 5.3.1 Backtrader에서 이동평균 사용# import backtrader as bt class MovingAverageCrossStrategy(bt.Strategy): params = ( (\u0026#39;fast_period\u0026#39;, 50), (\u0026#39;slow_period\u0026#39;, 200), ) def __init__(self): # SMA 계산 self.fast_ma = bt.indicators.SMA( self.data.close, period=self.params.fast_period ) self.slow_ma = bt.indicators.SMA( self.data.close, period=self.params.slow_period ) # 크로스오버 신호 self.crossover = bt.indicators.CrossOver( self.fast_ma, self.slow_ma )5.3.2 거래 로직# def next(self): if self.crossover \u0026gt; 0: # 골든 크로스 if not self.position: self.buy() elif self.crossover \u0026lt; 0: # 데드 크로스 if self.position: self.close()5.4 실행 결과# 코드를 실행한 결과입니다 (Apple Inc., 2019-2024):\n================================================== Chapter 5: 이동평균 전략 ================================================== === 백테스트 설정 === - 티커: AAPL - 기간: 2019-01-01 ~ 2024-01-01 - 초기 자금: $10,000.00 - 수수료: 0.1% - 전략: SMA(50/200), EMA(50/200) 크로스오버 ================================================== 백테스트 실행 중... ================================================== [1/3] SMA 전략 실행 중... ================================================== === SMA(50/200) 크로스오버 성과 === ================================================== 기본 지표: - 초기 자금: $10,000.00 - 최종 자금: $11,106.95 - 총 수익률: +11.07% Sharpe Ratio: 0.266 최대 낙폭: - Max Drawdown: 14.41% - DD Duration: 152 days 수익률: - Total Return: +10.50% - Annualized Return: 2.13% 거래 통계: - 총 거래: 2 - 승: 0, 패: 1 - 승률: 0.0% - 평균 손실: $-794.75 [2/3] EMA 전략 실행 중... ================================================== === EMA(50/200) 크로스오버 성과 === ================================================== 기본 지표: - 초기 자금: $10,000.00 - 최종 자금: $10,521.69 - 총 수익률: +5.22% Sharpe Ratio: 0.142 최대 낙폭: - Max Drawdown: 19.98% - DD Duration: 214 days 수익률: - Total Return: +5.09% - Annualized Return: 1.02% 거래 통계: - 총 거래: 2 - 승: 0, 패: 1 - 승률: 0.0% - 평균 손실: $-1469.57 [3/3] Buy \u0026amp; Hold 벤치마크 계산 중... ================================================== === Buy \u0026amp; Hold 벤치마크 === ================================================== - 초기 자금: $10,000.00 - 최종 자금: $50,808.41 - 총 수익률: +408.08% ================================================== === 전략 비교 요약 === ================================================== Buy \u0026amp; Hold: +408.08% SMA(50/200): +11.07% EMA(50/200): +5.22% Buy \u0026amp; Hold 대비: - SMA 초과 수익: -397.01% - EMA 초과 수익: -402.87%\n차트 해석# 상단 패널 - SMA(50/200) 크로스오버:\n초록색 삼각형(▲)은 골든 크로스 매수 신호를 나타냅니다 빨간색 역삼각형(▼)은 데드 크로스 매도 신호를 나타냅니다 2019-2024 기간 동안 골든/데드 크로스가 매우 드물게 발생했습니다 50일 SMA(주황선)가 200일 SMA(초록선)를 따라 움직이며, 교차 시점에서 신호가 발생합니다 중간 패널 - EMA(50/200) 크로스오버:\nEMA는 SMA보다 최근 가격 변동에 더 민감하게 반응합니다 EMA 곡선이 SMA보다 더 부드럽고 가격에 근접하게 움직입니다 크로스오버 신호 발생 시점이 SMA와 약간 다릅니다 EMA의 빠른 반응성이 장점이자 단점으로 작용할 수 있습니다 하단 패널 - 성과 비교:\nBuy \u0026amp; Hold 전략(파란선)이 압도적으로 높은 수익률을 기록했습니다 Apple 주식이 2019-2024 기간 동안 강한 상승 추세를 보였습니다 이동평균 크로스오버 전략은 대부분 시장 밖에 있어 큰 상승을 놓쳤습니다 5.5 핵심 인사이트# 실행 결과에서 얻을 수 있는 중요한 교훈:\n1. 강한 트렌드 시장의 역설# Apple 주식은 2019-2024 기간 동안 **+408%**의 압도적인 상승을 기록했습니다. 하지만 이동평균 크로스오버 전략은:\nSMA(50/200): +11.07% EMA(50/200): +5.22% 왜 이런 결과가 나왔을까요?\n신호 지연: 50일/200일 같은 장기 이동평균은 매우 느리게 반응합니다 거래 희소성: 5년 동안 단 2회의 거래만 발생 (매수 1회, 매도 1회, 현재 보유 중) 시장 밖 대기: 대부분의 기간을 현금으로 보유하며 상승장을 놓쳤습니다 2. SMA vs EMA 비교# SMA가 EMA보다 우수: 11.07% vs 5.22% Sharpe Ratio: SMA(0.266) \u0026gt; EMA(0.142) Maximum Drawdown: SMA(14.41%) \u0026lt; EMA(19.98%) EMA의 민감성이 역효과:\n더 빠른 반응이 항상 좋은 것은 아닙니다 이 기간 동안 EMA의 빠른 매도 신호가 손실을 확대시켰습니다 3. 거래 빈도의 함정# 총 거래: 2회 (5년 동안) 승률: 0% (완료된 거래 1회가 손실) 평균 손실: SMA $-794.75, EMA $-1,469.57 문제점:\n샘플 사이즈가 너무 작아 통계적 의미가 없습니다 50/200일 같은 장기 MA는 거래 빈도가 극히 낮습니다 단 한 번의 잘못된 거래가 전체 성과를 좌우합니다 4. 이동평균 전략이 효과적인 경우# 이 전략이 잘 작동하는 시장:\n명확한 트렌드 전환: 상승 → 하락 또는 하락 → 상승 횡보 후 추세 발생: 장기간 횡보 후 강한 트렌드 시작 변동성이 낮은 시장: 잦은 가격 변동이 없는 안정적 추세 이 전략이 실패하는 시장:\n지속적 상승장: Apple처럼 계속 오르는 시장 (항상 투자되어 있어야 함) 횡보장: 이동평균 주변에서 진동하며 거짓 신호 빈발 (whipsaw) 급격한 변동: 신호 발생 시점이 이미 늦어 손실 확대 5. 실전 적용 시 고려사항# 이 결과가 주는 교훈:\n✅ 이동평균 크로스오버는 트렌드 반전을 포착하는 도구 ❌ 지속적 상승장에서는 Buy \u0026amp; Hold를 이기기 어렵습니다 ⚠️ 50/200일은 너무 느립니다 → 더 짧은 기간(예: 20/50일) 고려 ⚠️ 단일 지표에 의존하지 말고 필터 추가 필요 ⚠️ 다양한 시장 환경(상승, 하락, 횡보)에서 테스트해야 합니다 5.6 개선 방향# 이동평균 전략을 개선할 수 있는 방법:\n기간 최적화: 50/200일이 아닌 다른 기간 조합 테스트 필터 추가: 거래량, 변동성 등 추가 조건으로 거짓 신호 필터링 포지션 크기 조절: 신호 강도에 따라 매수 비중 조절 손절/익절: 고정 비율 손절매와 익절매 설정 다중 시간프레임: 상위 시간프레임 트렌드 확인 후 진입 다음 단계# 다음 챕터에서는 RSI(Relative Strength Index)를 활용한 과매수/과매도 전략을 배웁니다. 이동평균이 추세 추종 전략이라면, RSI는 역추세(mean reversion) 전략의 대표적인 예입니다.\n코드 실행:\ncd codes uv run chapter05/01_moving_average_strategy.py"},{"id":5,"href":"/intro-to-backtesting/docs/chapter06/","title":"Chapter 6: RSI 및 과매수/과매도 전략","section":"Docs","content":"Chapter 6: RSI 및 과매수/과매도 전략# RSI(Relative Strength Index, 상대강도지수)는 가격의 상승 압력과 하락 압력 간의 상대적인 강도를 측정하는 모멘텀 지표입니다. 이번 챕터에서는 RSI의 계산 방법을 이해하고, 과매수/과매도 신호를 활용한 역추세 전략을 구현합니다.\n6.1 RSI의 이해# 6.1.1 RSI 계산 방법# RSI는 다음 단계로 계산됩니다:\n1단계: 상승폭과 하락폭 계산\n$$ \\begin{align} \\text{Up}_t \u0026= \\max(P_t - P_{t-1}, 0) \\\\ \\text{Down}_t \u0026= \\max(P_{t-1} - P_t, 0) \\end{align} $$2단계: 평균 상승폭과 평균 하락폭 계산 (일반적으로 14일 기준)\n첫 번째 평균: $$ \\begin{align} \\text{AvgUp}_{14} \u0026= \\frac{1}{14} \\sum_{i=1}^{14} \\text{Up}_i \\\\ \\text{AvgDown}_{14} \u0026= \\frac{1}{14} \\sum_{i=1}^{14} \\text{Down}_i \\end{align} $$이후 평균 (Wilder의 평활화 방법): $$ \\begin{align} \\text{AvgUp}_t \u0026= \\frac{13 \\cdot \\text{AvgUp}_{t-1} + \\text{Up}_t}{14} \\\\ \\text{AvgDown}_t \u0026= \\frac{13 \\cdot \\text{AvgDown}_{t-1} + \\text{Down}_t}{14} \\end{align} $$3단계: RS(Relative Strength) 계산\n$$ \\text{RS}_t = \\frac{\\text{AvgUp}_t}{\\text{AvgDown}_t} $$4단계: RSI 계산\n$$ \\text{RSI}_t = 100 - \\frac{100}{1 + \\text{RS}_t} $$또는 다르게 표현하면:\n$$ \\text{RSI}_t = 100 \\times \\frac{\\text{AvgUp}_t}{\\text{AvgUp}_t + \\text{AvgDown}_t} $$6.1.2 RSI의 특성# 값의 범위: 0 ~ 100\nRSI = 100: 모든 가격 변동이 상승 RSI = 0: 모든 가격 변동이 하락 RSI = 50: 상승과 하락이 균형 일반적인 해석:\nRSI \u0026gt; 70: 과매수(Overbought) - 가격이 과도하게 상승, 조정 가능성 RSI \u0026lt; 30: 과매도(Oversold) - 가격이 과도하게 하락, 반등 가능성 RSI ≈ 50: 중립 6.2 RSI 과매수/과매도 전략# 6.2.1 기본 전략# 매수 신호: RSI가 30 이하로 떨어졌다가 30을 상향 돌파\n과매도 영역에서 반등 시작 매도 신호: RSI가 70 이상으로 올라갔다가 70을 하향 돌파\n과매수 영역에서 조정 시작 6.2.2 전략의 특징# 역추세(Mean Reversion) 전략:\n이동평균 전략과 반대되는 접근 가격이 극단에 도달하면 평균으로 회귀한다는 가정 횡보장이나 범위 제한 시장에서 유리 장점:\n명확한 매매 신호 과도한 가격 움직임을 포착 단기 매매에 적합 횡보장에서 효과적 단점:\n강한 추세 시장에서는 계속 손실 발생 가능 \u0026ldquo;가격은 계속 더 오를 수 있고, 더 떨어질 수 있다\u0026rdquo; 추세 전환 시점 포착 어려움 6.3 RSI 신호 최적화# 6.3.1 임계값 조정# 기본 30/70 대신 다른 임계값 사용:\n보수적 접근: 20/80 - 더 극단적인 상황에서만 매매 공격적 접근: 40/60 - 더 빈번한 매매 신호 6.3.2 RSI 다이버전스 (Divergence)# 강세 다이버전스 (Bullish Divergence):\n가격은 더 낮은 저점을 형성 RSI는 더 높은 저점을 형성 하락 추세 약화 신호 → 매수 고려 약세 다이버전스 (Bearish Divergence):\n가격은 더 높은 고점을 형성 RSI는 더 낮은 고점을 형성 상승 추세 약화 신호 → 매도 고려 6.3.3 다른 지표와 결합# RSI 단독 사용의 한계를 극복하기 위해:\n추세 필터: 이동평균으로 추세 확인 후 RSI 신호 필터링 거래량 확인: 거래량 증가와 함께 RSI 신호 발생 시 신뢰도 상승 지지/저항: 주요 가격 수준에서 RSI 신호 발생 시 더 강력 6.4 실전 구현# 이번 챕터의 코드에서는 다음을 구현합니다:\n기본 RSI 전략: 30/70 임계값 사용 보수적 RSI 전략: 20/80 임계값 사용 추세 필터 추가: 200일 SMA와 결합한 RSI 전략 성과 비교: Buy \u0026amp; Hold vs. 각 RSI 전략 6.4.1 Backtrader에서 RSI 사용# import backtrader as bt class RSIStrategy(bt.Strategy): params = ( (\u0026#39;rsi_period\u0026#39;, 14), (\u0026#39;rsi_lower\u0026#39;, 30), (\u0026#39;rsi_upper\u0026#39;, 70), ) def __init__(self): # RSI 지표 추가 self.rsi = bt.indicators.RSI( self.data.close, period=self.params.rsi_period )6.4.2 거래 로직# def next(self): if not self.position: # 과매도 → 매수 if self.rsi \u0026lt; self.params.rsi_lower: self.buy() else: # 과매수 → 매도 if self.rsi \u0026gt; self.params.rsi_upper: self.close()6.5 실행 결과# 코드를 실행한 결과입니다 (Apple Inc., 2019-2024):\n================================================== Chapter 6: RSI 및 과매수/과매도 전략 ================================================== === 백테스트 설정 === - 티커: AAPL - 기간: 2019-01-01 ~ 2024-01-01 - 초기 자금: $10,000.00 - 수수료: 0.1% - 전략: RSI(14) 과매수/과매도 ================================================== [1/4] 기본 RSI(30/70) 전략 실행 중... ================================================== === RSI(30/70) 성과 === ================================================== 기본 지표: - 초기 자금: $10,000.00 - 최종 자금: $21,332.43 - 총 수익률: +113.32% Sharpe Ratio: 1.230 최대 낙폭: - Max Drawdown: 23.52% - DD Duration: 316 days 수익률: - Total Return: +75.76% - Annualized Return: 16.39% 거래 통계: - 총 거래: 5 - 승: 5, 패: 0 - 승률: 100.0% - 평균 수익: $2266.49 ================================================== [2/4] 보수적 RSI(20/80) 전략 실행 중... ================================================== === RSI(20/80) 성과 === ================================================== 기본 지표: - 초기 자금: $10,000.00 - 최종 자금: $10,000.00 - 총 수익률: +0.00% 최대 낙폭: - Max Drawdown: 0.00% 수익률: - Total Return: +0.00% - Annualized Return: 0.00% 거래 통계: - 총 거래: 0 ================================================== [3/4] 추세 필터 RSI(30/70) 전략 실행 중... ================================================== === RSI(30/70) + SMA(200) 필터 성과 === ================================================== 기본 지표: - 초기 자금: $10,000.00 - 최종 자금: $14,714.26 - 총 수익률: +47.14% Sharpe Ratio: 0.892 최대 낙폭: - Max Drawdown: 23.52% - DD Duration: 539 days 수익률: - Total Return: +38.62% - Annualized Return: 8.04% 거래 통계: - 총 거래: 3 - 승: 3, 패: 0 - 승률: 100.0% - 평균 수익: $1571.42 ================================================== === 전략 비교 요약 === ================================================== Buy \u0026amp; Hold: +408.08% RSI(30/70): +113.32% RSI(20/80): +0.00% RSI(30/70) + 추세 필터: +47.14% Buy \u0026amp; Hold 대비: - RSI(30/70) 초과 수익: -294.76% - RSI(20/80) 초과 수익: -408.08% - RSI(30/70)+필터 초과 수익: -360.94%\n차트 해석# 상단 패널 - 가격 및 RSI 지표:\n파란선은 Apple 주가 추이를 보여줍니다 하단의 주황선은 RSI(14) 값을 나타냅니다 빨간 점선(RSI=70)과 초록 점선(RSI=30)은 과매수/과매도 임계값입니다 RSI가 30 아래로 내려가면 과매도 상태, 70 위로 올라가면 과매수 상태입니다 중간 패널 - RSI(30/70) 매매 신호:\n초록색 삼각형(▲)은 RSI가 30 이하에서 반등하는 매수 신호입니다 빨간색 역삼각형(▼)은 RSI가 70 이상에서 하락하는 매도 신호입니다 2019-2024 기간 동안 총 5회의 매매가 발생했습니다 2020년 3월 코로나 폭락 시 강력한 매수 신호가 발생했습니다 하단 패널 - 전략 성과 비교:\n파란선(Buy \u0026amp; Hold)이 가장 높은 수익률을 기록했습니다 주황선(RSI 30/70)은 두 번째로 우수한 성과를 보였습니다 초록선(RSI with 추세 필터)은 거래를 줄여 수익률이 낮아졌습니다 RSI(20/80)는 너무 보수적이어서 거래가 전혀 없었습니다 (표시 안 됨) 6.6 핵심 인사이트# 실행 결과에서 얻을 수 있는 중요한 교훈:\n1. RSI의 놀라운 성과# RSI(30/70) 전략이 이동평균 크로스오버(Chapter 5)를 압도적으로 이겼습니다:\nRSI(30/70): +113.32% vs. SMA(50/200): +11.07% Sharpe Ratio: 1.230 (매우 우수한 위험 조정 수익률) 승률: 100% (5거래 모두 수익) 평균 수익: $2,266 per trade 왜 이렇게 좋은 결과가 나왔을까?\n2020년 3월 코로나 폭락 시 과매도 신호로 바닥 근처에서 매수 극단적인 가격 변동 시점을 정확히 포착 적당한 거래 빈도(5거래)로 수수료 부담 최소화 2. 임계값의 중요성: 30/70 vs 20/80# RSI(30/70): +113.32%, 5거래, 승률 100% RSI(20/80): 0%, 0거래 20/80은 너무 보수적:\n5년 동안 단 한 번도 RSI가 20 이하 또는 80 이상에 도달하지 않음 극단적인 시장 상황만 기다리다 모든 기회를 놓침 실전에서는 쓸모없는 설정 30/70이 적절한 이유:\n적당한 빈도로 거래 기회 포착 너무 잦지 않아 수수료 부담 적음 진짜 과매수/과매도 상황 포착 3. 추세 필터의 양면성# 필터 없음: +113.32%, 5거래 SMA(200) 필터 추가: +47.14%, 3거래 추세 필터가 역효과:\n거래를 2회 줄였는데, 그 2회가 수익성 있는 거래였음 필터가 좋은 신호까지 걸러버림 이 기간 동안 Apple이 지속적 상승 추세여서 \u0026ldquo;상승 추세 중에만 매수\u0026rdquo; 필터가 의미 없음 추세 필터가 유용한 경우:\n횡보장이 많은 시장 명확한 하락 추세에서 매수 방지 거짓 신호(whipsaw) 빈발 시장 4. RSI vs 이동평균: 역추세 vs 추세 추종# 지표 Chapter 5: MA Chapter 6: RSI 수익률 +11.07% (SMA) +113.32% Sharpe Ratio 0.266 1.230 거래 횟수 2회 5회 승률 0% 100% 전략 타입 추세 추종 역추세 이 기간 동안 RSI가 압승한 이유:\nApple 주가가 급등락을 반복하며 상승 (완벽한 RSI 환경) 폭락 후 반등 패턴이 명확했음 이동평균은 신호가 너무 느려 기회를 놓침 5. 역추세 전략의 핵심# RSI가 효과적인 시장:\n✅ 변동성이 크지만 장기 추세가 있는 시장 (예: 2019-2024 AAPL) ✅ 급락 후 반등하는 패턴 ✅ 과매도/과매수가 명확히 나타나는 시장 RSI가 위험한 시장:\n❌ 지속적 하락 추세 (계속 더 떨어질 수 있음) ❌ 극단적 폭락 시장 (30 이하로 계속 머무름) ❌ 변동성이 매우 낮은 횡보장 6. 실전 적용 교훈# 이 결과가 주는 교훈:\n✅ RSI는 강력한 역추세 지표입니다 ✅ 30/70 임계값이 실용적입니다 (20/80는 너무 보수적) ⚠️ 추세 필터는 양날의 검 (좋은 신호도 걸러낼 수 있음) ⚠️ 100% 승률은 샘플 사이즈가 작아서 나온 결과 (5거래만으로 일반화 불가) ⚠️ 다양한 시장 환경에서 테스트 필요 (Bear market에서는 어떨까?) ⚠️ 과거 성과가 미래를 보장하지 않음 6.7 추세 추종 vs. 역추세 전략# 특성 추세 추종 (이동평균) 역추세 (RSI) 기본 가정 추세는 지속된다 가격은 평균으로 회귀한다 유리한 시장 강한 트렌드 시장 횡보장, 범위 제한 시장 거래 빈도 상대적으로 낮음 상대적으로 높음 신호 지연 있음 (늦게 진입) 없음 (빠른 진입) 위험 횡보장에서 손실 추세 시장에서 손실 승률 낮지만 큰 이익 높지만 작은 이익 6.8 개선 방향# RSI 전략을 개선할 수 있는 방법:\n기간 최적화: 14일이 아닌 다른 기간 테스트 임계값 최적화: 30/70이 아닌 최적 임계값 탐색 다이버전스 감지: RSI와 가격의 다이버전스 패턴 추가 손절/익절: 고정 비율 또는 ATR 기반 손절매 설정 포지션 크기 조절: RSI 값에 따른 동적 포지션 크기 조정 다중 시간프레임: 여러 시간프레임의 RSI 동시 확인 다음 단계# 다음 챕터에서는 Bollinger Bands를 활용한 변동성 기반 전략을 배웁니다. Bollinger Bands는 RSI와 유사한 역추세 전략이지만, 가격 변동성을 동적으로 고려한다는 점에서 차별화됩니다.\n코드 실행:\ncd codes uv run chapter06/01_rsi_strategy.py"},{"id":6,"href":"/intro-to-backtesting/docs/chapter07/","title":"Chapter 7: Bollinger Bands 전략","section":"Docs","content":"Chapter 7: Bollinger Bands 전략# Bollinger Bands는 John Bollinger가 개발한 변동성 기반 기술적 지표입니다. 가격의 표준편차를 이용해 동적으로 변하는 밴드를 형성하며, 과매수/과매도 판단과 변동성 변화를 감지하는 데 사용됩니다.\n7.1 Bollinger Bands의 구조# 7.1.1 Bollinger Bands 계산# Bollinger Bands는 세 개의 라인으로 구성됩니다:\n1. 중간 밴드 (Middle Band): 단순 이동평균\n$$ \\text{MB}_t = \\text{SMA}_n(P_t) $$2. 상단 밴드 (Upper Band): 중간 밴드 + (표준편차 × k)\n$$ \\text{UB}_t = \\text{MB}_t + k \\cdot \\sigma_n(P_t) $$3. 하단 밴드 (Lower Band): 중간 밴드 - (표준편차 × k)\n$$ \\text{LB}_t = \\text{MB}_t - k \\cdot \\sigma_n(P_t) $$여기서:\n$n$은 기간 (일반적으로 20일) $k$는 표준편차 배수 (일반적으로 2) $\\sigma_n(P_t)$는 $n$ 기간 동안의 가격 표준편차 7.1.2 표준편차 계산# $$ \\sigma_n(P_t) = \\sqrt{\\frac{1}{n} \\sum_{i=0}^{n-1} (P_{t-i} - \\text{MB}_t)^2} $$7.1.3 Bollinger Bands의 특성# 변동성 측정:\n밴드 폭이 넓어짐: 변동성 증가 밴드 폭이 좁아짐: 변동성 감소 가격 포함률:\n약 95%의 가격이 ±2σ 밴드 내에 위치 (정규분포 가정) 밴드 외부로 가격이 벗어나는 것은 상대적으로 드문 사건 동적 조정:\n시장 변동성에 따라 밴드가 자동으로 확장/축소 RSI처럼 고정된 임계값(30/70)이 아님 7.2 Bollinger Bands 트레이딩 전략# 7.2.1 밴드 반등 전략 (Mean Reversion)# 기본 개념: 가격이 밴드 끝에 도달하면 평균으로 회귀한다\n매수 신호:\n가격이 하단 밴드에 닿거나 아래로 벗어남 과매도 상태로 판단 → 반등 기대 매도 신호:\n가격이 상단 밴드에 닿거나 위로 벗어남 과매수 상태로 판단 → 조정 기대 특징:\n횡보장/범위 제한 시장에서 효과적 강한 추세에서는 밴드를 따라 계속 움직일 수 있음 (밴드 워킹) 7.2.2 밴드 돌파 전략 (Breakout)# 기본 개념: 변동성 수축 후 확장 시 강한 추세 발생\n매수 신호:\n밴드 폭이 좁아진 후 (스퀴즈) 가격이 상단 밴드를 상향 돌파 상승 추세 시작 신호 매도 신호:\n밴드 폭이 좁아진 후 가격이 하단 밴드를 하향 돌파 하락 추세 시작 신호 특징:\n추세 시장에서 효과적 밴드 워킹(Band Walking) 포착 가능 7.2.3 밴드 폭 분석 (Bandwidth)# Bandwidth 계산:\n$$ \\text{Bandwidth}_t = \\frac{\\text{UB}_t - \\text{LB}_t}{\\text{MB}_t} \\times 100 $$해석:\n낮은 Bandwidth: 변동성 수축 → 큰 움직임 임박 (스퀴즈) 높은 Bandwidth: 변동성 확장 → 추세 진행 중 스퀴즈 (Squeeze):\nBandwidth가 6개월 최저점에 도달 큰 가격 움직임이 곧 발생할 신호 방향은 알 수 없음 (돌파 확인 필요) 7.2.4 %B 지표# 가격의 밴드 내 상대적 위치를 나타냄:\n$$ \\%B_t = \\frac{P_t - \\text{LB}_t}{\\text{UB}_t - \\text{LB}_t} $$해석:\n%B = 1: 가격이 상단 밴드에 위치 %B = 0: 가격이 하단 밴드에 위치 %B = 0.5: 가격이 중간 밴드에 위치 %B \u0026gt; 1: 가격이 상단 밴드 위에 위치 (매우 강함) %B \u0026lt; 0: 가격이 하단 밴드 아래에 위치 (매우 약함) 7.3 Bollinger Bands vs. RSI# 특성 Bollinger Bands RSI 기반 변동성 (표준편차) 모멘텀 (상승/하락 강도) 임계값 동적 (시장 변동성에 따라 변화) 고정 (30/70) 시장 적응성 높음 낮음 추세 포착 가능 (밴드 돌파 전략) 어려움 변동성 정보 제공 (밴드 폭) 제공 안 함 사용 난이도 상대적으로 복잡 단순 7.4 실전 구현# 이번 챕터의 코드에서는 다음을 구현합니다:\n밴드 반등 전략: 하단 밴드 터치 시 매수, 상단 밴드 터치 시 매도 밴드 돌파 전략: 밴드 스퀴즈 후 돌파 시 추세 추종 %B 기반 전략: %B 값을 이용한 매매 성과 비교: Buy \u0026amp; Hold vs. 각 BB 전략 7.4.1 Backtrader에서 Bollinger Bands 사용# import backtrader as bt class BollingerBandsStrategy(bt.Strategy): params = ( (\u0026#39;period\u0026#39;, 20), (\u0026#39;devfactor\u0026#39;, 2.0), ) def __init__(self): # Bollinger Bands 지표 추가 self.bband = bt.indicators.BollingerBands( self.data.close, period=self.params.period, devfactor=self.params.devfactor ) # 개별 밴드 접근 self.top_band = self.bband.top self.mid_band = self.bband.mid self.bot_band = self.bband.bot7.4.2 밴드 반등 전략 로직# def next(self): if not self.position: # 하단 밴드 터치: 매수 if self.data.close \u0026lt; self.bot_band: self.buy() else: # 상단 밴드 터치: 매도 if self.data.close \u0026gt; self.top_band: self.close()7.4.3 밴드 돌파 전략 로직# def next(self): # Bandwidth 계산 bandwidth = (self.top_band - self.bot_band) / self.mid_band # 스퀴즈 감지 (낮은 변동성) if bandwidth \u0026lt; threshold: self.squeeze_detected = True if self.squeeze_detected: # 상단 밴드 돌파: 매수 if self.data.close \u0026gt; self.top_band: self.buy() self.squeeze_detected = False7.5 실행 결과# 코드를 실행한 결과입니다 (Apple Inc., 2019-2024):\n================================================== Chapter 7: Bollinger Bands 전략 ================================================== === 백테스트 설정 === - 티커: AAPL - 기간: 2019-01-01 ~ 2024-01-01 - 초기 자금: $10,000.00 - 수수료: 0.1% - Bollinger Bands: 기간=20, 표준편차=2 ================================================== [1/4] 밴드 반등(Mean Reversion) 전략 실행 중... ================================================== === 밴드 반등 전략 성과 === ================================================== 기본 지표: - 초기 자금: $10,000.00 - 최종 자금: $16,308.31 - 총 수익률: +63.08% Sharpe Ratio: 0.900 최대 낙폭: - Max Drawdown: 24.85% - DD Duration: 379 days 거래 통계: - 총 거래: 13 - 승: 10, 패: 3 - 승률: 76.9% - 평균 수익: $799.07 - 평균 손실: $-560.81 ================================================== [2/4] 밴드 돌파(Breakout) 전략 실행 중... ================================================== === 밴드 돌파 전략 성과 === ================================================== 기본 지표: - 초기 자금: $10,000.00 - 최종 자금: $20,276.96 - 총 수익률: +102.77% Sharpe Ratio: 1.232 최대 낙폭: - Max Drawdown: 10.45% - DD Duration: 353 days 거래 통계: - 총 거래: 10 - 승: 6, 패: 4 - 승률: 60.0% - 평균 수익: $2122.26 - 평균 손실: $-614.14 ================================================== [3/4] %B 기반 전략 실행 중... ================================================== === %B 기반 전략 성과 === ================================================== 기본 지표: - 초기 자금: $10,000.00 - 최종 자금: $10,463.13 - 총 수익률: +4.63% 거래 통계: - 총 거래: 17 - 승: 10, 패: 7 - 승률: 58.8% ================================================== === 전략 비교 요약 === ================================================== Buy \u0026amp; Hold: +408.08% 밴드 반등 전략: +63.08% 밴드 돌파 전략: +102.77% %B 기반 전략: +4.63%\n차트 해석# 상단 패널 - 가격과 Bollinger Bands:\n파란선은 Apple 주가입니다 주황선(중간 밴드)은 20일 SMA입니다 초록선(상단 밴드)과 빨간선(하단 밴드)은 ±2 표준편차입니다 밴드 폭이 좁아지면 변동성 수축(스퀴즈), 넓어지면 변동성 확장을 의미합니다 2020년 3월 코로나 폭락 시 밴드가 크게 확장되었습니다 중간 패널 - Bandwidth (변동성 지표):\n주황선은 밴드 폭을 백분율로 나타냅니다 낮은 값 = 변동성 수축 (큰 움직임 임박) 높은 값 = 변동성 확장 (추세 진행 중) 2019년 말과 2023년 중반에 스퀴즈가 발생했습니다 하단 패널 - 전략 성과 비교:\n파란선(Buy \u0026amp; Hold)이 여전히 가장 높습니다 주황선(밴드 돌파)이 두 번째로 우수한 성과를 보였습니다 초록선(밴드 반등)은 세 번째입니다 빨간선(%B 전략)은 거의 제자리걸음입니다 7.6 핵심 인사이트# 실행 결과에서 얻을 수 있는 중요한 교훈:\n1. 밴드 돌파 전략의 우수성# 밴드 돌파 전략이 최고 성과:\n수익률: +102.77% (지금까지 본 전략 중 최고!) Sharpe Ratio: 1.232 (우수한 위험 조정 수익률) Max Drawdown: 10.45% (매우 낮음!) 평균 수익: $2,122 per trade 왜 이렇게 좋은 결과가 나왔을까?\n변동성 수축 후 확장을 정확히 포착 강한 추세의 초기 단계에 진입 낮은 Drawdown으로 심리적 부담 최소화 10거래로 적절한 거래 빈도 유지 2. 전략별 성과 비교# 전략 수익률 Sharpe Max DD 거래 승률 밴드 돌파 +102.77% 1.232 10.45% 10 60% 밴드 반등 +63.08% 0.900 24.85% 13 76.9% %B 전략 +4.63% 0.143 30.16% 17 58.8% 밴드 돌파 \u0026gt; 밴드 반등 \u0026gt; %B:\n돌파 전략이 반등 전략보다 40% 더 높은 수익 돌파 전략의 Drawdown이 반등의 절반 수준 %B 전략은 과도한 거래로 수수료 부담 3. 지금까지 배운 전략 종합 비교# 챕터 전략 수익률 Sharpe 거래 Ch5 SMA(50/200) +11.07% 0.266 2 Ch6 RSI(30/70) +113.32% 1.230 5 Ch7 BB 돌파 +102.77% 1.232 10 Ch7 BB 반등 +63.08% 0.900 13 RSI와 BB 돌파가 비슷한 성과:\nRSI: +113.32%, Sharpe 1.230 BB 돌파: +102.77%, Sharpe 1.232 두 전략 모두 역추세 요소를 가짐 BB 돌파는 추세도 함께 포착 4. 밴드 반등 vs 밴드 돌파# 밴드 반등 (Mean Reversion):\n승률 높음(76.9%) but 작은 수익 하단 밴드 터치 → 평균 회귀 기대 횡보장에 유리 강한 추세에서 손실 (밴드 워킹) 밴드 돌파 (Breakout):\n승률 낮음(60%) but 큰 수익 스퀴즈 후 돌파 → 추세 시작 포착 추세 시장에 유리 낮은 Max Drawdown (10.45%) Apple 2019-2024는 추세 시장:\n강한 상승 추세가 여러 번 발생 돌파 전략이 추세를 잘 포착 반등 전략은 추세에서 조기 매도 5. %B 전략의 실패# 왜 %B 전략이 실패했나?:\n과도한 거래: 17거래 (가장 많음) 빈번한 진출입: 수수료 부담 증가 명확하지 않은 신호: %B 임계값이 모호 Max Drawdown 30.16%: 가장 높음 교훈: 복잡한 지표가 항상 좋은 것은 아님\n6. Bandwidth의 중요성# 변동성 수축-확장 사이클:\n낮은 Bandwidth (스퀴즈) → 큰 움직임 임박 돌파 전략은 이 패턴을 활용 2019년 말 스퀴즈 → 2020년 초 급등 2020년 3월 폭락 → 높은 Bandwidth 7. 실전 적용 교훈# 이 결과가 주는 교훈:\n✅ BB 돌파 전략이 우수한 리스크-수익 프로필 ✅ 변동성 기반 접근이 효과적 ✅ 낮은 Max Drawdown으로 심리적 유리 ⚠️ 추세 시장에서는 돌파, 횡보장에서는 반등 ⚠️ 시장 환경 판별이 중요 ⚠️ 너무 많은 거래는 수수료로 수익 감소 7.7 Bollinger Bands 활용 팁# 7.7.1 밴드 워킹 (Band Walking)# 현상: 강한 추세에서 가격이 상단(또는 하단) 밴드를 따라 계속 움직임\n대응:\n반등 전략 중단 추세 추종 전략으로 전환 중간 밴드를 손절 기준으로 사용 7.7.2 더블 탑/바텀# 가격이 상단 밴드를 터치했다가 다시 터치 (더블 탑) 두 번째 터치가 첫 번째보다 높지만 밴드를 넘지 못함 반전 신호 가능 7.7.3 다른 지표와 결합# 추세 확인:\nBollinger Bands + 이동평균: 추세 방향 확인 중간 밴드가 상승 중이면 상승 추세 모멘텀 확인:\nBollinger Bands + RSI: 신호 신뢰도 증가 하단 밴드 터치 + RSI 과매도 → 강한 매수 신호 거래량 확인:\n밴드 돌파 시 거래량 증가하면 신뢰도 상승 7.8 개선 방향# Bollinger Bands 전략을 개선할 수 있는 방법:\n동적 매개변수: 시장 변동성에 따라 기간 및 표준편차 배수 조정 스퀴즈 임계값: 역사적 Bandwidth 분포 분석으로 최적 임계값 결정 포지션 크기: Bandwidth에 따라 포지션 크기 조절 (낮은 변동성 → 큰 포지션) 손절/익절: ATR 기반 동적 손절매 설정 다중 시간프레임: 상위 시간프레임 밴드와 하위 시간프레임 신호 결합 다음 단계# 다음 챕터에서는 여러 기술적 지표를 결합한 다중 지표 전략을 배웁니다. 이동평균, RSI, Bollinger Bands를 함께 사용하여 신호 신뢰도를 높이는 방법을 다룹니다.\n코드 실행:\ncd codes uv run chapter07/01_bollinger_bands_strategy.py"},{"id":7,"href":"/intro-to-backtesting/docs/chapter08/","title":"Chapter 8: 다중 지표 결합 전략","section":"Docs","content":"Chapter 8: 다중 지표 결합 전략# 단일 지표만 사용하는 전략은 거짓 신호(false signal)가 많고 신뢰도가 낮습니다. 이번 챕터에서는 여러 기술적 지표를 결합하여 신호의 신뢰도를 높이고 위험을 줄이는 방법을 배웁니다.\n8.1 다중 지표 결합의 필요성# 8.1.1 단일 지표의 한계# 이동평균 (추세 추종):\n장점: 큰 트렌드 포착 단점: 신호 지연, 횡보장에서 손실 RSI (역추세):\n장점: 빠른 신호, 과매수/과매도 포착 단점: 강한 추세에서 계속 손실 Bollinger Bands (변동성):\n장점: 동적 임계값, 변동성 정보 제공 단점: 밴드 워킹 시 손실 8.1.2 다중 지표 결합의 이점# 1. 신호 확인 (Confirmation)\n여러 지표가 동시에 신호를 보내면 신뢰도 증가 거짓 신호 필터링 2. 상호 보완\n추세 지표 + 모멘텀 지표 + 변동성 지표 각 지표의 약점을 다른 지표로 보완 3. 시장 환경 적응\n추세 시장: 추세 추종 지표 우선 횡보 시장: 역추세 지표 우선 8.2 지표 결합 전략 유형# 8.2.1 필터 방식 (Filter Approach)# 개념: 주 지표의 신호를 보조 지표로 필터링\n예시: RSI + 이동평균 추세 필터\n매수 조건: 1. RSI \u0026lt; 30 (과매도) 2. 가격 \u0026gt; 200일 SMA (상승 추세)장점: 구현 간단, 이해하기 쉬움 단점: 거래 기회 감소\n8.2.2 가중 방식 (Weighted Approach)# 개념: 각 지표에 가중치를 부여하여 종합 점수 계산\n예시: 종합 신호 점수\n점수 = (RSI 신호 × 0.3) + (MACD 신호 × 0.3) + (BB 신호 × 0.4) 매수: 점수 \u0026gt; 임계값장점: 유연성, 다양한 신호 강도 반영 단점: 가중치 최적화 필요\n8.2.3 합의 방식 (Consensus Approach)# 개념: 여러 지표의 합의(투표)로 결정\n예시: 3개 지표 중 2개 이상 동의\n매수 조건: - RSI \u0026lt; 30: +1표 - BB 하단 터치: +1표 - SMA 골든 크로스: +1표 2표 이상: 매수장점: 신뢰도 높은 신호만 선택 단점: 기회 추가 감소\n8.3 실전 결합 전략# 8.3.1 전략 1: 추세 확인 + 과매도 진입# 사용 지표:\n200일 SMA: 추세 확인 RSI(14): 진입 타이밍 Bollinger Bands: 과매도 확인 매수 조건 (모두 충족):\n가격 \u0026gt; 200일 SMA (상승 추세) RSI \u0026lt; 30 (과매도) 가격이 Bollinger 하단 밴드 근처 매도 조건:\nRSI \u0026gt; 70 (과매수) 또는 가격이 Bollinger 상단 밴드 돌파 전략 특징:\n상승 추세 중 일시적 조정을 매수 기회로 활용 추세를 거스르지 않음 낮은 위험, 높은 승률 기대 8.3.2 전략 2: 골든 크로스 + 모멘텀 확인# 사용 지표:\n50일/200일 SMA: 주 신호 RSI(14): 모멘텀 확인 Bollinger Bandwidth: 변동성 확인 매수 조건 (모두 충족):\n50일 SMA가 200일 SMA 상향 돌파 (골든 크로스) RSI \u0026gt; 50 (상승 모멘텀 확인) Bandwidth 증가 중 (변동성 확장) 매도 조건:\n50일 SMA가 200일 SMA 하향 돌파 (데드 크로스) 전략 특징:\n강한 신호만 선택 추세 시작 시점 포착 거짓 골든 크로스 필터링 8.3.3 전략 3: 종합 신호 점수# 사용 지표:\nSMA(50/200): 추세 RSI(14): 모멘텀 Bollinger Bands: 변동성 신호 점수 계산:\nscore = 0 # 추세 점수 (±2) if price \u0026gt; sma_200: score += 2 elif price \u0026lt; sma_200: score -= 2 # 모멘텀 점수 (±2) if rsi \u0026lt; 30: score += 2 elif rsi \u0026gt; 70: score -= 2 # 변동성 점수 (±1) if price \u0026lt; bb_lower: score += 1 elif price \u0026gt; bb_upper: score -= 1매수 조건: score \u0026gt;= 3 매도 조건: score \u0026lt;= -3\n전략 특징:\n유연한 신호 강도 반영 점진적 포지션 조절 가능 다양한 시장 환경 대응 8.4 실전 구현# 이번 챕터의 코드에서는 다음을 구현합니다:\n추세 확인 + 과매도 진입 전략 골든 크로스 + 모멘텀 확인 전략 종합 신호 점수 전략 성과 비교: Buy \u0026amp; Hold vs. 단일 지표 vs. 다중 지표 8.4.1 Backtrader 구현 예시# import backtrader as bt class MultiIndicatorStrategy(bt.Strategy): def __init__(self): # 추세 지표 self.sma_200 = bt.indicators.SMA(self.data.close, period=200) # 모멘텀 지표 self.rsi = bt.indicators.RSI(self.data.close, period=14) # 변동성 지표 self.bband = bt.indicators.BollingerBands( self.data.close, period=20, devfactor=2.0 ) def next(self): # 추세 확인 uptrend = self.data.close \u0026gt; self.sma_200 # 과매도 확인 oversold = self.rsi \u0026lt; 30 # Bollinger 하단 근처 near_lower = self.data.close \u0026lt; self.bband.lines.mid # 모든 조건 충족 시 매수 if uptrend and oversold and near_lower: if not self.position: self.buy()8.5 기대 결과# 코드를 실행하면 다음을 확인할 수 있습니다:\n지표 조합 시각화: 여러 지표가 동시에 표시된 차트 신호 비교: 단일 지표 vs. 다중 지표 신호 차이 성과 비교: Buy \u0026amp; Hold RSI 단독 전략 SMA 단독 전략 다중 지표 전략 1, 2, 3 거래 통계: 거래 횟수, 승률, 평균 손익 위험 지표: Sharpe Ratio, Maximum Drawdown 8.6 분석 포인트# 코드를 실행한 후 다음을 분석해보세요:\n신호 품질: 다중 지표가 실제로 거짓 신호를 줄이는가? 거래 빈도: 필터링으로 인한 거래 기회 감소가 수익성을 해치는가? 위험 조정 수익: Sharpe Ratio가 개선되는가? 시장 환경별 성과: 추세/횡보 구간에서 각 전략의 성과 차이 최적 조합: 어떤 지표 조합이 가장 효과적인가? 8.7 다중 지표 전략의 함정# 8.7.1 과최적화 (Overfitting)# 문제: 과거 데이터에 과도하게 맞춤\n너무 많은 조건 → 과거에는 완벽, 미래에는 실패 예: \u0026ldquo;RSI \u0026lt; 28.5이고 BB %B \u0026lt; 0.23일 때만 매수\u0026rdquo; 해결책:\n조건을 단순하게 유지 다양한 기간 테스트 (샘플 외 검증) 논리적으로 타당한 조합만 사용 8.7.2 상관관계 문제# 문제: 유사한 지표 중복 사용\nRSI + Stochastic: 둘 다 모멘텀 지표 → 중복 SMA(50/200) + EMA(50/200): 거의 동일한 신호 해결책:\n서로 다른 유형의 지표 결합 추세 + 모멘텀 + 변동성 8.7.3 복잡성 증가# 문제: 이해와 관리가 어려워짐\n버그 발생 가능성 증가 실시간 의사결정 어려움 해결책:\n명확한 규칙 유지 충분한 테스트와 문서화 8.8 실전 적용 가이드# 8.8.1 지표 선택 원칙# 1단계: 추세 파악 도구 선택\n이동평균 (SMA, EMA) ADX (추세 강도) 2단계: 진입 타이밍 도구 선택\nRSI (모멘텀) Stochastic (모멘텀) MACD (추세 + 모멘텀) 3단계: 리스크 관리 도구 선택\nBollinger Bands (변동성) ATR (변동성) 8.8.2 백테스팅 체크리스트# 충분한 데이터 기간 (최소 5년) 다양한 시장 환경 포함 (상승/하락/횡보) 샘플 외 검증 (out-of-sample test) 현실적인 수수료 및 슬리피지 반영 Sharpe Ratio \u0026gt; 1.0 목표 Maximum Drawdown \u0026lt; 30% 목표 8.9 개선 방향# 다중 지표 전략을 더욱 개선하는 방법:\n적응형 가중치: 시장 환경에 따라 지표 가중치 동적 조정 머신러닝 통합: 최적 지표 조합을 학습으로 발견 리스크 패리티: 각 지표의 위험 기여도를 균등하게 조정 앙상블 전략: 여러 전략을 동시에 운용하여 분산 실시간 성과 모니터링: 지표 효과가 떨어지면 자동 조정 다음 단계# Part 2 (기술적 분석 전략)를 마쳤습니다! 다음 Part 3에서는 리스크 관리와 포트폴리오 구성을 다룹니다:\nChapter 9: 포지션 크기 결정 (Position Sizing) Chapter 10: 리스크 관리 기법 Chapter 11: 포트폴리오 구성과 분산투자 기술적 분석으로 언제 매매할지 배웠다면, 이제 얼마나 매매할지, 어떻게 위험을 관리할지를 배울 차례입니다.\n8.10 실행 결과# 실제로 스크립트를 실행한 결과입니다:\n============================================================ Chapter 8: 다중 지표 결합 전략 ============================================================ === 백테스트 설정 === - 티커: AAPL - 기간: 2019-01-01 ~ 2024-01-01 - 초기 자금: $10,000.00 - 수수료: 0.1% ============================================================ 백테스트 실행 중... ============================================================ [1/3] 추세 확인 + 과매도 진입 전략... ================================================== === 추세 확인 + 과매도 진입 === ================================================== 총 수익률: +18.61% Sharpe Ratio: 1.090 Max Drawdown: 23.52% 거래 횟수: 3, 승률: 100.0% [2/3] 골든 크로스 + 모멘텀 확인 전략... ================================================== === 골든 크로스 + 모멘텀 확인 === ================================================== 총 수익률: +20.66% Sharpe Ratio: 0.500 Max Drawdown: 14.41% 거래 횟수: 1, 승률: 0.0% [3/3] 종합 신호 점수 전략... ================================================== === 종합 신호 점수 === ================================================== 총 수익률: +116.34% Sharpe Ratio: 0.658 Max Drawdown: 27.87% 거래 횟수: 2, 승률: 50.0% ============================================================ === 전략 비교 요약 === ============================================================ Buy \u0026amp; Hold: +408.08% 추세 확인 + 과매도 진입: +18.61% 골든 크로스 + 모멘텀 확인: +20.66% 종합 신호 점수: +116.34%\n차트 해석# 패널 1: 가격과 이동평균\nAAPL 종가를 SMA(50)과 SMA(200)과 함께 표시 골든 크로스 (녹색 삼각형): 50일선이 200일선을 상향 돌파 - 강력한 매수 신호 데드 크로스 (빨간색 역삼각형): 50일선이 200일선을 하향 돌파 - 매도 신호 2019년 초 골든 크로스 이후 강한 상승 추세 지속 2020년 3월 COVID-19 하락 시 일시적으로 추세 전환 패널 2: RSI(14) - 모멘텀 지표\n과매수 구간 (70 이상): 빨간색 음영 영역 과매도 구간 (30 이하): 녹색 음영 영역 RSI가 30 이하로 떨어질 때 매수 기회 (상승 추세 중인 경우) RSI가 70 이상일 때 익절 고려 강한 추세 시장에서는 RSI가 오랜 기간 과매수/과매도 구간에 머물 수 있음 패널 3: Bollinger Bands - 변동성 지표\n중간 밴드 (파란색): 20일 SMA 상단/하단 밴드 (빨간색/녹색 점선): ±2 표준편차 가격이 하단 밴드 근처에서 상단 밴드로 이동하는 패턴 반복 밴드 폭이 좁아진 후 확장되는 시점이 변동성 증가 및 추세 시작 신호 2020년 3월 급격한 밴드 확장 = 극심한 변동성 패널 4: 종합 신호 점수\n추세, 모멘텀, 변동성 지표를 종합한 점수 (-5 ~ +5) +3 이상 (녹색 영역): 강한 매수 신호 -3 이하 (빨간색 영역): 강한 매도 신호 점수가 0 근처에서 오래 머물 때 = 불확실한 시장 (거래 자제) 극단적 점수 (+5, -5)는 여러 지표가 동시에 강한 신호를 보낼 때 발생 성과 분석# 1. 추세 확인 + 과매도 진입 전략# 수익률: +18.61% Sharpe Ratio: 1.090 (우수) Max DD: 23.52% 거래: 3회, 승률 100% 특징:\n보수적 접근: 상승 추세 확인 후에만 매수 높은 승률: 모든 거래에서 수익 낮은 거래 빈도: 엄격한 조건으로 기회 제한 좋은 리스크 조정 수익 (Sharpe \u0026gt; 1.0) 2. 골든 크로스 + 모멘텀 확인 전략# 수익률: +20.66% Sharpe Ratio: 0.500 (보통) Max DD: 14.41% (가장 낮음) 거래: 1회, 승률 0% (아직 청산 안 됨) 특징:\n가장 보수적: 골든 크로스라는 매우 강한 신호만 사용 장기 포지션: 1회 진입 후 유지 낮은 최대 낙폭: 안정적 수익 곡선 추세 추종 전략의 특성: 소수의 큰 승리 추구 3. 종합 신호 점수 전략 (최고 성과!)# 수익률: +116.34% Sharpe Ratio: 0.658 Max DD: 27.87% 거래: 2회, 승률 50% 특징:\n가장 높은 절대 수익률: Buy \u0026amp; Hold를 제외하고 최고 유연한 의사결정: 점수 기반으로 다양한 시장 상황 대응 적절한 거래 빈도: 과매매 피하면서도 기회 포착 승률보다 손익비 중요: 승률 50%이지만 큰 수익 벤치마크 비교# Buy \u0026amp; Hold: +408.08% (AAPL의 강한 상승 추세) 종합 점수 전략: +116.34% (다중 지표 중 최고) 골든 크로스: +20.66% 추세+과매도: +18.61% 핵심 인사이트:\n다중 지표 결합의 효과\n종합 점수 전략이 가장 높은 수익률 달성 여러 관점에서 시장을 분석하면 더 나은 진입/퇴출 타이밍 포착 필터링의 양면성\n엄격한 필터 (추세+과매도, 골든크로스) = 높은 승률, 낮은 수익률 유연한 접근 (종합 점수) = 더 많은 기회, 높은 수익률 리스크-수익 트레이드오프\n골든 크로스: 낮은 변동성 (Max DD 14.41%), 낮은 수익 종합 점수: 높은 변동성 (Max DD 27.87%), 높은 수익 Sharpe Ratio로 리스크 조정 후에도 추세+과매도가 가장 효율적 (1.090) 강한 트렌드 시장의 도전\nAAPL의 지속적 상승 (2019-2024)에서는 Buy \u0026amp; Hold가 최고 기술적 지표 전략은 조정 기회를 기다리느라 시장 놓침 이러한 시장에서는 \u0026ldquo;추세를 거스르지 말라\u0026rdquo; 원칙이 중요 전략 선택 가이드\n안정성 우선: 추세+과매도 (Sharpe 1.090, 높은 승률) 절대 수익 추구: 종합 점수 (+116.34%) 보수적 장기 투자: 골든 크로스 (낮은 DD) 강한 상승장: Buy \u0026amp; Hold 고려 과최적화 경고\n이 결과는 AAPL 2019-2024 기간에 최적화됨 다른 종목, 다른 기간에서는 성과가 다를 수 있음 실전 적용 전 다양한 시장 환경에서 검증 필요 실전 적용 시 고려사항\n수수료와 슬리피지가 낮은 거래 빈도 전략에 유리 종합 점수 전략은 2회 거래로 +116% 달성 = 매우 효율적 거래 빈도가 낮으면 실전과 백테스트 결과 차이 최소화 코드 실행:\ncd codes uv run chapter08/01_multi_indicator_strategy.py"},{"id":8,"href":"/intro-to-backtesting/docs/chapter09/","title":"Chapter 9: 포지션 크기 결정","section":"Docs","content":"Chapter 9: 포지션 크기 결정# 아무리 좋은 전략이라도 포지션 크기를 잘못 결정하면 큰 손실을 입거나 기회를 놓칠 수 있습니다. 이번 챕터에서는 계좌 크기와 위험 허용도에 맞게 포지션 크기를 결정하는 다양한 방법을 배웁니다.\n9.1 포지션 크기의 중요성# 9.1.1 포지션 크기가 중요한 이유# 1. 위험 관리의 핵심\n너무 큰 포지션: 한 번의 손실로 계좌 파산 가능 너무 작은 포지션: 수익 기회 미활용 2. 복리 효과\n일정한 포지션 크기 유지 시 복리 효과 극대화 계좌 크기에 비례하여 포지션 조정 3. 심리적 안정\n적절한 포지션 크기로 감정적 의사결정 방지 손실을 견딜 수 있는 수준 유지 9.1.2 포지션 크기의 기본 원칙# 원칙 1: 한 번의 거래로 전체 계좌의 1-2% 이상 위험에 노출하지 않기\n예: 계좌 $10,000 → 거래당 최대 위험: $100-$200원칙 2: 계좌 크기에 비례하여 포지션 조정\n계좌 $10,000 → 포지션 $9,500 계좌 $20,000 → 포지션 $19,000원칙 3: 변동성에 따라 포지션 크기 조정\n고변동성 자산 → 작은 포지션 저변동성 자산 → 큰 포지션9.2 포지션 크기 결정 방법# 9.2.1 고정 금액 (Fixed Amount)# 방법: 매번 동일한 금액 투자\nposition_size = fixed_amount # 예: $5,000 shares = position_size / current_price장점:\n단순하고 이해하기 쉬움 구현 간단 단점:\n계좌 크기 변화 무시 복리 효과 없음 위험 관리 어려움 적용 사례: 초보자, 소액 계좌\n9.2.2 고정 비율 (Fixed Percentage)# 방법: 계좌 크기의 일정 비율 투자\nposition_size = account_value * percentage # 예: 95% shares = position_size / current_price장점:\n계좌 크기에 비례하여 자동 조정 복리 효과 발생 구현 간단 단점:\n변동성 고려 없음 연속 손실 시 빠른 계좌 감소 적용 사례: 가장 일반적인 방법, 장기 투자\n9.2.3 고정 위험 (Fixed Risk)# 방법: 거래당 위험을 계좌의 일정 비율로 제한\n$$ \\text{Position Size} = \\frac{\\text{Account Value} \\times \\text{Risk \\%}}{\\text{Entry Price} - \\text{Stop Loss Price}} $$예시:\n계좌: $10,000 위험 허용: 1% → $100 진입가: $100 손절가: $95 손실폭: $5 포지션 크기 = $100 / $5 = 20주 투자금액 = 20주 × $100 = $2,000장점:\n명확한 위험 관리 손실을 정확히 제어 변동성 자동 반영 단점:\n손절매 필수 계산 복잡 적용 사례: 전문 트레이더, 단기 매매\n9.2.4 켈리 기준 (Kelly Criterion)# 방법: 최적 성장률을 위한 수학적 공식\n$$ f^* = \\frac{p \\cdot (b + 1) - 1}{b} $$또는 더 간단하게:\n$$ f^* = \\frac{W - (1 - W)}{R} $$여기서:\n$f^*$: 투자할 자본 비율 $W$: 승률 (Win Rate) $R$: 평균 승리/평균 손실 비율 (Reward/Risk Ratio) $p$: 승률 $b$: 배당률 (net odds) 예시:\n승률 (W) = 60% = 0.6 평균 수익 = $300 평균 손실 = $150 R = $300 / $150 = 2 Kelly % = (0.6 - (1-0.6)) / 2 = (0.6 - 0.4) / 2 = 0.1 = 10%장점:\n이론적으로 최적의 성장률 장기적으로 복리 최대화 단점:\n실전에서는 너무 공격적 승률과 손익비 정확한 추정 필요 변동성이 큼 개선: Half-Kelly 또는 Quarter-Kelly\nkelly_percentage = (win_rate - (1 - win_rate)) / reward_risk_ratio safe_percentage = kelly_percentage * 0.5 # Half-Kelly적용 사례: 경험 많은 트레이더, 안정적인 전략\n9.2.5 변동성 기반 (Volatility-Based)# 방법: ATR(Average True Range)를 사용한 변동성 고려\n$$ \\text{Position Size} = \\frac{\\text{Account Value} \\times \\text{Risk \\%}}{\\text{ATR} \\times \\text{ATR Multiplier}} $$예시:\n계좌: $10,000 위험 허용: 1% → $100 ATR(14) = $5 ATR 배수 = 2 (손절매 = 진입가 - 2×ATR) 포지션 크기 = $100 / ($5 × 2) = 10주장점:\n시장 변동성 자동 반영 동적 위험 조정 다양한 자산 비교 가능 단점:\nATR 계산 필요 구현 복잡 적용 사례: 다양한 자산 거래, 변동성 큰 시장\n9.3 Backtrader에서 포지션 크기 관리# 9.3.1 Sizer 클래스# Backtrader는 Sizer 클래스를 통해 포지션 크기를 관리합니다:\n# 고정 비율 cerebro.addsizer(bt.sizers.PercentSizer, percents=95) # 고정 수량 cerebro.addsizer(bt.sizers.FixedSize, stake=100) # 고정 위험 (커스텀 구현 필요) cerebro.addsizer(FixedRiskSizer, risk_percent=1.0)9.3.2 커스텀 Sizer 구현# class FixedRiskSizer(bt.Sizer): params = ( (\u0026#39;risk_percent\u0026#39;, 1.0), # 위험 비율 (%) ) def _getsizing(self, comminfo, cash, data, isbuy): if isbuy: # 계좌 크기 account_value = self.broker.getvalue() # 위험 금액 risk_amount = account_value * (self.params.risk_percent / 100) # 진입가와 손절가 (전략에서 설정) entry_price = data.close[0] stop_loss = self.strategy.stop_loss_price # 주당 위험 risk_per_share = entry_price - stop_loss if risk_per_share \u0026gt; 0: # 포지션 크기 계산 position_size = risk_amount / risk_per_share return int(position_size) return 09.4 실전 구현# 이번 챕터의 코드에서는 다음을 구현합니다:\n고정 비율 전략: 95% 투자 고정 위험 전략: 거래당 1% 위험 켈리 기준 전략: Half-Kelly 방법 변동성 기반 전략: ATR 기반 포지션 크기 성과 비교: 각 방법의 수익률, 위험, Sharpe Ratio 9.5 기대 결과# 코드를 실행하면 다음을 확인할 수 있습니다:\n계좌 성장 곡선: 각 포지션 크기 방법별 계좌 가치 변화 포지션 크기 변화: 시간에 따른 포지션 크기 조정 위험 지표: 최대 낙폭 (Maximum Drawdown) 변동성 (Volatility) Sharpe Ratio 거래 통계: 평균 포지션 크기, 최대/최소 포지션 비교 분석: 어떤 방법이 가장 안정적이고 수익성이 높은가? 9.6 분석 포인트# 코드를 실행한 후 다음을 분석해보세요:\n위험 조정 수익: 높은 수익률보다 Sharpe Ratio가 중요 최대 낙폭: 감내할 수 있는 수준인가? 계좌 성장 안정성: 부드러운 성장 vs. 급등락 포지션 크기 변화: 시장 변동성에 적절히 반응하는가? 복리 효과: 고정 비율 방법의 복리 효과 확인 9.7 포지션 크기 결정 시 주의사항# 9.7.1 과도한 레버리지 피하기# 문제: 켈리 기준이 20%를 제안해도 너무 공격적\n해결책: Half-Kelly 또는 Quarter-Kelly 사용\nkelly = 0.20 safe_kelly = kelly * 0.5 # 10%9.7.2 연속 손실 대비# 문제: 연속 손실 시 계좌 급감\n해결책: 최대 손실 제한 설정\nif consecutive_losses \u0026gt;= 3: position_size *= 0.5 # 포지션 크기 절반으로 축소9.7.3 승률과 손익비 변화# 문제: 과거 데이터 기반 켈리 계산이 미래에 맞지 않음\n해결책:\n보수적 추정 사용 주기적으로 재계산 실시간 성과 모니터링 9.7.4 유동성 고려# 문제: 계산된 포지션 크기가 시장 유동성 초과\n해결책:\ndaily_volume = data.volume[0] max_position = daily_volume * 0.01 # 일일 거래량의 1% position_size = min(calculated_size, max_position)9.8 실전 적용 가이드# 9.8.1 초보자 권장 설정# # 보수적 접근 position_size = account_value * 0.50 # 50% 투자 risk_per_trade = account_value * 0.01 # 1% 위험9.8.2 중급자 권장 설정# # 균형 잡힌 접근 position_size = account_value * 0.80 # 80% 투자 risk_per_trade = account_value * 0.015 # 1.5% 위험9.8.3 전문가 권장 설정# # 공격적 접근 (Half-Kelly) kelly = (win_rate - (1 - win_rate)) / reward_risk_ratio position_size = account_value * kelly * 0.5 risk_per_trade = account_value * 0.02 # 2% 위험9.9 포지션 크기 최적화# 9.9.1 백테스팅을 통한 최적화# 다양한 포지션 크기로 백테스트:\nfor position_percent in [0.25, 0.50, 0.75, 0.95]: # 백테스트 실행 # Sharpe Ratio 및 Max Drawdown 비교최적화 목표:\n최대 Sharpe Ratio 최소 Drawdown 목표 수익률 달성 9.9.2 동적 포지션 조정# 시장 환경에 따라 포지션 크기 조정:\nif market_volatility \u0026gt; threshold: position_size *= 0.7 # 변동성 높을 때 축소 else: position_size *= 1.0 # 정상9.10 실행 결과# 실제로 스크립트를 실행한 결과입니다:\n============================================================ Chapter 9: 포지션 크기 결정 ============================================================ === 백테스트 설정 === - 티커: AAPL - 기간: 2019-01-01 ~ 2024-01-01 - 초기 자금: $10,000.00 - 전략: SMA(50/200) 크로스오버 ============================================================ 백테스트 실행 중... ============================================================ [1/4] 고정 비율 (95%) 전략... ============================================================ === 고정 비율 (95%) === ============================================================ 총 수익률: +11.07% 최종 자금: $11,106.95 Sharpe Ratio: 0.266 Max Drawdown: 14.41% 거래 횟수: 2, 승률: 0.0% [2/4] 고정 비율 (50%) 전략... ============================================================ === 고정 비율 (50%) === ============================================================ 총 수익률: +6.24% 최종 자금: $10,623.54 Sharpe Ratio: 0.266 Max Drawdown: 8.31% 거래 횟수: 2, 승률: 0.0% [3/4] 고정 위험 (1%) 전략... ============================================================ === 고정 위험 (1%) === ============================================================ 총 수익률: +3.04% 최종 자금: $10,303.77 Sharpe Ratio: 0.311 Max Drawdown: 3.64% 거래 횟수: 2, 승률: 0.0% [4/4] 켈리 기준 (Half-Kelly) 전략... ============================================================ === 켈리 기준 (Half-Kelly) === ============================================================ 총 수익률: +0.43% 최종 자금: $10,042.92 Sharpe Ratio: 0.277 Max Drawdown: 0.58% 거래 횟수: 2, 승률: 0.0% ============================================================ === 포지션 크기 방법 비교 요약 === ============================================================ 방법 수익률 Sharpe MDD ------------------------------------------------------------ 고정 비율 (95%) 11.07% 0.27 14.41% 고정 비율 (50%) 6.24% 0.27 8.31% 고정 위험 (1%) 3.04% 0.31 3.64% Kelly (Half) 0.43% 0.28 0.58%\n차트 해석# 패널 1: 계좌 가치 변화\n4가지 포지션 크기 방법의 계좌 가치 추이 비교 고정 비율 95% (파란색): 가장 높은 수익률 (+11.07%)이지만 가장 큰 변동성 고정 비율 50% (주황색): 중간 수익률 (+6.24%), 변동성 절반 감소 고정 위험 1% (녹색): 보수적 수익률 (+3.04%), 매우 안정적 Kelly Half (빨간색): 가장 낮은 수익률 (+0.43%), 최소 변동성 패널 2: Drawdown 비교\n각 방법의 최대 낙폭 시각화 고정 비율 95%: 최대 14.41% 하락 - 심리적으로 부담될 수 있는 수준 고정 비율 50%: 8.31% 하락 - 절반 투자로 손실도 절반 고정 위험 1%: 3.64% 하락 - 안정적이지만 기회비용 큼 Kelly Half: 0.58% 하락 - 거의 손실 없지만 수익도 미미 패널 3: 포지션 크기 변화\n시간에 따른 포지션 크기 (주식 수) 변화 고정 비율 방법은 계좌 가치에 비례하여 포지션 조정 (복리 효과) 고정 위험/Kelly 방법은 시장 변동성에 따라 동적 조정 변동성 높을 때 포지션 자동 축소 = 위험 관리 패널 4: 위험-수익 산점도\nX축: Maximum Drawdown (위험) Y축: 총 수익률 (수익) 이상적 위치: 왼쪽 상단 (낮은 위험, 높은 수익) 관찰: 고정 비율 95%가 가장 높은 수익이지만 위험도 가장 높음 트레이드오프: 더 높은 수익을 원하면 더 큰 위험 감수 필요 성과 분석 및 핵심 인사이트# 1. 포지션 크기와 수익률의 관계# 결과 요약:\n방법 수익률 Sharpe Ratio Max DD 최종 자금 고정 비율 95% +11.07% 0.266 14.41% $11,106.95 고정 비율 50% +6.24% 0.266 8.31% $10,623.54 고정 위험 1% +3.04% 0.311 3.64% $10,303.77 Kelly Half +0.43% 0.277 0.58% $10,042.92 관찰:\n포지션 크기가 클수록 수익률과 위험 모두 증가 고정 비율 50%는 95%의 56% 수익 (정확히 절반은 아님) 수익률은 선형적이지 않고 복리 효과와 변동성에 영향받음 2. 리스크 조정 수익률 (Sharpe Ratio)# 고정 위험 1%가 최고 Sharpe Ratio (0.311):\n변동성 대비 가장 효율적인 수익 절대 수익률은 낮지만 위험을 고려하면 가장 우수 실전에서는 Sharpe Ratio가 더 중요한 지표 Sharpe Ratio 해석:\n0.27-0.31: 모두 보통 수준 (1.0 이상이 우수) 전략 자체 (SMA 크로스오버)의 성과가 제한적 좋은 전략 + 적절한 포지션 크기 = 높은 Sharpe 3. Maximum Drawdown의 중요성# 감내할 수 있는 수준인가?:\n14.41% (95%): 많은 투자자에게 심리적 부담 8.31% (50%): 대부분 감내 가능 3.64% (1%): 매우 안정적, 초보자 적합 0.58% (Kelly): 거의 없음, 하지만 수익도 미미 실전 적용:\n자신의 손실 허용도를 먼저 파악 \u0026ldquo;얼마 잃으면 잠을 못 자는가?\u0026rdquo; 질문 Max DD \u0026lt; 20%를 일반적 목표로 설정 4. 켈리 기준의 실전 적용# Kelly가 가장 낮은 수익률을 보인 이유:\n전략의 승률이 낮아 (2회 거래, 승률 0%) Kelly 값이 매우 보수적으로 계산됨 Half-Kelly는 Full Kelly의 절반으로 더욱 보수적 교훈: 과거 성과가 불확실하면 Kelly는 극도로 조심스러워짐 Kelly의 장단점:\n장점: 이론적으로 최적의 장기 복리 성장 단점: 승률/손익비 추정이 정확해야 함, 실전에서는 과거 데이터 사용 권장: 항상 Half-Kelly 또는 Quarter-Kelly 사용 5. 복리 효과 관찰# 고정 비율 방법의 복리:\n수익 발생 시 다음 거래의 포지션 크기 증가 손실 발생 시 다음 거래의 포지션 크기 감소 장기적으로 계좌 성장 가속화 복리의 양면성:\n✅ 수익 시 더 빠른 성장 ❌ 손실 시 더 빠른 감소 연속 손실이 치명적일 수 있음 6. 포지션 크기 선택 가이드# 목표에 따른 선택:\n공격적 성장 추구: 고정 비율 80-95%\n높은 수익 기대 변동성 감내 필요 충분한 경험과 자금 필요 균형 잡힌 접근: 고정 비율 50-70%\n적절한 수익과 위험 균형 대부분의 투자자에게 적합 권장 시작점 보수적 운용: 고정 위험 1%\n안정적 계좌 성장 초보자, 큰 자금 적합 심리적 안정감 초보수적: Kelly (Half/Quarter)\n최소 위험 전략 검증 단계 실전 경험 부족 시 7. 실전 적용 시 고려사항# 포지션 크기 결정 체크리스트:\n계좌 크기: 작은 계좌는 더 보수적으로 경험 수준: 초보자는 50% 이하 위험 허용도: 손실 견딜 수 있는 범위 확인 전략 신뢰도: 검증된 전략은 더 공격적으로 시장 환경: 불확실할 때는 축소 다각화: 다른 전략/자산에도 분산 필요 동적 조정 전략:\n# 예시: 연속 손실 시 포지션 축소 if consecutive_losses \u0026gt;= 3: position_percent *= 0.5 # 절반으로 축소 elif consecutive_wins \u0026gt;= 5: position_percent = min(original_percent, position_percent * 1.2) # 점진적 증가8. 이 테스트의 한계# 주의사항:\nSMA 크로스오버는 2회만 거래 (샘플 적음) 더 많은 거래가 있는 전략에서는 결과가 다를 수 있음 단일 종목 (AAPL)에만 테스트 2019-2024 특정 기간에 최적화됨 권장사항:\n여러 종목, 여러 기간에서 테스트 최소 30회 이상 거래가 있는 전략으로 검증 실전 투입 전 충분한 샘플 외 검증 9. 최종 권장사항# 초보자: 고정 비율 50% + 거래당 위험 1%\n균형 잡힌 접근 충분한 경험 쌓기 Max DD 10% 이하 목표 중급자: 고정 비율 70-80% + 거래당 위험 1.5%\n검증된 전략 운용 Max DD 15% 이하 목표 시장 환경에 따라 동적 조정 전문가: 고정 비율 + Kelly 결합\n전략별 최적 포지션 계산 복수 전략 포트폴리오 운용 실시간 리스크 모니터링 9.11 개선 방향# 포지션 크기 전략을 더욱 개선하는 방법:\n다중 자산 포트폴리오: 자산별 최적 포지션 배분 상관관계 고려: 상관관계 높은 자산은 합산 위험 계산 시장 체제 인식: 상승장/하락장/횡보장별 다른 설정 머신러닝 통합: 최적 포지션 크기 학습 실시간 조정: 실시간 변동성 및 위험에 따라 동적 조정 다음 단계# 다음 챕터에서는 손절매(Stop Loss)와 익절매(Take Profit)를 포함한 종합적인 리스크 관리 기법을 배웁니다. 포지션 크기 결정만큼이나 중요한 것이 언제 손실을 확정하고 이익을 실현할 것인가입니다.\n코드 실행:\ncd codes uv run chapter09/01_position_sizing.py"},{"id":9,"href":"/intro-to-backtesting/docs/chapter10/","title":"Chapter 10: 리스크 관리와 손절매","section":"Docs","content":"Chapter 10: 리스크 관리와 손절매# 성공적인 트레이딩의 핵심은 수익을 극대화하는 것이 아니라 손실을 최소화하는 것입니다. 이번 챕터에서는 손절매(Stop Loss)와 익절매(Take Profit)를 활용한 체계적인 리스크 관리 기법을 배웁니다.\n10.1 리스크 관리의 중요성# 10.1.1 왜 리스크 관리가 중요한가?# 손실의 비대칭성:\n10% 손실 → 11.1% 수익 필요 (회복) 20% 손실 → 25% 수익 필요 50% 손실 → 100% 수익 필요!복리 효과의 역:\n작은 손실도 누적되면 계좌 파괴 일관된 소액 손실 제어가 핵심 감정적 의사결정 방지:\n큰 손실 → 패닉 매도 또는 복수 매매 명확한 규칙으로 감정 제어 10.1.2 리스크 관리의 기본 원칙# 원칙 1: 거래 전에 손절매 지점 결정\n진입 전 → 손절매 가격 설정 진입 후 → 절대 변경하지 않음원칙 2: 손익비(Risk-Reward Ratio) 최소 1:2\n손실 위험: $100 목표 수익: $200 이상 손익비 = 목표 수익 / 위험 손실 = 2:1원칙 3: 연속 손실 대비 계획\n3회 연속 손실 시 → 휴식 또는 포지션 축소 시스템 재검토 필요10.2 손절매 (Stop Loss) 유형# 10.2.1 고정 비율 손절매 (Percentage Stop)# 방법: 진입가에서 고정 비율만큼 떨어지면 청산\nentry_price = 100 stop_loss_percent = 0.02 # 2% stop_loss_price = entry_price * (1 - stop_loss_percent) # $98장점:\n단순하고 명확 계산 쉬움 일관된 위험 관리 단점:\n변동성 무시 시장 구조 무시 거짓 손절 가능 적용 사례: 초보자, 단기 매매\n10.2.2 ATR 기반 손절매 (ATR Stop)# 방법: ATR(Average True Range) 배수로 손절매 설정\n$$ \\text{Stop Loss} = \\text{Entry Price} - (n \\times \\text{ATR}) $$entry_price = 100 atr = 5 multiplier = 2 stop_loss_price = entry_price - (atr * multiplier) # $90장점:\n변동성 자동 반영 시장 적응적 거짓 손절 감소 단점:\nATR 계산 필요 시장별 최적 배수 다름 적용 사례: 경험자, 변동성 큰 시장\nATR 배수 가이드:\n단기 (Scalping): 1-1.5 × ATR 중기 (Swing): 2-3 × ATR 장기 (Position): 3-5 × ATR 10.2.3 지지선/저항선 기반 손절매# 방법: 주요 가격 수준 아래/위에 손절매 설정\n매수 시: 최근 저점 아래 매도 시: 최근 고점 위장점:\n시장 구조 반영 논리적 위치 심리적 안정 단점:\n주관적 판단 필요 명확한 지지/저항 없을 수 있음 적용 사례: 기술적 분석 중심 트레이더\n10.2.4 추적 손절매 (Trailing Stop)# 방법: 가격이 유리하게 움직이면 손절매도 함께 이동\n$$ \\text{Trailing Stop} = \\max(\\text{Current Stop}, \\text{Highest Price} - \\text{Trail Amount}) $$# 초기 손절매 stop_loss = entry_price * 0.98 # 2% 아래 # 가격 상승 시 if current_price \u0026gt; entry_price: new_stop = current_price * 0.98 stop_loss = max(stop_loss, new_stop) # 위로만 이동장점:\n수익 보호 큰 추세 포착 감정 제어 단점:\n조기 청산 가능 횡보장에서 불리 적용 사례: 추세 추종 전략, 큰 수익 추구\n10.2.5 시간 기반 손절매 (Time Stop)# 방법: 일정 기간 후 무조건 청산\nentry_date = datetime(2024, 1, 1) max_holding_days = 10 if current_date - entry_date \u0026gt;= timedelta(days=max_holding_days): close_position()장점:\n자본 효율 기회비용 감소 시스템 단순화 단점:\n가격 무시 추세 놓칠 수 있음 적용 사례: 단기 매매, 옵션 거래\n10.3 익절매 (Take Profit) 전략# 10.3.1 고정 목표 익절매# 방법: 손익비에 따른 목표가 도달 시 청산\nentry_price = 100 stop_loss = 95 risk = entry_price - stop_loss # $5 reward_risk_ratio = 2 take_profit = entry_price + (risk * reward_risk_ratio) # $110장점:\n명확한 목표 손익비 준수 감정 제거 단점:\n큰 추세 놓칠 수 있음 목표가 임의적일 수 있음 10.3.2 부분 익절 (Partial Profit Taking)# 방법: 여러 단계로 나눠 익절\nentry_price = 100 position_size = 100 # 첫 번째 목표 (+5%) if price \u0026gt;= 105: close_shares(50) # 50% 청산 # 두 번째 목표 (+10%) if price \u0026gt;= 110: close_shares(30) # 추가 30% 청산 # 나머지는 추적 손절매장점:\n위험 감소 큰 추세도 포착 심리적 안정 단점:\n복잡성 증가 수수료 증가 10.3.3 추적 익절 (Trailing Take Profit)# 방법: 가격이 유리하게 움직일 때만 추적\n# 일정 수익 이상 달성 후 추적 시작 if profit \u0026gt;= initial_target: trailing_stop_active = True if trailing_stop_active: trail_stop = highest_price * 0.95 # 5% 아래 추적10.4 손익비와 승률의 관계# 10.4.1 손익비 (Risk-Reward Ratio)# $$ \\text{Risk-Reward Ratio} = \\frac{\\text{Average Win}}{\\text{Average Loss}} $$10.4.2 기대값 (Expected Value)# $$ \\text{EV} = (W \\times \\text{AvgWin}) - ((1 - W) \\times \\text{AvgLoss}) $$여기서 $W$는 승률 (Win Rate)\n예시:\n승률 40%, 평균 수익 $300, 평균 손실 $100 EV = (0.4 × 300) - (0.6 × 100) = 120 - 60 = $60 (양수 → 수익성 있음!)10.4.3 손익비-승률 조합# 승률 필요한 최소 손익비 비고 30% 2.33:1 낮은 승률, 높은 손익비 40% 1.50:1 균형 잡힌 조합 50% 1.00:1 가장 쉬움 60% 0.67:1 높은 승률, 낮은 손익비 가능 교훈: 낮은 승률도 높은 손익비로 수익 가능!\n10.5 Backtrader에서 손절매/익절매 구현# 10.5.1 고정 손절매/익절매# class StopLossStrategy(bt.Strategy): params = ( (\u0026#39;stop_loss_percent\u0026#39;, 0.02), # 2% 손절 (\u0026#39;take_profit_percent\u0026#39;, 0.04), # 4% 익절 ) def notify_order(self, order): if order.status == order.Completed: if order.isbuy(): # 손절매/익절매 주문 생성 stop_price = order.executed.price * (1 - self.params.stop_loss_percent) limit_price = order.executed.price * (1 + self.params.take_profit_percent) self.sell(exectype=bt.Order.Stop, price=stop_price) self.sell(exectype=bt.Order.Limit, price=limit_price)10.5.2 ATR 기반 손절매# def next(self): if not self.position: if buy_signal: self.buy() else: # ATR 손절매 atr = self.atr[0] stop_price = self.position.price - (atr * 2) if self.data.close[0] \u0026lt; stop_price: self.close()10.5.3 추적 손절매# class TrailingStopStrategy(bt.Strategy): def __init__(self): self.highest_price = 0 self.trail_percent = 0.05 # 5% def next(self): if self.position: # 최고가 업데이트 if self.data.close[0] \u0026gt; self.highest_price: self.highest_price = self.data.close[0] # 추적 손절매 확인 trail_stop = self.highest_price * (1 - self.trail_percent) if self.data.close[0] \u0026lt; trail_stop: self.close()10.6 실전 구현# 이번 챕터의 코드에서는 다음을 구현합니다:\n고정 비율 손절매/익절매: 2% 손절, 4% 익절 ATR 기반 손절매: 2×ATR 손절매 추적 손절매: 고점에서 5% 아래 추적 손절매 없는 전략과 비교 성과 분석: 승률, 손익비, 최대 낙폭 10.7 기대 결과# 코드를 실행하면 다음을 확인할 수 있습니다:\n손절매 효과: 최대 낙폭 감소 확인 승률과 손익비: 각 방법의 승률과 평균 손익 거래 빈도: 손절매 사용 시 거래 증가 위험 조정 수익: Sharpe Ratio 개선 여부 손절매 히트맵: 어느 구간에서 손절이 많이 발생하는가? 10.8 리스크 관리 체크리스트# 10.8.1 거래 전# 손절매 가격 결정 익절매 목표 설정 손익비 확인 (최소 1:2) 포지션 크기 계산 최대 손실 금액 확인 10.8.2 거래 중# 손절매 주문 즉시 설정 감정적 판단 배제 손절매 임의 변경 금지 추적 손절매 업데이트 (해당 시) 10.8.3 거래 후# 거래 기록 및 분석 손절매 적절성 평가 손익비 달성 여부 확인 개선점 도출 10.9 흔한 실수와 대응# 10.9.1 손절매 이동하기# 문제: \u0026ldquo;조금만 더 기다리면\u0026hellip;\u0026rdquo; → 큰 손실\n해결책:\n자동 주문 시스템 사용 원칙 준수 강조 거래 일지 작성 10.9.2 너무 가까운 손절매# 문제: 정상 변동으로 손절 → 거짓 손절\n해결책:\nATR 기반 거리 사용 변동성 고려 백테스팅으로 최적화 10.9.3 손절매 없이 거래# 문제: \u0026ldquo;이번엔 괜찮아\u0026rdquo; → 계좌 파산\n해결책:\n손절매 필수 규칙화 최악의 시나리오 시뮬레이션 작은 계좌로 연습 10.10 개선 방향# 리스크 관리를 더욱 개선하는 방법:\n동적 손절매: 변동성에 따라 손절매 거리 조정 상관관계 고려: 여러 포지션의 합산 위험 관리 최대 일일 손실: 하루 최대 손실 도달 시 거래 중단 월간 손실 제한: 월 손실 한도 설정 심리적 준비: 손실 시뮬레이션 및 대응 훈련 다음 단계# 다음 챕터에서는 여러 자산에 분산투자하는 포트폴리오 구성 방법을 배웁니다. 단일 자산 리스크를 넘어 포트폴리오 전체의 위험을 관리하는 방법을 다룹니다.\n10.11 실행 결과# 실제로 스크립트를 실행한 결과입니다:\n========================================== Chapter 10: 리스크 관리와 손절매 ========================================== 테스트 기간: 2019-01-01 ~ 2024-01-01 (AAPL) ========================================== 전략별 백테스트 결과 ========================================== 1. 손절매 없음 (기준선) - 최종 자산: $11,106.50 - 총 수익률: +11.07% - Sharpe Ratio: 0.27 - 최대 낙폭: -14.41% - 총 거래 수: 2 2. 고정 비율 손절매 (2% 손절, 4% 익절) - 최종 자산: $9,674.49 - 총 수익률: -3.26% - Sharpe Ratio: -0.15 - 최대 낙폭: -8.15% - 총 거래 수: 4 3. ATR 기반 손절매 (2x ATR) - 최종 자산: $11,171.57 - 총 수익률: +11.72% - Sharpe Ratio: 0.28 - 최대 낙폭: -14.41% - 총 거래 수: 2 4. 추적 손절매 (5% 추적) - 최종 자산: $10,552.52 - 총 수익률: +5.53% - Sharpe Ratio: 0.19 - 최대 낙폭: -8.15% - 총 거래 수: 3 ========================================== 결과 저장 완료 ========================================== 차트: codes/chapter10/images/risk_management.png\n차트 해석# 상단 패널 - 자산 곡선 비교:\n손절매 없음 (파란선): 가장 높은 최종 수익률(+11.07%)을 기록했지만, 변동성이 크고 2020년 초 급락 구간에서 큰 낙폭(-14.41%)을 경험했습니다 고정 비율 손절매 (주황선): 유일하게 손실(-3.26%)을 기록했습니다. 2% 손절매가 너무 타이트하여 정상적인 가격 변동에도 손절이 발동되어 거짓 손절(false stop-out)이 빈번했습니다 ATR 기반 손절매 (녹색선): 가장 높은 수익률(+11.72%)과 Sharpe Ratio(0.28)를 기록했습니다. 변동성을 고려한 동적 손절매가 효과적이었습니다 추적 손절매 (빨간선): 중간 수익률(+5.53%)과 낮은 최대 낙폭(-8.15%)을 보였습니다. 수익 보호에는 효과적이지만 조기 청산으로 큰 추세를 놓쳤습니다 하단 패널 - 최대 낙폭 비교:\n손절매 없음 \u0026amp; ATR 손절매: -14.41%로 동일한 최대 낙폭을 보였습니다. 이는 이 기간 동안 큰 하락 구간에서 ATR 손절매가 발동되지 않았음을 의미합니다 고정 비율 \u0026amp; 추적 손절매: -8.15%로 낙폭을 절반 가까이 줄였습니다. 리스크 통제에는 성공했지만 수익률도 함께 감소했습니다 핵심 인사이트# 1. 손절매는 항상 좋은가? → 아니다\n이 테스트에서 손절매 없는 전략이 두 번째로 좋은 성과를 보였습니다 상승 추세가 강한 시장에서는 손절매가 오히려 방해가 될 수 있습니다 AAPL은 2019-2024년 동안 강한 상승 추세를 보여 \u0026ldquo;Buy and Hold\u0026rdquo; 성향이 유리했습니다 2. 고정 비율 손절매의 위험성\n2% 손절매는 너무 타이트하여 정상 변동성에도 손절이 발생했습니다 AAPL의 일평균 변동성(ATR)을 고려하지 않아 거짓 손절이 빈번했습니다 교훈: 변동성이 큰 종목은 고정 비율보다 ATR 기반 손절매가 적합합니다 3. ATR 손절매의 우수성\n변동성을 자동으로 반영하여 적응적(adaptive) 리스크 관리를 제공합니다 정상 변동성에는 손절하지 않고, 진짜 추세 반전에만 반응합니다 가장 높은 Sharpe Ratio(0.28)로 리스크 대비 수익이 가장 좋았습니다 4. 추적 손절매의 트레이드오프\n최대 낙폭을 효과적으로 줄였지만(-8.15%), 조기 청산으로 큰 수익을 놓쳤습니다 5% 추적 간격이 이 전략에는 너무 타이트했을 수 있습니다 적합한 사용처: 단기 스윙 트레이딩, 변동성 장세 5. 시장 환경의 중요성\n이 결과는 **상승 추세 시장(bull market)**에서의 결과입니다 하락장이나 횡보장에서는 손절매의 효과가 더 클 것입니다 교훈: 전략은 시장 환경에 따라 다르게 작동합니다 6. 거래 빈도와 수익의 관계\n손절매 없음: 2회 거래 → +11.07% 고정 비율: 4회 거래 → -3.26% 빈번한 거래가 항상 좋은 것은 아닙니다 수수료와 슬리피지를 고려하면 격차는 더 벌어질 것입니다 실전 적용 가이드# 종목 특성에 따른 손절매 선택:\n종목 특성 추천 손절매 이유 고변동성 (테슬라, 비트코인) ATR 2-3배 정상 변동성 흡수 저변동성 (배당주, 유틸리티) 고정 2-3% 일관된 리스크 통제 강한 추세 (성장주) 추적 7-10% 큰 추세 포착 횡보장 (레인지) 고정 2-4% 빠른 손절 필요 손절매 설정 체크리스트:\n종목의 평균 ATR 확인 (최근 20일) 손절매 거리 \u0026gt; 2 × ATR (거짓 손절 방지) 백테스트에서 손절 빈도 확인 (월 2회 이상이면 너무 타이트) 손익비 확인 (익절 거리 ≥ 2 × 손절 거리) 시장 환경 고려 (추세장 vs. 횡보장) 코드 실행:\ncd codes uv run chapter10/01_risk_management.py"},{"id":10,"href":"/intro-to-backtesting/docs/chapter11/","title":"Chapter 11: 포트폴리오 구성과 분산투자","section":"Docs","content":"Chapter 11: 포트폴리오 구성과 분산투자# \u0026ldquo;계란을 한 바구니에 담지 마라\u0026quot;는 투자의 가장 기본적인 원칙입니다. 이번 챕터에서는 여러 자산에 분산투자하여 위험을 줄이고 안정적인 수익을 추구하는 포트폴리오 구성 방법을 배웁니다.\n11.1 분산투자의 원리# 11.1.1 왜 분산투자가 필요한가?# 단일 자산의 위험:\nAAPL만 투자 → AAPL 하락 시 전체 손실포트폴리오의 위험 감소:\nAAPL + MSFT + GOOGL + AMZN → 한 종목 하락해도 다른 종목이 보완수학적 원리: 상관관계가 낮은 자산 결합\n$$ \\sigma_p^2 = \\sum_{i=1}^{n} w_i^2 \\sigma_i^2 + \\sum_{i=1}^{n}\\sum_{j\\neq i}^{n} w_i w_j \\rho_{ij} \\sigma_i \\sigma_j $$여기서:\n$\\sigma_p$: 포트폴리오 표준편차 (위험) $w_i$: 자산 $i$의 비중 $\\sigma_i$: 자산 $i$의 표준편차 $\\rho_{ij}$: 자산 $i$와 $j$의 상관계수 11.1.2 상관관계의 중요성# 상관계수 ($\\rho$)의 의미:\n$\\rho = +1$: 완전 양의 상관 (함께 움직임) → 분산 효과 없음 $\\rho = 0$: 무상관 (독립적) → 분산 효과 있음 $\\rho = -1$: 완전 음의 상관 (반대로 움직임) → 분산 효과 최대 예시:\nAAPL \u0026amp; MSFT: ρ ≈ 0.7 (같은 기술주 섹터) AAPL \u0026amp; GOLD: ρ ≈ 0.0 (상관 낮음) 주식 \u0026amp; 채권: ρ ≈ -0.3 (음의 상관)11.1.3 최적 분산 개수# Naive Diversification: 단순 균등 분산\n$$ w_i = \\frac{1}{N} $$실증 연구 결과:\n15-20개 종목: 대부분의 비체계적 위험 제거 30개 이상: 추가 분산 효과 미미 너무 많으면: 관리 복잡, 수수료 증가 11.2 포트폴리오 배분 전략# 11.2.1 균등 비중 (Equal Weight)# 방법: 모든 자산에 동일한 비중 투자\n$$ w_i = \\frac{1}{N} $$장점:\n단순하고 명확 시가총액 편향 없음 소형주 노출 증가 단점:\n리밸런싱 빈번 수수료 증가 위험 자산에 과다 노출 가능 11.2.2 시가총액 비중 (Market Cap Weight)# 방법: 시가총액에 비례하여 투자\n$$ w_i = \\frac{\\text{Market Cap}_i}{\\sum_{j=1}^{N} \\text{Market Cap}_j} $$장점:\n시장 대표성 리밸런싱 적음 지수 추종 단점:\n대형주 편향 버블 위험 소형주 기회 놓침 11.2.3 역변동성 비중 (Inverse Volatility)# 방법: 변동성에 반비례하여 투자\n$$ w_i = \\frac{1/\\sigma_i}{\\sum_{j=1}^{N} 1/\\sigma_j} $$장점:\n위험 균등 배분 안정성 증가 변동성 큰 자산 축소 단점:\n수익률 희생 가능 변동성 변화 추적 필요 11.2.4 리스크 패리티 (Risk Parity)# 방법: 각 자산의 위험 기여도를 동일하게\n위험 기여도 (Risk Contribution):\n$$ RC_i = w_i \\times \\frac{\\partial \\sigma_p}{\\partial w_i} $$목표: $RC_1 = RC_2 = \\cdots = RC_N$\n장점:\n진정한 위험 분산 상관관계 고려 균형잡힌 포트폴리오 단점:\n계산 복잡 최적화 필요 11.2.5 평균-분산 최적화 (Mean-Variance Optimization)# Markowitz 모형: 주어진 위험 수준에서 수익 최대화\n$$ \\max_{w} \\quad \\mu^T w - \\frac{\\lambda}{2} w^T \\Sigma w $$제약 조건: $$ \\begin{align} \\sum_{i=1}^{N} w_i \u0026= 1 \\\\ w_i \u0026\\geq 0 \\quad \\forall i \\end{align} $$여기서:\n$\\mu$: 기대 수익률 벡터 $\\Sigma$: 공분산 행렬 $\\lambda$: 위험 회피 계수 장점:\n이론적으로 최적 효율적 프론티어 도출 단점:\n과거 데이터 의존 추정 오차 민감 극단적 비중 가능 11.3 리밸런싱 (Rebalancing)# 11.3.1 리밸런싱의 필요성# 문제: 시간이 지나면 비중 변화\n초기: AAPL 25%, MSFT 25%, GOOGL 25%, AMZN 25% 1년 후: AAPL 35%, MSFT 20%, GOOGL 30%, AMZN 15%목적:\n목표 비중 유지 위험 통제 차익실현 및 손절 11.3.2 리밸런싱 방법# 1. 주기적 리밸런싱 (Time-Based)\nif month == 12: # 연 1회 rebalance_to_target_weights()빈도 옵션:\n월간: 빈번, 수수료 높음 분기: 균형잡힌 선택 연간: 수수료 낮음, 편차 클 수 있음 2. 임계값 기반 리밸런싱 (Threshold-Based)\nif abs(current_weight - target_weight) \u0026gt; 0.05: # 5% 편차 rebalance()3. 혼합 방식\n# 분기마다 확인하되, 5% 편차 시만 리밸런싱 if quarter_end and abs(current_weight - target_weight) \u0026gt; 0.05: rebalance()11.3.3 리밸런싱의 효과# 수익 향상 메커니즘:\nBuy Low, Sell High: 하락한 자산 매수, 상승한 자산 매도 변동성 수익: 변동성에서 추가 수익 추출 위험 통제: 극단적 포지션 방지 예시:\n자산 A: 50% → 70% (30% 상승) 자산 B: 50% → 30% (30% 하락) 리밸런싱: - A 일부 매도 (고점 매도) - B 일부 매수 (저점 매수)11.4 Backtrader에서 다중 자산 백테스팅# 11.4.1 여러 데이터 피드 추가# # 여러 종목 데이터 다운로드 tickers = [\u0026#39;AAPL\u0026#39;, \u0026#39;MSFT\u0026#39;, \u0026#39;GOOGL\u0026#39;, \u0026#39;AMZN\u0026#39;] for ticker in tickers: data = yf.download(ticker, start, end) data_feed = bt.feeds.PandasData(dataname=data) cerebro.adddata(data_feed, name=ticker)11.4.2 포트폴리오 전략 구현# class PortfolioStrategy(bt.Strategy): def __init__(self): # 각 데이터에 대해 지표 생성 self.mas = {} for data in self.datas: self.mas[data._name] = bt.indicators.SMA(data.close, period=50) def next(self): # 균등 비중 계산 target_weight = 1.0 / len(self.datas) for data in self.datas: current_value = self.getposition(data).size * data.close[0] portfolio_value = self.broker.getvalue() current_weight = current_value / portfolio_value # 리밸런싱 if abs(current_weight - target_weight) \u0026gt; 0.05: target_value = portfolio_value * target_weight target_shares = target_value / data.close[0] self.order_target_size(data=data, target=target_shares)11.5 실전 구현# 이번 챕터의 코드에서는 다음을 구현합니다:\n단일 자산 (AAPL): 기준선 균등 비중 포트폴리오: 4개 기술주 균등 배분 역변동성 포트폴리오: 변동성 역비례 배분 리밸런싱 효과: 분기별 리밸런싱 vs. 리밸런싱 없음 상관관계 분석: 포트폴리오 구성 자산 간 상관관계 11.6 기대 결과# 코드를 실행하면 다음을 확인할 수 있습니다:\n위험 감소 효과: 단일 자산 vs. 포트폴리오 MDD 비교 상관관계 매트릭스: 자산 간 상관관계 히트맵 효율적 프론티어: 위험-수익 그래프 리밸런싱 효과: 분기별 리밸런싱 수익률 기여 Sharpe Ratio 개선: 위험 조정 수익 향상 11.7 포트폴리오 구성 원칙# 11.7.1 자산 선택# 1. 상관관계 낮은 자산:\n✓ 주식 + 채권 ✓ 미국 주식 + 해외 주식 ✓ 주식 + 원자재 ✗ 애플 + 마이크로소프트 (높은 상관)2. 다양한 자산군:\n주식 (성장) 채권 (안정) 원자재 (인플레이션 헷지) 부동산 (대체 투자) 3. 유동성 고려:\n거래량 충분 매수/매도 용이 11.7.2 비중 결정# 초보자 권장:\n주식 60% + 채권 40% 또는 주식 70% + 채권 30%공격적 투자자:\n주식 80% + 대체자산 20%보수적 투자자:\n주식 40% + 채권 50% + 현금 10%11.7.3 리밸런싱 규칙# 권장 방식: 분기별 + 5% 임계값\nif quarter_end: for asset in portfolio: if abs(current_weight - target_weight) \u0026gt; 0.05: rebalance(asset)수수료 고려:\n거래 비용 \u0026gt; 리밸런싱 이익이면 skip 큰 편차만 조정 11.8 고급 포트폴리오 기법# 11.8.1 팩터 투자 (Factor Investing)# 팩터: 수익률을 설명하는 체계적 특성\nValue: 저평가 주식 Size: 소형주 Momentum: 추세 주식 Quality: 고품질 기업 Low Volatility: 저변동성 주식 11.8.2 All Weather Portfolio (레이 달리오)# 구성:\n주식 30% 장기 채권 40% 중기 채권 15% 금 7.5% 원자재 7.5%특징: 모든 경제 환경에서 안정적\n11.8.3 60/40 포트폴리오 (전통적)# 구성:\n주식 60% 채권 40%특징: 검증된 안정성, 간단한 관리\n11.9 실전 적용 시 주의사항# 11.9.1 과거 성과 맹신 금지# 문제: 과거 최적이 미래 최적 아님\n해결:\n다양한 기간 테스트 Walk-forward 분석 스트레스 테스트 11.9.2 극단적 비중 회피# 문제: 평균-분산 최적화 시 극단적 배분\n자산 A: 95%, 자산 B: 5% ← 위험!해결:\n최소/최대 비중 제약 정규화 (Regularization) 11.9.3 실시간 모니터링# 필수 지표:\n포트폴리오 가치 각 자산 비중 최대 낙폭 Sharpe Ratio 11.10 개선 방향# 포트폴리오 전략을 더욱 개선하는 방법:\n동적 자산 배분: 시장 환경에 따라 비중 조정 Black-Litterman 모델: 주관적 전망과 시장 균형 결합 위험 버짓팅: 각 자산에 위험 예산 할당 조건부 상관관계: VIX 높을 때 상관관계 변화 반영 머신러닝 최적화: 최적 비중 학습 다음 단계# Part 3 (리스크와 포트폴리오 관리)를 완료했습니다! 다음 Part 4에서는 백테스팅 성과를 평가하고 비교하는 방법을 다룹니다:\nChapter 12: 성과 평가 지표 Chapter 13: 전략 비교와 최적화 지금까지 언제 매매하고 (기술적 분석), 얼마나 투자하며 (포지션 크기), 어떻게 위험을 관리하고 (손절매), 무엇에 분산할지 (포트폴리오)를 배웠습니다. 이제 전략을 어떻게 평가할지 배울 차례입니다.\n11.11 실행 결과# 실제로 스크립트를 실행한 결과입니다:\n========================================== Chapter 11: 포트폴리오 구성과 분산투자 ========================================== 테스트 기간: 2019-01-01 ~ 2024-01-01 포트폴리오 구성: AAPL, MSFT, GOOGL, AMZN ========================================== 단일 자산 전략 (AAPL) ========================================== 최종 자산: $49,597.99 총 수익률: +395.98% Sharpe Ratio: 1.09 최대 낙폭: -30.03% 총 거래 수: 1 ========================================== 균등 비중 포트폴리오 ========================================== 최종 자산: $29,312.50 총 수익률: +193.13% Sharpe Ratio: 0.87 최대 낙폭: -39.15% 총 거래 수: 16 (리밸런싱 포함) 평균 종목 비중: 25% (목표) ========================================== 역변동성 비중 포트폴리오 ========================================== 최종 자산: $25,142.00 총 수익률: +151.42% Sharpe Ratio: 0.79 최대 낙폭: -38.05% 총 거래 수: 16 (리밸런싱 포함) ========================================== 상관관계 분석 ========================================== AAPL MSFT GOOGL AMZN AAPL 1.000 0.756 0.682 0.624 MSFT 0.756 1.000 0.723 0.651 GOOGL 0.682 0.723 1.000 0.697 AMZN 0.624 0.651 0.697 1.000 높은 상관관계(0.6~0.8): 같은 기술주 섹터 → 분산 효과 제한적 ========================================== 결과 저장 완료 ========================================== 차트: codes/chapter11/images/portfolio_diversification.png\n차트 해석# 좌상단 패널 - 자산 곡선 비교:\n단일 자산 (AAPL, 파란선): 놀랍게도 가장 높은 수익률(+395.98%)을 기록했습니다. 2019-2024년 동안 AAPL의 강력한 상승세를 그대로 포착했습니다 균등 비중 포트폴리오 (주황선): 두 번째 수익률(+193.13%)을 보였습니다. AAPL보다 낮지만 여전히 높은 수익을 기록했습니다 역변동성 비중 (녹색선): 가장 낮은 수익률(+151.42%)이지만 가장 안정적인 상승 곡선을 보였습니다 우상단 패널 - 최대 낙폭 비교:\n단일 자산: -30.03%로 가장 낮은 최대 낙폭을 기록했습니다. 예상과 달리 분산 포트폴리오보다 낙폭이 작았습니다 균등 비중: -39.15%로 가장 큰 낙폭을 보였습니다. 4개 종목 모두 2020년 3월 코로나 팬데믹 때 동시에 하락했기 때문입니다 역변동성: -38.05%로 균등 비중과 비슷한 낙폭을 보였습니다 좌하단 패널 - 상관관계 히트맵:\n모든 종목 간 상관계수가 0.62~0.76으로 매우 높습니다 같은 기술주 섹터에 속해 있어 시장 움직임에 동시에 반응합니다 AAPL-MSFT: 0.756으로 가장 높은 상관관계 (둘 다 대형 기술주) AAPL-AMZN: 0.624로 상대적으로 낮지만 여전히 높은 상관관계 우하단 패널 - 리스크-수익 산점도:\n단일 자산 (AAPL): 가장 오른쪽 위에 위치 → 최고 수익률 + 중간 리스크 균등 비중: 중간 위치 → 중간 수익률 + 높은 리스크 역변동성: 왼쪽 아래 → 낮은 수익률 + 낮은 리스크 이상적으로는 왼쪽 위(낮은 리스크, 높은 수익)를 원하지만, 이 경우 AAPL이 가장 효율적입니다 핵심 인사이트# 1. 분산투자의 역설 (이 케이스에서)\n예상: 분산 → 리스크 감소 + 안정적 수익 실제: 단일 자산(AAPL)이 더 높은 수익 + 더 낮은 낙폭 원인: 2019-2024년은 AAPL의 황금기였고, 다른 종목들은 상대적으로 부진했습니다 2. 상관관계의 중요성\n4개 기술주의 상관계수가 0.62~0.76으로 매우 높습니다 진정한 분산 효과를 얻으려면 상관관계 \u0026lt; 0.5 또는 음의 상관관계가 필요합니다 교훈: 같은 섹터 내 분산은 진정한 분산이 아닙니다 3. 시스템적 리스크 (Systematic Risk)\n2020년 3월 코로나 팬데믹 때 모든 종목이 동시에 하락했습니다 이는 시스템적 리스크로, 분산투자로도 피할 수 없습니다 분산투자는 **비체계적 리스크(종목 고유 리스크)**만 줄일 수 있습니다 4. 균등 비중 vs. 역변동성 비중\n균등 비중: +193.13%, Sharpe 0.87 → 더 높은 수익 역변동성: +151.42%, Sharpe 0.79 → 더 낮은 수익 역변동성 비중은 안정성을 추구하지만, 성장주 비중을 줄여 수익도 감소했습니다 적합한 경우: 보수적 투자자, 하락장 대비 5. 리밸런싱 효과\n균등 비중과 역변동성 모두 16회 거래 발생 (분기별 리밸런싱) 리밸런싱은 \u0026ldquo;고점 매도, 저점 매수\u0026rdquo; 효과를 제공합니다 하지만 이 케이스에서는 AAPL의 지속적 상승으로 리밸런싱이 오히려 손해였습니다 6. Sharpe Ratio 비교\n단일 자산: 1.09 (가장 높음) → 리스크 대비 수익 최고 균등 비중: 0.87 → 양호 역변동성: 0.79 → 괜찮음 이 기간에는 단일 자산이 가장 효율적이었습니다 그렇다면 분산투자는 필요 없는가?# 아니다! 이 결과는 특수한 경우입니다:\n1. 사후 편향 (Hindsight Bias)\n2019년 시점에서 AAPL이 최고 성과를 낼 것을 알 수 없었습니다 백테스트는 \u0026ldquo;이미 알고 있는 과거\u0026quot;를 보는 것입니다 2. 생존 편향 (Survivorship Bias)\n우리는 성공한 AAPL을 선택했습니다 같은 기간 망한 기술주들은 고려하지 않았습니다 3. 시장 환경의 특수성\n2019-2024년은 기술주 슈퍼사이클이었습니다 다른 기간(예: 2000-2002 닷컴 버블 붕괴)에서는 결과가 정반대일 수 있습니다 4. 미래는 과거와 다릅니다\n과거 최고 종목이 미래에도 최고일 보장이 없습니다 분산투자는 미래 불확실성에 대한 보험입니다 올바른 분산투자 방법# 1. 섹터 분산:\n✗ 잘못된 분산: AAPL, MSFT, GOOGL, AMZN (모두 기술주) ✓ 올바른 분산: - 기술주 25% (AAPL) - 헬스케어 25% (JNJ) - 금융 25% (JPM) - 원자재 25% (GOLD)2. 자산군 분산:\n주식 60% + 채권 30% + 원자재 10% → 상관관계 0.3 이하로 진정한 분산 효과3. 지역 분산:\n미국 50% + 유럽 25% + 신흥국 25% → 지역별 경제 사이클 차이 활용실전 적용 가이드# 투자자 유형별 권장 포트폴리오:\n투자자 유형 포트폴리오 구성 기대 수익/리스크 공격적 기술주 80% + 성장주 20% 높은 수익, 높은 변동성 균형 주식 60% + 채권 40% 중간 수익, 중간 변동성 보수적 주식 30% + 채권 60% + 현금 10% 낮은 수익, 낮은 변동성 리밸런싱 주기:\n분기별: 이 테스트에서 사용, 적당한 빈도 반기별: 수수료 절감, 추세 포착에 유리 연간: 장기 투자자 적합, 최소 비용 상관관계 체크리스트:\n포트폴리오 내 평균 상관계수 \u0026lt; 0.5 최소 3개 이상의 서로 다른 섹터 주식 외 자산군 포함 (채권, 원자재 등) 지역 분산 고려 (국내 + 해외) 코드 실행:\ncd codes uv run chapter11/01_portfolio_diversification.py"},{"id":11,"href":"/intro-to-backtesting/docs/chapter12/","title":"Chapter 12: 성과 지표와 리스크 측정","section":"Docs","content":"Chapter 12: 성과 지표와 리스크 측정# 12.1 소개# 백테스팅 전략의 성과를 평가하는 것은 매우 중요합니다. 단순히 수익률만 보는 것이 아니라, 얼마나 큰 리스크를 감수했는지, 수익의 일관성은 어떠한지 등을 종합적으로 평가해야 합니다.\n이 장에서는 다양한 성과 지표와 리스크 측정 방법을 학습하고, 이를 Python으로 계산하는 방법을 알아봅니다.\n12.2 수익률 지표# 12.2.1 총 수익률 (Total Return)# 총 수익률은 투자 기간 동안의 전체 수익률을 나타냅니다:\n$$TR = \\frac{V_{\\text{end}} - V_{\\text{start}}}{V_{\\text{start}}}$$여기서:\n$V_{\\text{end}}$: 기말 포트폴리오 가치 $V_{\\text{start}}$: 기초 포트폴리오 가치 12.2.2 연환산 수익률 (Annualized Return)# 서로 다른 기간의 전략을 비교하기 위해서는 연환산 수익률을 사용합니다:\n$$AR = \\left(1 + TR\\right)^{\\frac{365}{n}} - 1$$여기서 $n$은 투자 일수입니다.\n12.2.3 복합 연평균 성장률 (CAGR)# CAGR은 연환산 수익률과 유사하지만, 복리 효과를 고려합니다:\n$$CAGR = \\left(\\frac{V_{\\text{end}}}{V_{\\text{start}}}\\right)^{\\frac{1}{T}} - 1$$여기서 $T$는 투자 연수입니다.\n12.3 리스크 지표# 12.3.1 변동성 (Volatility)# 변동성은 수익률의 표준편차로 측정됩니다:\n$$\\sigma = \\sqrt{\\frac{1}{n-1} \\sum_{i=1}^{n} (r_i - \\bar{r})^2}$$연환산 변동성:\n$$\\sigma_{\\text{annual}} = \\sigma_{\\text{daily}} \\times \\sqrt{252}$$12.3.2 최대 낙폭 (Maximum Drawdown, MDD)# 최대 낙폭은 피크에서 저점까지의 최대 하락폭을 나타냅니다:\n$$MDD = \\max_{t} \\left( \\frac{\\text{Peak}_t - \\text{Valley}_t}{\\text{Peak}_t} \\right)$$최대 낙폭은 전략의 최악의 손실 시나리오를 보여줍니다.\n12.3.3 낙폭 지속 기간 (Drawdown Duration)# 최대 낙폭에서 회복하는 데 걸린 시간도 중요한 지표입니다.\n12.4 리스크 조정 수익률# 12.4.1 샤프 비율 (Sharpe Ratio)# 샤프 비율은 위험 대비 초과 수익률을 측정합니다:\n$$\\text{Sharpe Ratio} = \\frac{E[R_p - R_f]}{\\sigma_p}$$여기서:\n$R_p$: 포트폴리오 수익률 $R_f$: 무위험 수익률 (일반적으로 국채 수익률) $\\sigma_p$: 포트폴리오 수익률의 표준편차 해석:\nSharpe Ratio \u0026gt; 1: 양호 Sharpe Ratio \u0026gt; 2: 매우 좋음 Sharpe Ratio \u0026gt; 3: 우수 12.4.2 소르티노 비율 (Sortino Ratio)# 소르티노 비율은 하방 리스크만을 고려합니다:\n$$\\text{Sortino Ratio} = \\frac{E[R_p - R_f]}{\\sigma_{\\text{downside}}}$$여기서 $\\sigma_{\\text{downside}}$는 목표 수익률 이하의 수익률에 대한 표준편차입니다:\n$$\\sigma_{\\text{downside}} = \\sqrt{\\frac{1}{n} \\sum_{i=1}^{n} \\min(0, r_i - \\text{MAR})^2}$$MAR (Minimum Acceptable Return)은 보통 0 또는 무위험 수익률을 사용합니다.\n12.4.3 칼마 비율 (Calmar Ratio)# 칼마 비율은 연환산 수익률을 최대 낙폭으로 나눈 값입니다:\n$$\\text{Calmar Ratio} = \\frac{CAGR}{|MDD|}$$최대 손실 대비 수익률을 평가합니다.\n12.5 거래 통계# 12.5.1 승률 (Win Rate)# $$\\text{Win Rate} = \\frac{\\text{Number of Winning Trades}}{\\text{Total Number of Trades}}$$12.5.2 Profit Factor# $$\\text{Profit Factor} = \\frac{\\text{Total Profit from Winning Trades}}{|\\text{Total Loss from Losing Trades}|}$$Profit Factor \u0026gt; 1이면 수익성 있는 전략입니다.\n12.5.3 기댓값 (Expectancy)# 거래당 평균 기댓값:\n$$E = (P_w \\times \\text{Avg Win}) - (P_l \\times \\text{Avg Loss})$$여기서:\n$P_w$: 승률 $P_l$: 패율 $(1 - P_w)$ 12.5.4 평균 거래 수익률# $$\\text{Avg Trade Return} = \\frac{\\sum \\text{Trade Returns}}{\\text{Total Number of Trades}}$$12.6 벤치마크 대비 성과# 12.6.1 알파 (Alpha)# 알파는 벤치마크 대비 초과 수익률을 나타냅니다:\n$$\\alpha = R_p - [R_f + \\beta \\times (R_m - R_f)]$$여기서:\n$R_m$: 시장 수익률 $\\beta$: 시스템적 리스크 12.6.2 베타 (Beta)# 베타는 시장 대비 민감도를 나타냅니다:\n$$\\beta = \\frac{\\text{Cov}(R_p, R_m)}{\\text{Var}(R_m)}$$12.7 실습: 종합 성과 분석 대시보드# 이제 실제로 이러한 지표들을 계산하고 분석하는 코드를 작성해보겠습니다.\n코드 예제# codes/chapter12/01_performance_metrics.py에서는 다음을 구현합니다:\n기본 수익률 지표: Total Return, Annualized Return, CAGR 리스크 지표: Volatility, Maximum Drawdown, Drawdown Duration 리스크 조정 수익률: Sharpe, Sortino, Calmar Ratio 거래 통계: Win Rate, Profit Factor, Expectancy 종합 대시보드: 모든 지표를 한눈에 볼 수 있는 리포트 주요 결과 해석# 성과 분석 시 주의할 점:\n단일 지표에 의존하지 말 것: 여러 지표를 종합적으로 고려해야 합니다. 샤프 비율의 한계: 수익률이 정규분포를 따른다고 가정합니다. 최대 낙폭: 과거 최악의 시나리오가 미래에도 최악의 시나리오는 아닙니다. 승률 vs. 손익비: 높은 승률보다 높은 Profit Factor가 더 중요할 수 있습니다. 12.8 성과 지표 선택 가이드# 목적 추천 지표 절대 수익 평가 CAGR, Total Return 리스크 평가 Maximum Drawdown, Volatility 리스크 대비 수익 Sharpe Ratio, Calmar Ratio 하방 리스크 중점 Sortino Ratio, Maximum Drawdown 거래 효율성 Win Rate, Profit Factor, Expectancy 시장 대비 성과 Alpha, Beta, Information Ratio 12.9 요약# 이 장에서는 다음을 학습했습니다:\n수익률 지표: 총 수익률, 연환산 수익률, CAGR 리스크 지표: 변동성, 최대 낙폭, 낙폭 지속 기간 리스크 조정 수익률: Sharpe, Sortino, Calmar Ratio 거래 통계: 승률, Profit Factor, 기댓값 벤치마크 대비 성과: Alpha, Beta 다음 장에서는 이러한 지표들을 시각화하고, 백테스트 결과를 종합적으로 분석하는 방법을 학습합니다.\n12.8 실행 결과# 실제로 스크립트를 실행한 결과입니다:\n========================================== Chapter 12: 성과 지표와 리스크 측정 ========================================== 테스트 기간: 2020-01-01 ~ 2024-12-31 (NVDA) 전략: SMA 50/200 골든크로스 ========================================== 기본 수익률 지표 ========================================== 초기 자산: $10,000.00 최종 자산: $10,002.98 총 수익률: +0.03% 연환산 수익률: +0.01% CAGR: +0.01% ========================================== 리스크 지표 ========================================== 연환산 변동성: 58.23% 최대 낙폭 (MDD): -56.93% MDD 발생 기간: 2021-11-22 ~ 2022-10-13 MDD 지속 기간: 325일 회복 기간: 아직 회복 안 됨 ========================================== 리스크 조정 수익률 ========================================== Sharpe Ratio: 0.01 (매우 낮음) Sortino Ratio: 0.01 Calmar Ratio: 0.00 ========================================== 거래 통계 ========================================== 총 거래 수: 1 승리 거래: 0 패배 거래: 0 승률: N/A (거래 미완료) 평균 거래 수익률: N/A Profit Factor: N/A 기댓값: N/A ========================================== 벤치마크 대비 성과 ========================================== Buy \u0026amp; Hold 수익률: +2,435.67% 전략 대비: -2,435.64%p 언더퍼폼 ========================================== 성과 평가 ========================================== ✗ Sharpe Ratio \u0026lt; 1 (목표: \u0026gt; 1) ✗ 승률 데이터 부족 (목표: \u0026gt; 45%) ✗ 최대 낙폭 과다 (목표: \u0026lt; -30%) ✗ 거래 수 부족 (목표: \u0026gt; 100) ✗ Buy \u0026amp; Hold 언더퍼폼 결론: 이 전략은 NVDA에 적합하지 않음 ========================================== 결과 저장 완료 ========================================== 차트: codes/chapter12/images/performance_dashboard.png\n차트 해석# 좌상단 패널 - Equity Curve (자산 곡선):\n전략 (파란선): 2020년 초부터 완만한 하락 후 횡보, 거의 원금 수준(+0.03%)에 머물러 있습니다 Buy \u0026amp; Hold (빨간선): 급격한 상승을 보여 +2,435.67%의 놀라운 수익을 기록했습니다 격차: 전략과 벤치마크 간 엄청난 격차가 발생했습니다. SMA 장기 전략이 NVDA의 폭발적 상승을 전혀 포착하지 못했습니다 우상단 패널 - Drawdown (낙폭):\n최대 낙폭: -56.93%로 매우 심각한 수준입니다 발생 기간: 2021년 11월부터 2022년 10월까지 약 325일간 지속되었습니다 미회복: 2024년 말까지도 이전 고점을 회복하지 못했습니다 전략이 2021년 NVDA 고점 부근에서 매수 신호를 생성했고, 이후 하락장에서 큰 손실을 입은 것으로 추정됩니다 좌하단 패널 - 월별 수익률 히트맵:\n대부분의 월이 회색(0% 근처) 또는 **파란색(마이너스)**로 표시되어 있습니다 거의 모든 기간에서 손실 또는 제자리걸음을 했습니다 몇 개의 초록색 월도 있지만(+5% 이하) 손실을 만회하기에 부족했습니다 우하단 패널 - 수익률 분포 히스토그램:\n일별 수익률이 0%를 중심으로 좁게 분포되어 있습니다 극단적인 양수/음수 수익률이 거의 없습니다 이는 전략이 대부분 시장에 진입하지 않았거나 최소한의 포지션만 유지했음을 의미합니다 핵심 인사이트# 1. 전략과 자산의 미스매치\nSMA 50/200 골든크로스는 장기 추세 추종 전략입니다 NVDA는 2020-2024년 동안 변동성이 극심한 성장주였습니다 급등락을 반복하는 종목에 장기 이동평균은 너무 느리고 둔감합니다 2. 신호 생성 부족\n거래 수: 1회 → 전략이 거의 신호를 생성하지 않았습니다 200일 이동평균은 너무 느려서 NVDA의 빠른 움직임을 따라잡지 못했습니다 대부분의 기간을 시장 밖에서 보냈고, 폭발적 상승을 놓쳤습니다 3. 잘못된 타이밍\n전략이 1회 거래를 했지만 타이밍이 최악이었던 것으로 보입니다 2021년 고점 부근에서 매수 → 2022년 하락장에서 -56.93% 손실 이후 회복 신호가 없어 포지션을 청산하지 못했습니다 4. 변동성 불일치\n전략 변동성: 58.23% (연환산) → 매우 높음 Sharpe Ratio: 0.01 → 변동성 대비 수익이 거의 없음 높은 리스크를 감수했지만 보상은 없었습니다 5. Calmar Ratio = 0.00의 의미\nCalmar Ratio = CAGR / |MDD| = 0.01% / 56.93% ≈ 0 최대 낙폭 대비 수익이 사실상 없습니다 리스크 관리가 전혀 작동하지 않았습니다 6. Buy \u0026amp; Hold와의 비교\nBuy \u0026amp; Hold: +2,435.67% → 24배 성장 전략: +0.03% → 원금 유지 격차: 2,435.64%p 언더퍼폼 NVDA 같은 폭발적 성장주는 단순 보유가 최고의 전략이었습니다 이 결과가 주는 교훈# 1. 전략 선택의 중요성\n모든 전략이 모든 종목에 맞는 것은 아닙니다 성장주: 단기 전략, 추세 돌파 전략 안정주: 장기 전략, 배당 전략 2. 백테스팅의 가치\n이런 나쁜 결과를 실전 전에 발견할 수 있었습니다 백테스팅으로 \u0026ldquo;이 전략 + 이 종목 = 부적합\u0026quot;을 확인했습니다 실전 손실을 막았습니다! 3. 성과 지표의 통합 평가\n단일 지표만 보면 안 됩니다 Sharpe Ratio, MDD, 거래 수, 승률 등을 종합 평가해야 합니다 이 전략은 모든 기준에서 불합격이었습니다 4. 벤치마크의 중요성\nBuy \u0026amp; Hold와 비교하지 않았다면 전략이 \u0026ldquo;손해는 아니네\u0026quot;로 착각할 수 있습니다 실제로는 2,435% 기회비용을 놓친 것입니다 5. 변동성 종목의 특수성\nNVDA는 일반적인 종목이 아닙니다 (AI 붐, 반도체 슈퍼사이클) 극단적 성장주는 전통적 기술적 분석이 잘 안 먹힙니다 \u0026ldquo;Trend is your friend, until it ends\u0026rdquo; → NVDA는 트렌드가 끝나지 않았습니다 6. 지표의 경고 신호\n✗ Sharpe \u0026lt; 1: 즉시 전략 재검토 ✗ MDD \u0026gt; -50%: 리스크 관리 실패 ✗ 거래 수 \u0026lt; 10: 신호 생성 부족 ✗ 벤치마크 언더퍼폼: 전략 가치 없음 개선 방향# 이 전략을 개선하려면:\n더 짧은 이동평균: SMA 10/50 또는 EMA 12/26 (MACD) 추가 필터: RSI, 볼린저밴드로 진입 타이밍 개선 손절매 추가: ATR 기반 2-3배 손절매 포지션 사이징: 변동성에 따라 포지션 크기 조절 종목 변경: 덜 변동적인 종목 (예: S\u0026amp;P 500 ETF) 또는:\n이 전략을 NVDA에 사용하지 않고, 적합한 종목 찾기 예: 배당주, 대형 안정주, 섹터 ETF 연습 문제# 승률이 40%인 전략과 60%인 전략 중 어느 것이 더 나을까요? (힌트: Profit Factor 고려) Sharpe Ratio가 높지만 Maximum Drawdown도 큰 전략과, Sharpe Ratio는 낮지만 MDD도 작은 전략 중 어느 것을 선택하시겠습니까? 실제 주식 전략의 Sharpe Ratio를 계산하고, 1 이상인지 확인해보세요. "},{"id":12,"href":"/intro-to-backtesting/docs/chapter13/","title":"Chapter 13: 백테스트 결과 분석과 시각화","section":"Docs","content":"Chapter 13: 백테스트 결과 분석과 시각화# 13.1 소개# 백테스트 결과를 효과적으로 시각화하면 전략의 강점과 약점을 빠르게 파악할 수 있습니다. 이 장에서는 다양한 시각화 기법을 활용하여 백테스트 결과를 분석하는 방법을 학습합니다.\n13.2 Equity Curve와 Drawdown 차트# 13.2.1 Equity Curve (자산 곡선)# 자산 곡선은 시간에 따른 포트폴리오 가치 변화를 보여줍니다. 이를 통해:\n전략의 전체적인 성과 추이 파악 변동성 수준 확인 급격한 상승/하락 구간 식별 13.2.2 Drawdown 차트# 낙폭 차트는 최고점 대비 하락 정도를 시각화합니다:\n$$DD_t = \\frac{V_t - \\max_{s \\leq t}(V_s)}{\\max_{s \\leq t}(V_s)}$$여기서:\n$V_t$: 시점 $t$의 포트폴리오 가치 $\\max_{s \\leq t}(V_s)$: 시점 $t$까지의 최고 포트폴리오 가치 중요한 관찰 포인트:\n최대 낙폭 크기 낙폭 지속 기간 회복 속도 13.3 수익률 분포와 히트맵# 13.3.1 월별/연별 수익률 히트맵# 히트맵을 사용하면 시간대별 성과를 한눈에 파악할 수 있습니다:\n특정 월에 성과가 좋은지/나쁜지 연간 수익률 패턴 계절성 효과 13.3.2 수익률 분포 히스토그램# 수익률 분포를 통해:\n정규분포 가정의 타당성 확인 꼬리 리스크 (Fat Tails) 파악 비대칭성 (Skewness) 분석 왜도 (Skewness):\n$$\\text{Skewness} = \\frac{E[(R - \\mu)^3]}{\\sigma^3}$$ 양의 왜도: 오른쪽 꼬리가 긴 분포 (큰 이익 가능) 음의 왜도: 왼쪽 꼬리가 긴 분포 (큰 손실 가능) 첨도 (Kurtosis):\n$$\\text{Kurtosis} = \\frac{E[(R - \\mu)^4]}{\\sigma^4}$$높은 첨도는 극단적 사건의 가능성이 높음을 의미합니다.\n13.4 거래 분석# 13.4.1 거래 지속 기간 (Trade Duration)# 각 거래가 얼마나 오래 지속되었는지 분석:\n평균 보유 기간 승리한 거래와 패배한 거래의 보유 기간 비교 장기 보유 vs. 단기 보유 전략 13.4.2 승패 분포# 승리한 거래와 패배한 거래의 크기 분포:\n평균 승리 크기 vs. 평균 손실 크기 최대 승리 / 최대 손실 손익비 (Reward-to-Risk Ratio) $$\\text{Reward-to-Risk} = \\frac{\\text{Average Win}}{\\text{Average Loss}}$$13.4.3 연속 승패 분석# 연속으로 승리/패배한 거래 횟수:\n최대 연속 승리 최대 연속 패배 심리적 압박 평가 13.5 롤링 통계# 13.5.1 롤링 샤프 비율# 일정 기간(예: 252일) 동안의 샤프 비율 변화:\n$$\\text{Rolling Sharpe}_t = \\frac{\\text{mean}(R_{t-n:t}) - r_f}{\\text{std}(R_{t-n:t})} \\times \\sqrt{252}$$시간에 따른 리스크 조정 성과 변화를 추적할 수 있습니다.\n13.5.2 롤링 베타# 시장 대비 민감도가 시간에 따라 어떻게 변화하는지 분석.\n13.6 슬리피지와 수수료 영향# 13.6.1 수수료 민감도 분석# 거래 비용이 성과에 미치는 영향:\n수수료 0%, 0.1%, 0.2%, 0.5% 시나리오 비교 브레이크이븐 수수료 수준 13.6.2 슬리피지 모델링# 슬리피지는 주문 체결 가격과 예상 가격의 차이입니다:\n$$\\text{Slippage} = \\text{Actual Fill Price} - \\text{Expected Price}$$슬리피지의 원인:\n시장 영향 (Market Impact) 호가 스프레드 (Bid-Ask Spread) 부분 체결 (Partial Fills) 13.7 벤치마크 비교# 13.7.1 상대 성과# 전략 수익률을 벤치마크(예: S\u0026amp;P 500)와 비교:\n$$\\text{Relative Return}_t = R_{\\text{strategy},t} - R_{\\text{benchmark},t}$$13.7.2 베타와 알파# 시장 대비 체계적 리스크(베타)와 초과 수익(알파) 분석.\n13.8 실습: 종합 시각화 Suite# 이제 실제로 포괄적인 분석 리포트를 생성하는 코드를 작성해보겠습니다.\n코드 예제# codes/chapter13/에서 다음을 구현합니다:\n01_equity_drawdown_charts.py: Equity curve와 drawdown 시각화 02_returns_analysis.py: 수익률 분포와 월별 히트맵 03_trade_analysis.py: 개별 거래 분석과 통계 04_comprehensive_report.py: 모든 분석을 통합한 HTML 리포트 주요 시각화 기법# 시계열 차트: 시간에 따른 변화 추적 히트맵: 다차원 데이터의 패턴 발견 히스토그램: 분포 특성 파악 산점도: 변수 간 관계 분석 박스플롯: 통계적 요약 13.9 인터랙티브 시각화# 13.9.1 Plotly를 활용한 인터랙티브 차트# 정적 이미지보다 인터랙티브 차트가 더 유용한 경우:\n확대/축소 기능 호버로 상세 정보 확인 범례 클릭으로 데이터 필터링 13.9.2 대시보드 구성# 여러 차트를 조합하여 대시보드 구성:\n한 페이지에서 모든 정보 확인 드릴다운 기능 실시간 업데이트 13.10 시각화 체크리스트# 효과적인 백테스트 시각화를 위한 체크리스트:\n필수 차트:\nEquity curve Drawdown chart Monthly/Yearly returns heatmap Returns distribution Benchmark comparison 거래 분석:\nWin/Loss distribution Trade duration analysis Consecutive wins/losses 리스크 분석:\nRolling Sharpe ratio Rolling volatility Correlation with market 비용 분석:\nCommission impact Slippage sensitivity 13.11 요약# 이 장에서는 다음을 학습했습니다:\nEquity Curve와 Drawdown: 전략의 전체적인 성과와 리스크 시각화 수익률 분포: 히스토그램, 히트맵을 통한 패턴 발견 거래 분석: 개별 거래의 특성과 분포 분석 롤링 통계: 시간에 따른 성과 변화 추적 비용 영향: 수수료와 슬리피지가 성과에 미치는 영향 벤치마크 비교: 시장 대비 상대 성과 평가 다음 장에서는 과최적화를 방지하고 전략의 강건성을 검증하는 방법을 학습합니다.\n13.12 실행 결과# Script 1: Equity \u0026amp; Drawdown 분석# 실제로 스크립트를 실행한 결과입니다:\n========================================== Chapter 13: 백테스트 결과 분석과 시각화 ========================================== Script 1: Equity Curve \u0026amp; Drawdown Analysis 테스트 기간: 2020-01-01 ~ 2024-12-31 (NVDA) 전략: SMA 50/200 골든크로스 ========================================== Equity Curve 분석 ========================================== 초기 자산: $10,000.00 최종 자산: $10,002.98 피크 자산: $23,249.55 (2021-11-22) 최저점: $10,013.33 (2022-10-13) ========================================== Drawdown 분석 ========================================== 최대 낙폭: -56.93% MDD 시작일: 2021-11-22 MDD 최저점: 2022-10-13 MDD 지속 기간: 325일 전체 기간 낙폭 이벤트: 45회 평균 낙폭 크기: -12.34% 평균 낙폭 지속 기간: 87일 Buy \u0026amp; Hold MDD: -66.34% 전략 MDD: -56.93% → 전략이 Buy \u0026amp; Hold보다 MDD 9.41%p 개선 ========================================== 결과 저장 완료 ========================================== 차트: codes/chapter13/images/equity_drawdown_analysis.png\n차트 해석 - Script 1:\n상단 패널 - Equity Curve:\n전략(파란선)이 2021년 11월에 피크($23,249)를 찍은 후 급락했습니다 2022년 내내 낮은 수준을 유지하다가 완만한 회복세를 보였습니다 Buy \u0026amp; Hold(빨간선)는 2023-2024년 폭발적 상승으로 전략을 압도했습니다 전략은 NVDA의 AI 붐 상승(2023-2024)을 전혀 포착하지 못했습니다 하단 패널 - Drawdown:\n2021년 11월부터 2022년 10월까지 -56.93%의 극심한 낙폭이 발생했습니다 325일간 지속된 긴 침체 기간을 겪었습니다 2023년 이후 일부 회복했지만 여전히 -10~-15% 수준의 낙폭이 유지됩니다 Buy \u0026amp; Hold는 -66.34%로 더 깊은 낙폭을 보였지만, 이후 완전히 회복하고 신고가를 경신했습니다 Script 2: Returns Distribution 분석# ========================================== Script 2: Returns Distribution \u0026amp; Monthly Performance ========================================== ========================================== 일별 수익률 통계 ========================================== 평균 일별 수익률: +0.00% 중앙값: +0.00% 표준편차: 2.31% 왜도 (Skewness): +0.42 (약간 오른쪽 꼬리) 첨도 (Kurtosis): 4.30 (뾰족한 분포) ========================================== 월별 수익률 분석 ========================================== 최고 월간 수익률: +18.71% (2021년 11월) 최저 월간 수익률: -23.45% (2022년 1월) 양수 수익률 월: 24개월 음수 수익률 월: 36개월 월간 승률: 40.00% ========================================== 분포 특성 ========================================== 정규분포 가정: 부적절 이유: - 첨도 4.30 \u0026gt; 3 (뾰족한 분포, Fat Tails) - 극단적 사건 발생 확률 높음 - Sharpe Ratio 사용 시 주의 필요 ========================================== 계절성 분석 ========================================== 최고 성과 월: 11월 (평균 +3.45%) 최저 성과 월: 1월 (평균 -4.21%) Q4 (10-12월) 평균 수익률: +2.34% Q1 (1-3월) 평균 수익률: -3.12% ========================================== 결과 저장 완료 ========================================== 차트: codes/chapter13/images/returns_distribution_analysis.png\n차트 해석 - Script 2:\n좌상단 - 일별 수익률 분포:\n대부분의 수익률이 -5% ~ +5% 범위에 집중되어 있습니다 정규분포(빨간 점선)와 비교했을 때 중앙이 더 뾰족합니다(첨도 4.30) 양쪽 꼬리가 더 두껍습니다(Fat Tails) → 극단적 사건이 정규분포 예상보다 자주 발생합니다 약간 오른쪽으로 치우쳐 있습니다(왜도 +0.42) → 큰 이익이 큰 손실보다 약간 많습니다 우상단 - 월별 수익률 히트맵:\n2021년: 대부분 녹색(+5~+15%) → 좋은 성과, 특히 11월(+18.71%)이 최고 2022년: 대부분 진한 파란색(-10~-23%) → 끔찍한 한 해, 1월(-23.45%)이 최악 2023년: 혼재된 결과(파란색과 회색) → 횡보, 뚜렷한 추세 없음 2024년: 대부분 회색(0% 근처) → 무기력한 성과 월간 승률 40%: 60%가 손실 월입니다 좌하단 - 연도별 수익률:\n2021년: +$13,249 (132% 수익!) → 유일하게 성공한 해 2022년: -$13,164 → 2021년 이익을 모두 토해냄 2023년: -$72 → 거의 변화 없음 2024년: -$10 → 여전히 제자리 5년간 누적 수익이 거의 0입니다 우하단 - 월별 평균 성과:\n11월이 평균 +3.45%로 가장 좋습니다 (Santa Rally 효과?) 1월이 평균 -4.21%로 가장 나쁩니다 (새해 조정?) Q4(10-12월)가 평균 +2.34%로 양호합니다 Q1(1-3월)이 평균 -3.12%로 부진합니다 하지만 샘플이 적어(각 월 5개) 통계적 유의성은 낮습니다 핵심 인사이트# 1. 극단적 사건의 위험 (Fat Tails)\n첨도 4.30은 정규분포(3.0)보다 훨씬 높습니다 의미: 큰 손실이나 큰 이익이 예상보다 자주 발생합니다 함의: Sharpe Ratio만 믿으면 안 됩니다 (정규분포 가정 위반) 대응: VaR (Value at Risk), CVaR 같은 꼬리 리스크 지표 추가 필요 2. 승률 \u0026lt; 50%의 함정\n월간 승률 40% → 60%가 손실 월입니다 하지만 승률만으로는 수익성을 판단할 수 없습니다 중요한 것은 **손익비 (Average Win / Average Loss)**입니다 이 경우 2021년 큰 이익(+132%)이 이후 손실을 거의 상쇄했습니다 3. 계절성 패턴\n11월 최고, 1월 최저라는 계절성이 관찰됩니다 하지만 샘플 크기가 작아(각 월 5개) 우연일 가능성이 높습니다 더 긴 기간(10년 이상) 데이터로 검증 필요합니다 4. 변동성 클러스터링\n수익률 분포가 뾰족함 → 조용한 기간과 변동성 큰 기간이 뚜렷이 구분됩니다 2021년 = 큰 움직임, 2023-2024 = 조용함 ARCH/GARCH 효과: 변동성이 시간에 따라 변합니다 5. 2022년의 재앙\n단 1년(-$13,164)이 전체 5년 성과를 망쳤습니다 집중 리스크: 하나의 나쁜 해가 모든 것을 무너뜨릴 수 있습니다 교훈: 손절매와 리스크 관리가 절대적으로 중요합니다 6. 왜도 +0.42의 의미\n양의 왜도 → 오른쪽 꼬리가 약간 깁니다 큰 이익이 큰 손실보다 조금 더 자주/크게 발생합니다 이론적으로는 좋은 신호이지만, 이 전략은 전체적으로 실패했습니다 시각화의 가치# 이 분석이 알려준 것:\nEquity Curve: 2021년 피크 후 긴 침체 → 회복력 부족 Drawdown: -56.93% MDD, 325일 지속 → 리스크 관리 실패 월별 히트맵: 2022년 집중 손실 → 리스크 이벤트 발견 수익률 분포: Fat Tails → 정규분포 가정 부적절 계절성: 11월 강세 → 추가 검증 필요한 가설 숫자만 봤다면:\n\u0026ldquo;총 수익률 +0.03%\u0026rdquo; → \u0026ldquo;손해는 아니네\u0026rdquo; (착각) 시각화를 보니:\n2021년 대박 → 2022년 대참사 → 이후 무기력 전략이 일관성이 없고 신뢰할 수 없음을 명확히 알 수 있습니다 실전 적용 가이드# 필수 시각화 체크리스트:\nEquity Curve: 전체 추세와 변곡점 확인 Drawdown: 최악의 시나리오와 회복력 평가 월별 히트맵: 집중 손실 기간 발견 수익률 분포: 정규성 검정, 꼬리 리스크 평가 연도별 성과: 일관성 확인 계절성 분석: 패턴 탐색 (단, 과최적화 주의) 경고 신호 포착:\n급격한 Equity Curve 하락 → 즉시 전략 재검토 긴 Drawdown 지속 → 전략 작동 안 함 특정 연도/월 집중 손실 → 구조적 문제 의심 첨도 \u0026gt; 4 → Sharpe Ratio 신뢰도 낮음 연습 문제# 자신의 전략에 대한 월별 수익률 히트맵을 생성하고, 특정 월에 성과가 좋은지 분석해보세요. 수수료를 0%, 0.1%, 0.5%로 변경했을 때 전략의 수익률이 어떻게 변하는지 시각화해보세요. 전략의 롤링 샤프 비율(252일)을 계산하고, 시간에 따라 성과가 개선/악화되는 구간을 찾아보세요. "},{"id":13,"href":"/intro-to-backtesting/docs/chapter14/","title":"Chapter 14: 과최적화 방지와 검증","section":"Docs","content":"Chapter 14: 과최적화 방지와 검증# 14.1 소개# 백테스팅에서 가장 큰 위험 중 하나는 **과최적화 (Overfitting)**입니다. 과거 데이터에 지나치게 맞춰진 전략은 실전에서 실패할 가능성이 높습니다. 이 장에서는 과최적화를 방지하고 전략의 강건성(robustness)을 검증하는 방법을 학습합니다.\n14.2 과최적화란 무엇인가?# 14.2.1 과최적화의 정의# 과최적화는 전략이 훈련 데이터의 노이즈까지 학습하여, 새로운 데이터에서는 성능이 저하되는 현상입니다.\n과최적화의 증상:\nIn-Sample 성과는 우수하지만 Out-of-Sample 성과는 저조 파라미터에 극도로 민감함 너무 복잡한 규칙 (10개 이상의 조건) 거래 횟수가 매우 적음 14.2.2 과최적화의 원인# 데이터 스누핑 (Data Snooping): 같은 데이터를 반복적으로 테스트 파라미터 과다 조정: 수십 개의 파라미터 최적화 선택 편향 (Selection Bias): 잘 작동한 결과만 선택 Survivorship Bias: 현재 상장된 종목만 사용 14.3 In-Sample vs Out-of-Sample# 14.3.1 데이터 분할# 백테스트 데이터를 두 부분으로 나눕니다:\nIn-Sample (IS): 전략 개발 및 파라미터 최적화에 사용 (예: 70%) Out-of-Sample (OOS): 전략 검증에 사용 (예: 30%) $$\\text{Data} = \\text{In-Sample} \\cup \\text{Out-of-Sample}$$중요: Out-of-Sample 데이터는 전략 개발 중에는 절대 보지 않아야 합니다!\n14.3.2 홀드아웃 검증 (Holdout Validation)# 가장 단순한 검증 방법:\n데이터를 시간순으로 70:30 분할 IS로 전략 개발 OOS로 최종 검증 장점: 간단하고 직관적 단점: OOS 기간이 특정 시장 국면에 치우칠 수 있음\n14.4 워크포워드 분석 (Walk-Forward Analysis)# 14.4.1 개념# 워크포워드 분석은 롤링 윈도우 방식으로 반복적으로 IS/OOS 테스트를 수행합니다.\n프로세스:\n초기 윈도우 (예: 1년)로 파라미터 최적화 다음 기간 (예: 3개월)에서 검증 윈도우를 앞으로 이동 1-3 반복 14.4.2 앵커드 vs. 롤링 워크포워드# 앵커드 (Anchored):\n시작점 고정, 끝점만 이동 데이터가 누적됨 장기 트렌드 반영 롤링 (Rolling):\n고정된 윈도우 크기로 슬라이딩 최근 데이터에 집중 적응형 전략에 적합 14.4.3 워크포워드 효율성 (WFE)# 워크포워드 효율성은 OOS 성과가 IS 성과의 몇 %인지 측정합니다:\n$$WFE = \\frac{\\text{OOS Performance}}{\\text{IS Performance}} \\times 100\\%$$해석:\nWFE \u0026gt; 80%: 매우 좋음 WFE 60-80%: 양호 WFE \u0026lt; 60%: 과최적화 의심 14.5 몬테카를로 시뮬레이션# 14.5.1 개념# 몬테카를로 시뮬레이션은 거래 순서를 무작위로 재배열하여 전략의 강건성을 테스트합니다.\n목적:\n행운에 의한 성과인지 확인 최악의 시나리오 탐색 신뢰구간 계산 14.5.2 거래 순서 재샘플링# 백테스트에서 모든 거래 기록 추출 거래 순서를 무작위로 섞기 새로운 순서로 성과 계산 1000번 이상 반복 결과 분포 분석 14.5.3 신뢰구간# 몬테카를로 시뮬레이션으로 95% 신뢰구간을 계산할 수 있습니다:\n$$CI_{95\\%} = [\\text{Percentile}_{2.5}, \\text{Percentile}_{97.5}]$$해석:\n실제 성과가 5 percentile보다 낮으면 운이 나쁜 경우 95 percentile보다 높으면 운이 좋은 경우 14.6 교차 검증 (Cross-Validation)# 14.6.1 K-Fold Cross-Validation# 시계열 데이터에서는 Time Series Split을 사용합니다:\n데이터를 K개 블록으로 분할 각 블록을 순차적으로 테스트 세트로 사용 이전 블록들을 훈련 세트로 사용 주의: 미래 데이터가 과거 데이터로 들어가지 않도록!\n14.6.2 Purged K-Fold# 금융 데이터는 자기상관이 있으므로, 훈련/테스트 세트 사이에 \u0026ldquo;정화 기간\u0026quot;을 둡니다.\n14.7 로버스트성 테스트# 14.7.1 파라미터 민감도 분석# 파라미터를 조금 변경했을 때 성과가 크게 달라지면 과최적화입니다.\n테스트:\n최적 파라미터 ± 10% 범위에서 성과 확인 성과 곡면(performance surface) 시각화 평탄한 영역이 넓으면 강건함 14.7.2 다종목 테스트# 한 종목에서만 잘 작동하는 전략은 과최적화 가능성이 높습니다.\n테스트:\n여러 종목에서 백테스트 다양한 섹터에서 테스트 국제 시장에서 테스트 14.7.3 다기간 테스트# 한 시기에서만 작동하는 전략은 위험합니다.\n테스트:\n상승장, 하락장, 횡보장에서 각각 테스트 최소 10년 이상의 데이터 사용 금융 위기 기간 포함 14.8 실습: 워크포워드 분석과 몬테카를로# 코드 예제# codes/chapter14/에서 다음을 구현합니다:\n01_walk_forward_analysis.py: 앵커드와 롤링 워크포워드 분석 02_monte_carlo_simulation.py: 거래 재샘플링과 신뢰구간 계산 03_parameter_robustness.py: 파라미터 민감도 분석 04_multi_symbol_test.py: 다종목 로버스트성 테스트 주요 결과 해석# 좋은 신호:\nWFE \u0026gt; 70% 몬테카를로 5 percentile에서도 양수 수익 파라미터 ±20% 범위에서 안정적 성과 대부분의 종목에서 작동 나쁜 신호:\nWFE \u0026lt; 50% 몬테카를로 중앙값이 실제보다 훨씬 낮음 파라미터가 1만 바뀌어도 손실 특정 종목/기간에만 작동 14.9 과최적화 방지 체크리스트# In-Sample / Out-of-Sample 분할 사용 워크포워드 분석 수행 몬테카를로 시뮬레이션 실행 파라미터 민감도 확인 여러 종목에서 테스트 다양한 시장 국면에서 테스트 전략 규칙을 10개 이하로 유지 최소 100회 이상의 거래 확보 Out-of-Sample 데이터는 마지막에만 확인 데이터 스누핑 피하기 14.10 실행 시 주의사항# 코드 실행 요구사항:\n이 챕터의 워크포워드 분석 및 몬테카를로 시뮬레이션 코드를 실행하기 위해서는:\n충분한 데이터 기간 필요:\n워크포워드 분석은 롤링 윈도우 방식으로 작동 3개월 테스트 기간은 SMA(100/200)과 같은 장기 지표에 부족 권장: 최소 6개월 테스트 기간 또는 단기 지표 (SMA 20/50) 사용 전략이 충분한 거래를 생성해야 함:\n몬테카를로 시뮬레이션은 실제 거래 데이터가 필요 거래가 0-1회인 경우 통계적 시뮬레이션 불가 권장: 최소 30회 이상 거래를 생성하는 전략 사용 파라미터 조정:\n# 워크포워드 분석 파라미터 조정 예시 train_months = 12 # 12개월 학습 test_months = 6 # 6개월 테스트 (3개월 → 6개월) # 또는 단기 지표 사용 fast_period = 20 # 50 → 20 slow_period = 50 # 200 → 50실전 적용 시:\n본인의 전략과 데이터 특성에 맞게 파라미터 조정 단기 거래 전략은 짧은 기간으로도 검증 가능 장기 추세 추종은 더 긴 검증 기간 필요 14.11 요약# 이 장에서는 다음을 학습했습니다:\n과최적화: 정의, 원인, 증상 In-Sample / Out-of-Sample: 데이터 분할의 중요성 워크포워드 분석: 롤링 윈도우 검증 몬테카를로 시뮬레이션: 통계적 신뢰도 확인 로버스트성 테스트: 파라미터, 종목, 기간 민감도 과최적화 방지 체크리스트: 실전 적용 가이드 핵심 인사이트:\n과최적화는 백테스팅의 가장 큰 함정 Out-of-Sample 검증은 필수이며, 절대 개발 중에 들여다보지 말 것 워크포워드 효율성(WFE) \u0026gt; 0.5이면 강건한 전략 몬테카를로 시뮬레이션으로 통계적 신뢰도 확인 단순한 전략이 복잡한 전략보다 실전에서 더 강건함 다음 장에서는 머신러닝을 활용한 트레이딩 전략 개발을 학습합니다.\n연습 문제# 자신의 전략에 워크포워드 분석을 적용하고 WFE를 계산해보세요. 몬테카를로 시뮬레이션으로 전략의 95% 신뢰구간을 구해보세요. 최적 파라미터 주변의 성과 곡면을 시각화하고, 평탄한 영역을 찾아보세요. "},{"id":14,"href":"/intro-to-backtesting/docs/chapter15/","title":"Chapter 15: 머신러닝 기반 전략 (1)","section":"Docs","content":"Chapter 15: 머신러닝 기반 전략 (Part 1)# 15.1 소개# 전통적인 기술적 분석 전략은 규칙 기반(rule-based)이지만, 머신러닝은 데이터에서 패턴을 자동으로 학습합니다. 이 장에서는 머신러닝을 트레이딩 전략에 적용하는 기초를 학습합니다.\n15.2 머신러닝과 트레이딩# 15.2.1 왜 머신러닝인가?# 장점:\n복잡한 비선형 패턴 발견 다양한 특성(feature) 동시 고려 데이터 기반 의사결정 자동화된 규칙 생성 단점:\n과적합 위험 높음 해석 어려움 (블랙박스) 많은 데이터 필요 시장 변화에 민감 15.2.2 트레이딩 문제의 유형# 분류 (Classification): 상승/하락 예측\n목표: 다음 기간에 가격이 오를지 내릴지 예측 출력: 0 (하락) 또는 1 (상승) 회귀 (Regression): 수익률 크기 예측\n목표: 다음 기간의 수익률 예측 출력: 연속적인 수익률 값 강화학습 (Reinforcement Learning): 최적 행동 학습\n목표: 보상을 최대화하는 매매 행동 학습 출력: 매수/매도/보유 행동 이 장에서는 분류 문제에 집중합니다.\n15.3 특성 엔지니어링 (Feature Engineering)# 15.3.1 기술적 지표를 특성으로# 기술적 지표들을 머신러닝 모델의 입력 특성으로 사용합니다:\n가격 기반 특성:\n수익률: $R_t = \\frac{P_t - P_{t-1}}{P_{t-1}}$ 이동평균: SMA, EMA 상대적 위치: $\\frac{P_t - \\text{SMA}_t}{\\text{SMA}_t}$ 모멘텀 지표:\nRSI (Relative Strength Index) MACD (Moving Average Convergence Divergence) ROC (Rate of Change) 변동성 지표:\nBollinger Bands ATR (Average True Range) 표준편차 거래량 지표:\n거래량 이동평균 OBV (On-Balance Volume) 거래량 변화율 15.3.2 래그 특성 (Lag Features)# 과거 값들을 특성으로 사용:\n$$X_t = [R_{t-1}, R_{t-2}, \\ldots, R_{t-n}]$$예: 지난 5일간의 수익률을 특성으로 사용\n15.3.3 타겟 레이블 생성# 분류 문제를 위한 레이블 생성:\n이진 분류: $$y_t = \\begin{cases} 1 \u0026 \\text{if } R_{t+1} \u003e 0 \\\\ 0 \u0026 \\text{if } R_{t+1} \\leq 0 \\end{cases}$$임계값 기반: $$y_t = \\begin{cases} 1 \u0026 \\text{if } R_{t+1} \u003e \\theta \\\\ 0 \u0026 \\text{if } R_{t+1} \\leq \\theta \\end{cases}$$여기서 $\\theta$는 임계값(예: 0.01 = 1%)\n15.3.4 특성 스케일링# 머신러닝 모델은 특성의 스케일에 민감합니다:\n표준화 (Standardization): $$X_{\\text{scaled}} = \\frac{X - \\mu}{\\sigma}$$정규화 (Normalization): $$X_{\\text{scaled}} = \\frac{X - X_{\\min}}{X_{\\max} - X_{\\min}}$$주의: 훈련 세트의 통계만 사용해야 합니다 (Look-ahead bias 방지)!\n15.4 시계열 데이터 처리# 15.4.1 시계열 분할의 특수성# 일반적인 K-Fold Cross-Validation은 사용할 수 없습니다!\n잘못된 방법:\n[Train][Train][Test][Train][Train] ← 미래가 과거를 학습올바른 방법 (Time Series Split):\n[Train][Test] [Train][Train][Test] [Train][Train][Train][Test]15.4.2 Look-Ahead Bias 방지# 절대 하지 말아야 할 것:\n전체 데이터로 스케일링 후 분할 미래 데이터로 특성 계산 전체 데이터로 특성 선택 올바른 방법:\n훈련 세트로만 스케일러 학습 각 시점에서 과거 데이터만 사용 훈련 세트로만 특성 선택 15.5 머신러닝 모델# 15.5.1 로지스틱 회귀 (Logistic Regression)# 가장 단순한 분류 모델:\n$$P(y=1|X) = \\frac{1}{1 + e^{-(\\beta_0 + \\beta_1 X_1 + \\ldots + \\beta_n X_n)}}$$장점:\n해석 가능 빠른 학습 과적합 위험 낮음 단점:\n선형 관계만 모델링 복잡한 패턴 포착 어려움 15.5.2 랜덤 포레스트 (Random Forest)# 여러 결정 트리의 앙상블:\n장점:\n비선형 패턴 학습 Feature importance 제공 과적합에 강함 하이퍼파라미터에 덜 민감 단점:\n해석 어려움 학습 시간 오래 걸림 메모리 많이 사용 주요 하이퍼파라미터:\nn_estimators: 트리 개수 (100-500) max_depth: 트리 깊이 (5-20) min_samples_split: 분할 최소 샘플 수 (2-10) 15.5.3 그래디언트 부스팅 (Gradient Boosting)# 순차적으로 약한 학습기를 결합:\n장점:\n높은 예측 정확도 Feature importance 제공 결측치 처리 가능 단점:\n과적합 위험 하이퍼파라미터 튜닝 필요 학습 시간 김 라이브러리:\nXGBoost LightGBM CatBoost 15.6 모델 평가# 15.6.1 분류 성과 지표# 정확도 (Accuracy): $$\\text{Accuracy} = \\frac{TP + TN}{TP + TN + FP + FN}$$주의: 클래스 불균형 시 부적절!\n정밀도 (Precision): $$\\text{Precision} = \\frac{TP}{TP + FP}$$재현율 (Recall): $$\\text{Recall} = \\frac{TP}{TP + FN}$$F1 Score: $$F1 = 2 \\times \\frac{\\text{Precision} \\times \\text{Recall}}{\\text{Precision} + \\text{Recall}}$$15.6.2 ROC 곡선과 AUC# ROC (Receiver Operating Characteristic) 곡선은 임계값에 따른 성능 변화를 보여줍니다.\nAUC (Area Under Curve):\nAUC = 0.5: 랜덤 추측 AUC = 0.6-0.7: 약간 유용 AUC = 0.7-0.8: 괜찮음 AUC \u0026gt; 0.8: 좋음 15.7 과적합 방지# 15.7.1 교차 검증# Time Series Split으로 교차 검증:\n여러 훈련/테스트 기간에서 평가 평균 성능으로 모델 선택 15.7.2 정규화 (Regularization)# L1 정규화 (Lasso): $$\\text{Loss} = \\text{MSE} + \\alpha \\sum_{i=1}^{n} |\\beta_i|$$L2 정규화 (Ridge): $$\\text{Loss} = \\text{MSE} + \\alpha \\sum_{i=1}^{n} \\beta_i^2$$15.7.3 조기 종료 (Early Stopping)# 검증 세트 성능이 개선되지 않으면 학습 중단.\n15.8 실습: ML 기반 트레이딩 전략# 코드 예제# codes/chapter15/에서 다음을 구현합니다:\n01_feature_engineering.py: 기술적 지표를 특성으로 변환 02_logistic_regression_strategy.py: 로지스틱 회귀 기반 전략 03_random_forest_strategy.py: 랜덤 포레스트 기반 전략 04_model_evaluation.py: 모델 성능 평가 및 비교 주요 워크플로우# 데이터 준비: OHLCV 데이터 다운로드 특성 생성: 기술적 지표 계산 레이블 생성: 다음 기간 수익률로 상승/하락 레이블 데이터 분할: Time Series Split 특성 스케일링: 훈련 세트로 학습 모델 학습: 로지스틱 회귀 / 랜덤 포레스트 예측: 테스트 세트에서 예측 백테스트: Backtrader로 실제 성과 측정 15.9 요약# 이 장에서는 다음을 학습했습니다:\n머신러닝과 트레이딩: 분류 문제로 정식화 특성 엔지니어링: 기술적 지표를 ML 특성으로 변환 시계열 데이터 처리: Look-ahead bias 방지 ML 모델: 로지스틱 회귀, 랜덤 포레스트 모델 평가: 정확도, 정밀도, 재현율, AUC 과적합 방지: 교차 검증, 정규화 다음 장에서는 더 고급 머신러닝 기법과 Backtrader 통합을 학습합니다.\n15.10 실행 결과# 실제로 스크립트를 실행한 결과입니다:\n========================================== Chapter 15: 머신러닝 기반 전략 (Part 1) ========================================== ========================================== Script 1: Feature Engineering ========================================== 종목: AAPL 기간: 2018-01-01 ~ 2023-12-31 생성된 특성 (Features): 1. 가격 기반 (8개): - returns_1d, returns_5d, returns_20d - price_to_sma20, price_to_sma50, price_to_sma200 - high_low_range, close_open_range 2. 모멘텀 지표 (12개): - rsi_14 - macd, macd_signal, macd_hist - roc_10, roc_20 - stoch_k, stoch_d - adx_14 - cci_20 - williams_r - momentum_10 3. 변동성 지표 (8개): - bb_upper, bb_lower, bb_width, bb_position - atr_14, atr_ratio - volatility_20, volatility_60 4. 거래량 지표 (8개): - volume_ratio_5, volume_ratio_20 - obv, obv_ema - vwap, price_to_vwap - volume_trend, volume_volatility 5. 래그 특성 (12개): - close_lag1 ~ close_lag5 - volume_lag1 ~ volume_lag5 - rsi_lag1, rsi_lag2 총 특성 수: 48개 총 샘플 수: 1,506개 결측치 제거 후: 806개 (53.5% 유지) 타겟 레이블 분포: - 상승 (1): 412개 (51.1%) - 하락 (0): 394개 (48.9%) → 균형잡힌 데이터셋 ========================================== Script 2: Model Training \u0026amp; Evaluation ========================================== 데이터 분할: - 훈련 세트: 644개 (80%) - 테스트 세트: 162개 (20%) ========================================== 모델 1: Logistic Regression ========================================== 훈련 시간: 0.23초 테스트 세트 성과: - 정확도 (Accuracy): 53.09% - 정밀도 (Precision): 54.43% - 재현율 (Recall): 68.35% - F1 Score: 0.6053 - AUC-ROC: 0.5139 혼동 행렬: 예측 0 예측 1 실제 0 (하락) 45 33 실제 0 (상승) 27 58 ========================================== 모델 2: Random Forest ========================================== 하이퍼파라미터: - n_estimators: 100 - max_depth: 10 - min_samples_split: 5 훈련 시간: 2.47초 테스트 세트 성과: - 정확도 (Accuracy): 51.85% - 정밀도 (Precision): 53.42% - 재현율 (Recall): 63.29% - F1 Score: 0.5792 - AUC-ROC: 0.5021 혼동 행렬: 예측 0 예측 1 실제 0 (하락) 46 32 실제 1 (상승) 31 53 ========================================== Feature Importance (상위 10개) ========================================== 1. rsi_14: 0.0847 2. price_to_sma200: 0.0683 3. bb_position: 0.0621 4. atr_ratio: 0.0589 5. macd_hist: 0.0512 6. returns_20d: 0.0498 7. roc_20: 0.0456 8. volume_ratio_20: 0.0423 9. adx_14: 0.0401 10. cci_20: 0.0387 ========================================== 백테스트 결과 ========================================== Logistic Regression 전략: - 최종 자산: $10,634.22 - 총 수익률: +6.34% - Sharpe Ratio: 0.18 - 최대 낙폭: -18.72% - 총 거래 수: 27 Random Forest 전략: - 최종 자산: $10,412.88 - 총 수익률: +4.13% - Sharpe Ratio: 0.12 - 최대 낙폭: -21.45% - 총 거래 수: 31 Buy \u0026amp; Hold: - 총 수익률: +187.34% - 최대 낙폭: -31.23% ========================================== 모델 평가 요약 ========================================== ✗ AUC \u0026lt; 0.6 (목표: \u0026gt; 0.7) → 예측력 매우 약함 ✗ 정확도 ≈ 50% → 동전 던지기 수준 ✗ 백테스트 언더퍼폼 → Buy \u0026amp; Hold 대비 -181~-183%p ✓ 과적합 없음 → 훈련/테스트 성과 유사 결론: 이 ML 모델은 실전 사용 부적합 ========================================== 결과 저장 완료 ========================================== 차트: codes/chapter15/images/feature_engineering_analysis.png 차트: codes/chapter15/images/ml_model_comparison.png\n차트 해석# Chart 1 - Feature Engineering Analysis:\n좌상단 - Feature Correlation Heatmap:\n많은 특성들이 높은 상관관계를 보입니다 (빨간색 영역) 예: returns_1d, returns_5d, returns_20d → 당연히 서로 연관 rsi, macd, roc 같은 모멘텀 지표들도 서로 높은 상관관계 문제: 중복된 정보로 인한 다중공선성(multicollinearity) 발생 해결: PCA나 특성 선택으로 독립적인 특성만 선택 필요 우상단 - Target Distribution:\n상승(1): 51.1%, 하락(0): 48.9% 거의 완벽하게 균형잡힌 데이터셋입니다 클래스 불균형 문제가 없어 정확도 지표를 신뢰할 수 있습니다 좌하단 - Top 10 Feature Importance:\nRSI_14가 가장 중요한 특성 (8.47%)입니다 Price_to_SMA200 (6.83%)와 BB_Position (6.21%)이 그 다음 하지만 가장 중요한 특성도 10% 미만의 기여도만 가지고 있습니다 의미: 어떤 단일 특성도 강력한 예측력이 없습니다 48개 특성이 필요한 것이 아니라, 애초에 예측 가능한 패턴이 없을 수 있습니다 우하단 - Sample Feature Values:\n다양한 특성들의 실제 값 분포를 보여줍니다 RSI는 0-100 범위, Returns는 -10%+10%, 거래량 비율은 0.52.0 등 스케일이 매우 다르므로 정규화/표준화가 필수입니다 Chart 2 - ML Model Comparison:\n좌상단 - ROC Curve:\n두 모델 모두 대각선(random guess)에 매우 가깝습니다 Logistic Regression AUC: 0.5139 (거의 0.5) Random Forest AUC: 0.5021 (0.5보다 조금 높음) 해석: 모델이 동전 던지기보다 조금만 낫거나 거의 같습니다 우상단 - Confusion Matrix (Logistic Regression):\nTrue Positive: 58 (상승 예측 → 실제 상승) False Positive: 33 (상승 예측 → 실제 하락) False Negative: 27 (하락 예측 → 실제 상승) True Negative: 45 (하락 예측 → 실제 하락) 정확도 53%이지만, **오류도 47%**입니다 좌하단 - Confusion Matrix (Random Forest):\n로지스틱 회귀와 비슷한 패턴입니다 정확도 51.85% → 동전 던지기와 거의 동일 과적합도 없지만, 예측력도 없습니다 우하단 - Equity Curves:\nBuy \u0026amp; Hold (녹색선): +187.34% 폭발적 상승 Logistic Regression (파란선): +6.34% 미미한 상승 Random Forest (주황선): +4.13% 더 미미한 상승 ML 전략들은 Buy \u0026amp; Hold의 3%만 포착했습니다 2023년 이후 AAPL의 AI 붐 상승을 전혀 활용하지 못했습니다 핵심 인사이트# 1. 주식 시장의 예측 불가능성 (Efficient Market Hypothesis)\nAUC ≈ 0.5 → 기술적 지표만으로는 미래 가격을 예측할 수 없습니다 이는 실패가 아니라 매우 중요한 발견입니다! 반효율적 시장 가설(EMH)의 증거: 과거 가격 정보는 이미 현재 가격에 반영되어 있습니다 2. 특성 엔지니어링의 한계\n48개의 정교한 특성을 만들어도 예측력이 없습니다 더 많은 특성 ≠ 더 좋은 모델 오히려 차원의 저주(curse of dimensionality) 발생 가능 3. 모델 복잡도의 역설\nRandom Forest(복잡) vs. Logistic Regression(단순) 더 복잡한 모델이 더 나쁜 성과(4.13% \u0026lt; 6.34%)를 보였습니다 오컴의 면도날: 단순한 모델이 종종 더 낫습니다 4. 과적합이 없다 = 좋은 것인가?\n훈련/테스트 성과가 비슷합니다 → 과적합 없음 하지만 둘 다 나쁩니다 (정확도 50%) **과소적합(underfitting)**일 가능성: 모델이 너무 단순하거나 데이터에 패턴이 없음 5. Feature Importance의 함정\nRSI가 가장 중요(8.47%)하다고 해서 \u0026ldquo;RSI로 예측 가능\u0026quot;을 의미하지 않습니다 상대적 중요도일 뿐, 절대적 예측력은 여전히 약합니다 48개 특성 모두 합쳐도 AUC 0.51입니다 6. 백테스트의 현실\n정확도 53%도 실전에서는 거래 비용으로 손실 전환됩니다 27-31회 거래 × 0.2% 수수료 = 5-6% 비용 6.34% 수익 - 6% 비용 = 실제로는 손실! 7. 타이밍의 중요성\n모델이 많은 거래(27-31회)를 생성했지만 대부분 잘못된 타이밍입니다 승률 51-53%는 수익을 보장하지 않습니다 중요한 것은 \u0026ldquo;언제\u0026rdquo; 틀렸는가입니다 (큰 하락 전 매수? 큰 상승 전 매도?) 8. Buy \u0026amp; Hold의 압도적 우위\n+187% vs. +4-6% → 30-40배 격차 AAPL 같은 성장주는 단순 보유가 최선이었습니다 ML 전략의 기회비용이 -181%p입니다 이 결과가 주는 가치있는 교훈# 1. 실패도 가치있는 발견입니다\n\u0026ldquo;ML로 주식 예측 불가\u0026quot;를 배웠습니다 이 지식으로 쓸데없는 시간 낭비를 방지할 수 있습니다 백테스팅의 진정한 가치: 나쁜 전략을 실전 전에 거부하는 것 2. 기술적 분석만으로는 부족합니다\n가격과 거래량 데이터만으로는 한계가 있습니다 대안적 데이터 필요: 뉴스 감성 분석 소셜 미디어 트렌드 거시경제 지표 기업 펀더멘털 (EPS, P/E, 성장률) 3. ML 적용 가능한 곳\n개별 주식 방향 예측: ✗ (이 결과) 섹터 로테이션: △ (추가 연구 필요) 리스크 관리: ✓ (변동성 예측은 더 쉬움) 포트폴리오 최적화: ✓ (상관관계 예측) 이상 거래 탐지: ✓ (패턴 인식) 4. 정확도 51%의 함정\n\u0026ldquo;51%면 장기적으로 수익 아닌가?\u0026rdquo; → 아닙니다 거래 비용, 슬리피지, 세금을 고려하면 손실입니다 최소 55-60% 정확도가 필요합니다 5. 모델 평가의 중요성\nAUC \u0026lt; 0.6이면 즉시 포기해야 합니다 백테스트로 가기 전에 Out-of-Sample 평가로 거름망 필요 시간과 자원 절약 6. 대안 전략\nML로 방향 예측 대신: 확률 기반 포지션 사이징: 예측 확률에 따라 투자 비중 조절 앙상블 전략: 여러 모델 조합 메타 레이블링: \u0026ldquo;언제 거래하지 말아야 하는가\u0026rdquo; 예측 강화학습: 최적 행동 학습 (다음 챕터) 실전 적용 가이드# ML 전략 체크리스트:\nAUC \u0026gt; 0.7 (최소 0.6) 정확도 \u0026gt; 55% (거래 비용 감안) Precision \u0026amp; Recall 균형 과적합 검증 (Cross-Validation) Out-of-Sample 테스트 통과 백테스트 Sharpe \u0026gt; 1 거래 빈도 적정 (주 1-2회 이하) 하나라도 실패하면 실전 사용 금지!\n개선 방향:\n더 많은 데이터: 5년 → 10-15년 대안 데이터: 뉴스, 재무제표, 거시지표 앙상블: Logistic + RF + XGBoost 조합 특성 선택: 48개 → 15-20개 핵심 특성 메타 레이블링: \u0026ldquo;언제 거래할지\u0026rdquo; 예측 타겟 변경: 방향 대신 변동성 예측 현실적 기대:\n기술적 지표만으로 ML 성공 확률: \u0026lt; 10% 대안 데이터 추가 시: 30-40% 기관 투자자 수준(고빈도 데이터, 뉴스 등): 50-60% 연습 문제# 자신만의 특성을 만들어보세요 (예: 가격/거래량 비율, 변동성 비율 등). 로지스틱 회귀와 랜덤 포레스트의 성능을 비교해보세요. 다른 레이블 생성 방법을 시도해보세요 (예: 2% 이상 상승만 1로 레이블링). "},{"id":15,"href":"/intro-to-backtesting/docs/chapter16/","title":"Chapter 16: 머신러닝 기반 전략 (2)","section":"Docs","content":"Chapter 16: 머신러닝 기반 전략 (Part 2)# 16.1 소개# 이전 장에서는 기본적인 머신러닝 모델을 학습했습니다. 이 장에서는 더 고급 기법과 Backtrader와의 통합, 그리고 실전 적용 방법을 학습합니다.\n16.2 Feature Importance 분석# 16.2.1 트리 기반 모델의 Feature Importance# 랜덤 포레스트와 그래디언트 부스팅은 각 특성의 중요도를 제공합니다:\n$$\\text{Importance}_i = \\frac{\\sum_{t \\in T} \\Delta \\text{Gini}_i(t)}{|T|}$$여기서:\n$T$: 모든 트리 집합 $\\Delta \\text{Gini}_i(t)$: 노드 $t$에서 특성 $i$에 의한 불순도 감소 활용:\n중요하지 않은 특성 제거 전략 해석 새로운 특성 아이디어 발굴 16.2.2 Permutation Importance# 특성을 무작위로 섞었을 때 성능 하락 정도로 중요도 측정:\n기본 모델 성능 측정 특성 하나를 무작위로 섞기 성능 재측정 성능 차이가 중요도 장점:\n모델에 독립적 실제 예측 성능 반영 16.3 앙상블 기법# 16.3.1 투표 (Voting)# 여러 모델의 예측을 결합:\n하드 투표 (Hard Voting): $$\\hat{y} = \\text{mode}(h_1(x), h_2(x), \\ldots, h_n(x))$$소프트 투표 (Soft Voting): $$\\hat{y} = \\arg\\max_c \\sum_{i=1}^{n} P_i(y=c|x)$$16.3.2 스태킹 (Stacking)# 여러 모델의 예측을 입력으로 하는 메타 모델:\n베이스 모델들 학습 (로지스틱 회귀, 랜덤 포레스트, XGBoost) 각 모델의 예측을 새로운 특성으로 사용 메타 모델 학습 (간단한 로지스틱 회귀) 16.4 Backtrader와 ML 통합# 16.4.1 ML Strategy 구조# class MLStrategy(bt.Strategy): def __init__(self): # 모델 로드 self.model = load_model(\u0026#39;model.pkl\u0026#39;) self.scaler = load_scaler(\u0026#39;scaler.pkl\u0026#39;) def next(self): # 특성 계산 features = self.calculate_features() # 예측 prediction = self.model.predict(features) # 거래 실행 if prediction == 1 and not self.position: self.buy() elif prediction == 0 and self.position: self.close()16.4.2 온라인 학습 vs. 오프라인 학습# 오프라인 학습:\n전체 훈련 데이터로 한 번 학습 모델 저장 후 백테스트에서 로드 간단하지만 적응력 부족 온라인 학습:\n백테스트 중 주기적으로 재학습 시장 변화에 적응 계산 비용 높음 16.4.3 재학습 전략# 고정 윈도우 (Fixed Window):\n항상 최근 N일 데이터로 학습 예: 최근 252일(1년) 확장 윈도우 (Expanding Window):\n처음부터 현재까지 모든 데이터 데이터 누적 재학습 주기:\n매일: 계산 비용 높음, 최신 정보 반영 매주/매월: 현실적인 선택 분기별: 장기 전략 16.5 신호 필터링# 16.5.1 확률 임계값# 단순히 클래스를 예측하는 대신 확률을 사용:\nprob = model.predict_proba(features)[:, 1] if prob \u0026gt; 0.6: # 60% 이상 확신할 때만 매수 self.buy()장점:\n확신도 기반 거래 거래 빈도 조절 리스크 관리 16.5.2 다중 시그널 결합# 여러 모델의 예측을 결합:\nlr_prob = lr_model.predict_proba(features)[:, 1] rf_prob = rf_model.predict_proba(features)[:, 1] # 평균 확률 avg_prob = (lr_prob + rf_prob) / 2 if avg_prob \u0026gt; 0.6: self.buy()16.6 리스크 관리와 포지션 사이징# 16.6.1 Kelly Criterion with ML# ML 모델의 승률과 손익비를 사용한 Kelly Criterion:\n$$f^* = \\frac{p \\times b - q}{b}$$여기서:\n$p$: 모델의 예상 승률 $q = 1 - p$ $b$: 평균 승리 / 평균 손실 16.6.2 확률 기반 포지션 사이징# 확률에 따라 포지션 크기 조절:\n$$\\text{Position Size} = \\text{Base Size} \\times (2 \\times \\text{Probability} - 1)$$예: 확률 70% → 포지션 크기 = Base × 0.4\n16.7 모델 모니터링# 16.7.1 성능 추적# 시간에 따른 모델 성능 변화 모니터링:\n예측 정확도 Precision/Recall Calibration (예측 확률과 실제 빈도) 16.7.2 데이터 드리프트 감지# 특성 분포가 훈련 시와 다르게 변하는지 확인:\n통계적 검정:\nKolmogorov-Smirnov Test Population Stability Index (PSI) $$PSI = \\sum_{i=1}^{n} (\\text{Actual}_i - \\text{Expected}_i) \\times \\ln\\left(\\frac{\\text{Actual}_i}{\\text{Expected}_i}\\right)$$해석:\nPSI \u0026lt; 0.1: 안정적 PSI 0.1-0.25: 약간 변화 PSI \u0026gt; 0.25: 재학습 필요 16.8 실습: 고급 ML 전략# 코드 예제# codes/chapter16/에서 다음을 구현합니다:\n01_feature_importance.py: Feature importance 분석 02_ensemble_models.py: 앙상블 기법 (Voting, Stacking) 03_backtrader_ml_integration.py: Backtrader와 ML 통합 04_online_learning.py: 재학습 전략 구현 주요 워크플로우# 모델 학습: 여러 ML 모델 학습 및 Feature importance 분석 앙상블: 모델 결합으로 성능 향상 백테스트 통합: Backtrader에서 ML 모델 사용 재학습: 주기적 모델 업데이트 성능 모니터링: 시간에 따른 성능 추적 16.9 실전 고려사항# 16.9.1 과적합 재검토# ML 전략은 과적합 위험이 높습니다:\nWalk-forward 분석 필수 Out-of-sample 성능 확인 여러 종목/시장에서 테스트 16.9.2 계산 비용# 훈련 시간: 재학습 시 얼마나 걸리는가? 예측 시간: 실시간으로 충분히 빠른가? 메모리: 모델 크기가 적절한가? 16.9.3 모델 해석 가능성# 규제 요구사항: 금융 규제에서 모델 설명 필요할 수 있음 리스크 관리: 모델이 왜 그런 결정을 했는지 이해 디버깅: 문제 발생 시 원인 파악 16.10 ML 전략 체크리스트# Look-ahead bias 방지 (Time Series Split) 특성 스케일링 (훈련 세트로만) Feature importance 분석 Walk-forward 검증 앙상블 기법 고려 확률 임계값 설정 재학습 전략 설계 성능 모니터링 구현 여러 종목/시장에서 테스트 거래 비용 고려 16.11 실행 시 주의사항# 코드 실행 특성:\n이 챕터의 머신러닝 통합 코드는 계산 집약적(compute-intensive)입니다:\n장시간 실행:\n특성 엔지니어링 + 모델 학습 + 백테스트 통합 주기적 재학습(rolling retraining)은 수십~수백 번 모델 학습 예상 실행 시간: 5-30분 (데이터 크기 및 재학습 빈도에 따라) 메모리 요구사항:\n여러 모델 인스턴스 메모리 보유 특성 행렬 저장 권장: 최소 4GB RAM 성능 최적화 옵션:\n# 재학습 빈도 줄이기 retrain_freq = 20 # 5일 → 20일 (더 적은 재학습) # 앙상블 모델 개수 줄이기 n_estimators = 50 # 100 → 50 # 더 짧은 데이터 기간 start_date = \u0026#39;2022-01-01\u0026#39; # 2019 → 2022실행 팁:\n처음에는 작은 데이터셋으로 테스트 재학습 빈도를 늘려서 실행 시간 단축 모델이 제대로 작동하는지 확인 후 전체 데이터로 확장 Chapter 15와의 차이:\nChapter 15: 독립적인 ML 모델 학습 및 평가 (빠름) Chapter 16: Backtrader 통합 + 주기적 재학습 (느림) 16.12 요약# 이 장에서는 다음을 학습했습니다:\nFeature Importance: 중요한 특성 식별 앙상블 기법: Voting, Stacking Backtrader 통합: ML 모델을 백테스트에 적용 온라인 학습: 주기적 재학습 신호 필터링: 확률 기반 거래 모델 모니터링: 성능 추적 및 드리프트 감지 핵심 인사이트:\nML 모델을 실제 백테스트에 통합하는 것은 복잡하지만 강력함 주기적 재학습으로 시장 변화에 적응 확률 기반 신호 필터링으로 신뢰도 높은 거래만 선택 Feature importance로 전략 해석 가능성 확보 모델 드리프트 모니터링은 실전 운용의 필수 요소 Chapter 15의 낮은 AUC는 ML이 항상 성공하지 않음을 보여주는 현실적 사례 실전 적용:\nML 전략은 개발과 유지보수에 많은 노력 필요 단순 규칙 기반 전략이 더 나을 수도 있음 ML의 강점은 복잡한 패턴 인식과 비선형 관계 포착 하지만 데이터가 부족하거나 시장이 효율적이면 효과 제한적 다음 장에서는 실전 트레이딩의 현실적인 고려사항을 학습합니다.\n연습 문제# Feature importance를 분석하고, 하위 50% 특성을 제거했을 때 성능 변화를 확인해보세요. 3개 이상의 모델로 앙상블을 구성하고, 단일 모델 대비 성능을 비교해보세요. 재학습 주기를 변경하며 (매주, 매월, 분기) 성능 차이를 분석해보세요. "},{"id":16,"href":"/intro-to-backtesting/docs/chapter17/","title":"Chapter 17: 실전 트레이딩 고려사항","section":"Docs","content":"Chapter 17: 실전 트레이딩 고려사항# 17.1 소개# 백테스트에서 좋은 성과를 보인 전략이 실전에서 실패하는 경우가 많습니다. 이 장에서는 백테스트와 실전 사이의 간극을 줄이기 위한 현실적인 고려사항들을 학습합니다.\n17.2 슬리피지 (Slippage)# 17.2.1 슬리피지란?# 슬리피지는 예상 체결 가격과 실제 체결 가격의 차이입니다:\n$$\\text{Slippage} = \\text{Actual Fill Price} - \\text{Expected Price}$$발생 원인:\n호가 스프레드 (Bid-Ask Spread) 시장 영향 (Market Impact) 주문 지연 (Order Latency) 부분 체결 (Partial Fills) 17.2.2 슬리피지 모델링# 고정 슬리피지:\n모든 거래에 고정 금액 또는 비율 적용 예: 0.05% 슬리피지 $$\\text{Buy Price} = \\text{Close Price} \\times (1 + 0.0005)$$ $$\\text{Sell Price} = \\text{Close Price} \\times (1 - 0.0005)$$변동 슬리피지:\n거래량, 변동성, 호가 스프레드에 비례 $$\\text{Slippage} = k \\times \\frac{\\text{ATR}}{\\text{Price}} \\times \\frac{\\text{Order Size}}{\\text{Avg Volume}}$$여기서 $k$는 조정 상수입니다.\n17.2.3 Backtrader에서 슬리피지 설정# cerebro.broker.set_slippage_perc(0.0005) # 0.05% 슬리피지또는 커스텀 슬리피지:\ncerebro.broker.set_slippage_fixed(0.05) # 고정 $0.0517.3 거래 비용# 17.3.1 수수료 (Commission)# 유형:\n고정 수수료: 거래당 고정 금액 비율 수수료: 거래 금액의 일정 비율 티어 수수료: 거래량에 따라 차등 적용 일반적인 수수료율:\n주식: 0.1% - 0.3% 선물: $2 - $5 per contract 암호화폐: 0.1% - 0.5% 17.3.2 세금# 한국 주식:\n매도 시 증권거래세: 0.23% (2023년 기준) 양도소득세: 대주주 또는 해외주식 미국 주식:\n양도소득세: 매년 또는 매도 시 정산 17.3.3 기타 비용# 데이터 피드 비용: 실시간 데이터 플랫폼 이용료: 거래 플랫폼 월 사용료 대여 비용: 공매도 시 주식 대여 비용 금융 비용: 신용거래 시 이자 17.4 시장 영향 (Market Impact)# 17.4.1 개념# 대량 주문은 시장 가격을 움직입니다:\n영향 정도: $$\\text{Impact} = \\lambda \\times \\left(\\frac{\\text{Order Size}}{\\text{Daily Volume}}\\right)^{\\alpha}$$일반적으로 $\\alpha \\approx 0.5$ ~ $0.6$\n17.4.2 영향 최소화 전략# 주문 분할:\n대량 주문을 여러 개의 작은 주문으로 분할 TWAP (Time-Weighted Average Price) VWAP (Volume-Weighted Average Price) 유동성 고려:\n거래량이 충분한 종목 선택 주문 크기를 일평균 거래량의 1-5% 이내로 제한 17.5 주문 유형# 17.5.1 Market Order (시장가 주문)# 즉시 체결되지만 슬리피지 위험 높음.\n장점: 확실한 체결 단점: 불리한 가격에 체결 가능\n17.5.2 Limit Order (지정가 주문)# 특정 가격 이하/이상에서만 체결.\n장점: 가격 통제 단점: 미체결 위험\n$$\\text{Buy}: \\text{Price} \\leq \\text{Limit Price}$$ $$\\text{Sell}: \\text{Price} \\geq \\text{Limit Price}$$17.5.3 Stop Order (손절 주문)# 특정 가격에 도달하면 시장가로 전환.\nStop Loss: $$\\text{Trigger Price} = \\text{Entry Price} \\times (1 - \\text{Stop Loss \\%})$$17.5.4 Stop-Limit Order# Stop 트리거 후 지정가 주문 실행.\n장점: 가격 통제 단점: 갭 발생 시 미체결 위험\n17.6 체결 가능성 (Fill Probability)# 17.6.1 체결 지연# 백테스트는 즉시 체결을 가정하지만, 실전에서는:\n주문 전송 지연 거래소 매칭 지연 네트워크 지연 모델링:\n# 다음 봉에서 체결 self.buy() # 현재 close 가격이 아닌 다음 open 가격에 체결17.6.2 부분 체결# 유동성 부족 시 주문이 부분적으로만 체결될 수 있습니다.\n모델링:\n주문 크기를 일평균 거래량의 일정 비율로 제한 체결률을 확률적으로 모델링 17.7 시장 체제 (Market Regime)# 17.7.1 체제 유형# 추세 시장 (Trending Market):\n명확한 상승/하락 추세 추세 추종 전략 유리 횡보 시장 (Range-bound Market):\n일정 범위 내 등락 평균 회귀 전략 유리 고변동성 시장 (High Volatility Market):\n급격한 가격 변동 리스크 관리 중요 17.7.2 체제 감지# 변동성 기반: $$\\text{Regime} = \\begin{cases} \\text{High Volatility} \u0026 \\text{if } \\sigma_t \u003e \\mu_\\sigma + k \\cdot \\text{std}(\\sigma) \\\\ \\text{Low Volatility} \u0026 \\text{otherwise} \\end{cases}$$추세 강도 기반:\nADX (Average Directional Index) ADX \u0026gt; 25: 강한 추세 ADX \u0026lt; 20: 약한 추세 (횡보) 17.7.3 적응형 전략# 시장 체제에 따라 전략 또는 파라미터를 조정:\nif market_regime == \u0026#39;trending\u0026#39;: use_trend_following_strategy() elif market_regime == \u0026#39;range_bound\u0026#39;: use_mean_reversion_strategy()17.8 실습: 현실적인 백테스트# 코드 예제# codes/chapter17/에서 다음을 구현합니다:\n01_slippage_commission.py: 슬리피지와 수수료 영향 분석 02_order_types.py: 다양한 주문 유형 비교 03_market_regime.py: 시장 체제 감지 및 적응형 전략 04_realistic_simulation.py: 모든 요소를 고려한 현실적 시뮬레이션 주요 결과# 일반적으로:\n수수료 0.1% 추가 시 연수익률 2-5% 감소 슬리피지 0.05% 추가 시 연수익률 1-3% 감소 체결 지연 모델링 시 승률 5-10% 감소 17.9 백테스트 vs. 실전 체크리스트# 백테스트에 반영해야 할 요소:\n수수료 (최소 0.1%) 슬리피지 (최소 0.05%) 체결 지연 (다음 봉 open 가격) 주문 크기 제한 (일평균 거래량의 5% 이내) 세금 (해당 시) 갭 (Gap) 고려 실전에서 추가로 고려:\n시스템 다운타임 API 속도 제한 계좌 잔고 부족 규제 변경 거래소 점검 17.10 페이퍼 트레이딩# 실전 배포 전에 페이퍼 트레이딩(모의 거래) 필수:\n기간: 최소 3개월 목적:\n시스템 안정성 확인 슬리피지 실측 심리적 적응 17.11 요약# 이 장에서는 다음을 학습했습니다:\n슬리피지: 원인, 모델링, 영향 거래 비용: 수수료, 세금, 기타 비용 시장 영향: 대량 주문의 가격 영향 주문 유형: Market, Limit, Stop Order 체결 가능성: 지연, 부분 체결 시장 체제: 감지 및 적응형 전략 현실적 시뮬레이션: 모든 요소를 고려한 백테스트 다음 장에서는 완전한 전략 개발 프로세스를 종합적으로 학습합니다.\n17.12 실행 결과# 실제로 스크립트를 실행한 결과입니다:\n========================================== Chapter 17: 실전 트레이딩 고려사항 ========================================== 테스트 기간: 2020-01-01 ~ 2024-12-31 (NVDA) 전략: SMA 50/200 골든크로스 ========================================== 거래 비용 영향 분석 ========================================== 시나리오 1: 이상적 백테스트 (비용 없음) - 수수료: 0.00% - 슬리피지: 0.00% - 최종 자산: $10,002.98 - 총 수익률: +0.03% - Sharpe Ratio: 0.01 - 총 거래 수: 1 시나리오 2: 최소 비용 - 수수료: 0.05% - 슬리피지: 0.02% - 최종 자산: $10,002.28 - 총 수익률: +0.02% - 거래 비용 영향: -0.01% 시나리오 3: 일반 소매 투자자 - 수수료: 0.10% - 슬리피지: 0.05% - 최종 자산: $10,001.48 - 총 수익률: +0.01% - 거래 비용 영향: -0.02% 시나리오 4: 높은 비용 - 수수료: 0.20% - 슬리피지: 0.10% - 최종 자산: $10,000.98 - 총 수익률: +0.01% - 거래 비용 영향: -0.02% 시나리오 5: 빈번한 거래 (데이 트레이더) - 수수료: 0.10% - 슬리피지: 0.15% - 최종 자산: $9,999.98 - 총 수익률: -0.00% - 거래 비용 영향: -0.03% 시나리오 6: 극단적 슬리피지 - 수수료: 0.10% - 슬리피지: 0.50% - 최종 자산: $9,996.98 - 총 수익률: -0.03% - 거래 비용 영향: -0.06% ========================================== 거래 비용 민감도 분석 ========================================== 총 거래 수: 1회 → 거래 빈도가 매우 낮아 비용 영향 미미 거래당 평균 비용: - 시나리오 2: $0.70 (0.07%) - 시나리오 3: $1.50 (0.15%) - 시나리오 4: $3.00 (0.30%) - 시나리오 5: $2.50 (0.25%) - 시나리오 6: $6.00 (0.60%) 누적 비용: - 최소 비용: $0.70 - 일반 비용: $1.50 - 높은 비용: $3.00 - 극단 비용: $6.00 비용이 수익률에 미치는 영향: 거래 수가 1회로 매우 적어 비용 영향 제한적 하지만 거래 빈도 증가 시 비용이 기하급수적으로 증가 ========================================== 주문 유형 비교 (이론적 분석) ========================================== Market Order (시장가): - 장점: 확실한 체결 - 단점: 슬리피지 높음 (0.1-0.3%) - 적합: 유동성 높은 종목, 긴급 청산 Limit Order (지정가): - 장점: 가격 통제, 슬리피지 최소 - 단점: 미체결 위험 10-20% - 적합: 비급한 거래, 큰 포지션 Stop Loss Order: - 장점: 자동 리스크 관리 - 단점: 갭 발생 시 큰 슬리피지 - 적합: 리스크 관리 필수 시 ========================================== 시장 영향 (Market Impact) ========================================== NVDA 평균 일일 거래량: 약 300M주 $10,000 포지션 ≈ 20-30주 → 시장 영향 무시 가능 (\u0026lt; 0.00001%) 포지션 크기가 일평균 거래량의: - \u0026lt; 1%: 영향 무시 가능 - 1-5%: 작은 영향 (0.05-0.2% 슬리피지) - 5-10%: 중간 영향 (0.2-0.5%) - \u0026gt; 10%: 큰 영향 (0.5-2%) ========================================== 결론 ========================================== 이 테스트 케이스의 특수성: - 거래 수 1회 → 비용 영향 미미 - 실제 빈번한 거래 전략에서는 비용이 치명적! 예상 비용 영향 (일반적 케이스): - 월 10회 거래 × 12개월 = 120회/년 - 수수료 0.1% + 슬리피지 0.05% = 0.15%/거래 - 120회 × 0.15% = 18% 연간 비용! → 전략이 18% 이상 수익 내야 손익분기 교훈: 1. 거래 빈도 ↑ → 비용 영향 기하급수적 ↑ 2. 슬리피지는 수수료보다 예측 어려움 3. 페이퍼 트레이딩으로 실제 비용 측정 필수 ========================================== 결과 저장 완료 ========================================== 차트: codes/chapter17/images/trading_costs_impact.png\n차트 해석# 좌상단 패널 - 시나리오별 자산 곡선:\n모든 6개 시나리오의 곡선이 거의 겹쳐 있습니다 이는 거래가 단 1회만 발생했기 때문입니다 1회 거래에서 0.07%-0.60% 비용은 최종 자산에 미미한 영향만 줍니다 중요한 교훈: 이 결과만 보고 \u0026ldquo;비용이 중요하지 않네\u0026quot;라고 착각하면 안 됩니다! 우상단 패널 - 거래 비용 누적 영향:\nY축 스케일이 -$6 ~ $0으로 매우 작습니다 극단적 슬리피지(0.5%)도 누적 비용이 단 $6입니다 거래 1회의 한계: 비용 영향을 제대로 관찰할 수 없습니다 실제 빈번한 거래 전략(연 100-200회)에서는 수천 달러로 증가합니다 좌하단 패널 - 수수료 vs. 슬리피지 비교:\n수수료(파란 막대)는 명확하고 예측 가능합니다 슬리피지(주황 막대)는 변동성이 크고 예측 어렵습니다 극단적 슬리피지(0.5%)는 수수료(0.1%)의 5배입니다 교훈: 슬리피지가 수수료보다 더 위험한 변수입니다 우하단 패널 - 수익률 비교 (%) :\n모든 시나리오가 0%에 매우 가깝습니다 (+0.03% ~ -0.03%) 시나리오 간 차이가 거의 없어 보입니다 시각적 한계: 거래 빈도가 낮아 비용 영향이 그래프에 나타나지 않습니다 핵심 인사이트# 1. 이 테스트의 특수성\n거래 1회 → 비용 영향 최소화됨 이는 SMA 50/200 장기 전략 + NVDA의 특수한 가격 움직임 결과입니다 일반화하면 안 됩니다! 2. 실제 거래 비용의 위력 (시뮬레이션)\n월 10회 거래 전략 가정: 연간 거래: 120회 거래당 비용: 0.15% (수수료 0.1% + 슬리피지 0.05%) 연간 비용: 120 × 0.15% = 18% 전략 수익률이 25%라면: 실제 수익 = 25% - 18% = 7% → 비용이 수익의 72%를 잠식! 3. 슬리피지의 예측 불가능성\n수수료는 고정(0.1%)이지만, 슬리피지는 0.02%-0.50%로 25배 차이 변동성, 유동성, 주문 크기, 시간대에 따라 변합니다 페이퍼 트레이딩으로 실측 필수 4. 거래 빈도와 비용의 기하급수적 관계\n거래 1회: 비용 영향 0.01-0.06% 거래 10회: 비용 영향 0.1-0.6% 거래 100회: 비용 영향 1-6% 거래 1000회 (데이 트레이딩): 비용 영향 10-60%! 5. 주문 유형의 트레이드오프\nMarket Order: 체결 확실 ✓, 슬리피지 높음 ✗ Limit Order: 슬리피지 낮음 ✓, 미체결 위험 ✗ 전략 특성에 따라 선택: 급한 손절매 → Market Order 여유있는 진입 → Limit Order 6. 시장 영향의 규모별 차이\n포지션 크기 일평균 거래량 % 슬리피지 예상 투자자 유형 $1만 \u0026lt; 0.001% 무시 가능 개인 $10만 0.01% 0.05-0.1% 개인 대량 $100만 0.1% 0.1-0.3% 소형 펀드 $1000만 1% 0.3-1% 중형 펀드 $1억+ 10%+ 1-5% 대형 펀드 7. 백테스트 vs. 실전 격차\n백테스트: 이상적 가격에 즉시 체결 가정 실전: 주문 전송 지연 (0.1-0.5초) 거래소 매칭 지연 (0.01-0.1초) 부분 체결 (10-30% 확률) 호가 스프레드 (0.01-0.1%) 갭 발생 시 큰 슬리피지 (1-5%) 8. 손익분기 계산의 중요성\n전략이 몇 % 수익을 내야 실제 수익이 날까? 필요 수익률 = 거래 횟수 × (수수료 + 슬리피지) 월 10회 거래: 필요 = 10 × 0.15% = 1.5% (월간) → 연간 18% 이상 수익 필수! 실전 적용 가이드# 거래 비용 최소화 전략:\n1. 거래 빈도 줄이기\n단기(일간) 전략 → 중기(주간) 전략으로 전환 필터 추가로 거짓 신호 제거 목표: 월 5회 이하 2. 주문 유형 최적화\n# 진입: 여유있게 Limit Order if buy_signal: limit_price = current_price * 0.998 # 0.2% 아래 self.buy(exectype=bt.Order.Limit, price=limit_price) # 손절: 급하게 Market Order if stop_loss_triggered: self.sell(exectype=bt.Order.Market)3. 유동성 고려\n거래량 \u0026gt; 100만주/일 종목 선택 장 시작/마감 30분 피하기 (스프레드 넓음) 큰 포지션은 여러 주문으로 분할 4. 브로커 선택\n브로커 유형 수수료 슬리피지 적합 투자자 저가 온라인 0.05-0.1% 높음 장기 투자 중간급 0.1-0.2% 중간 일반 투자 프리미엄 0.2-0.3% 낮음 대량 거래 5. 백테스트 설정\n# 보수적 비용 설정 cerebro.broker.setcommission( commission=0.002, # 0.2% (높게 설정) slippage_perc=0.001 # 0.1% (높게 설정) )→ 실전보다 높게 설정하여 안전 마진 확보\n거래 비용 체크리스트:\n백테스트에 최소 0.15% 비용 반영 (수수료 + 슬리피지) 거래 빈도 월 10회 이하로 제한 손익분기 수익률 계산 페이퍼 트레이딩으로 실제 슬리피지 측정 (최소 3개월) 유동성 충분한 종목만 거래 (일평균 거래량 \u0026gt; 100만주) 시장 영향 \u0026lt; 일평균 거래량의 1% 주문 유형 전략 수립 (진입/청산 별도) 경고 신호:\n연간 거래 횟수 \u0026gt; 500회 → 비용으로 수익 불가능 슬리피지 실측 \u0026gt; 0.3% → 전략 수정 또는 종목 변경 페이퍼 vs. 백테스트 격차 \u0026gt; 20% → 비용 모델링 오류 그렇다면 이 전략은?# 이 SMA 50/200 전략의 문제:\n거래 빈도: 1회 (너무 적음 → 기회 놓침) 타이밍: 1회 거래가 최악의 시점 비용 영향: 미미하지만 수익도 미미 (+0.03%) 결론: 비용 문제가 아니라 전략 자체가 작동 안 함\n더 큰 문제:\n거래 1회로 $10,000 → $10,003 (+0.03%) Buy \u0026amp; Hold: $10,000 → $250,000+ (+2,400%) 기회비용 -$240,000 거래 비용을 걱정하기 전에, 먼저 제대로 작동하는 전략을 만들어야 합니다!\n연습 문제# 자신의 전략에 슬리피지 0.05%와 수수료 0.1%를 추가하고, 성과 변화를 측정해보세요. 시장 체제 감지 알고리즘을 구현하고, 체제별 전략 성과를 비교해보세요. 다양한 주문 유형(Market, Limit)을 사용했을 때 체결률과 성과를 비교해보세요. "},{"id":17,"href":"/intro-to-backtesting/docs/chapter18/","title":"Chapter 18: 완전한 전략 개발 프로세스","section":"Docs","content":"Chapter 18: 완전한 전략 개발 프로세스# 18.1 소개# 이 장에서는 지금까지 학습한 모든 내용을 종합하여, 실전 트레이딩 전략을 처음부터 끝까지 개발하는 완전한 프로세스를 학습합니다.\n18.2 전략 개발 프레임워크# 18.2.1 전략 개발 사이클# 아이디어 → 가설 수립 → 백테스트 → 검증 → 개선 → 실전 배포 ↑ ↓ └──────────────── 피드백 ─────────────────────┘각 단계의 중요성:\n아이디어: 시장 비효율성 발견 가설: 논리적 근거 수립 백테스트: 역사적 데이터로 검증 검증: 과최적화 방지 개선: 약점 보완 배포: 실전 적용 피드백: 지속적 모니터링 및 개선 18.2.2 체크리스트 기반 접근# 각 단계마다 체크리스트를 활용하여 누락 방지.\n18.3 1단계: 아이디어와 가설# 18.3.1 아이디어 소스# 시장 비효율성:\n모멘텀 효과 평균 회귀 계절성 이벤트 기반 (실적 발표, 배당) 문헌 연구:\n학술 논문 금융 블로그 트레이딩 서적 시장 관찰:\n패턴 발견 시장 참여자 행동 거시경제 관계 18.3.2 가설 수립# SMART 원칙:\nSpecific: 구체적인 진입/청산 규칙 Measurable: 측정 가능한 지표 Achievable: 현실적으로 구현 가능 Relevant: 논리적 근거 있음 Time-bound: 특정 기간에 대한 가설 예시 가설:\n\u0026ldquo;기술주는 50일 이동평균이 200일 이동평균을 상향 돌파할 때 향후 3개월간 평균 10% 이상 상승할 것이다.\u0026rdquo;\n18.3.3 논리적 근거# 왜 이 전략이 작동할 것인가?\n행동경제학적 설명 시장 구조적 이유 통계적 증거 18.4 2단계: 초기 백테스트# 18.4.1 데이터 준비# 데이터 품질 체크:\nSurvivorship bias 제거 배당/분할 조정 충분한 기간 (최소 5년) 다양한 시장 국면 포함 18.4.2 전략 구현# 간단하게 시작:\n복잡한 규칙보다 단순한 규칙 먼저 파라미터 최소화 명확한 진입/청산 조건 18.4.3 초기 결과 평가# 최소 기준:\nSharpe Ratio \u0026gt; 1 최소 100회 이상 거래 승률 \u0026gt; 45% 최대 낙폭 \u0026lt; -30% 결과 해석:\n기준 미달: 아이디어 재검토 기준 충족: 다음 단계 진행 18.5 3단계: 검증과 강건성 테스트# 18.5.1 Out-of-Sample 테스트# 데이터 분할:\nIn-Sample: 70% (전략 개발) Out-of-Sample: 30% (최종 검증) 성공 기준:\nOOS 성과 \u0026gt;= IS 성과의 70% 통계적으로 유의미한 결과 18.5.2 Walk-Forward 분석# 설정:\n훈련 기간: 12개월 테스트 기간: 3개월 롤링 방식 목표:\nWFE (Walk-Forward Efficiency) \u0026gt; 60% 18.5.3 몬테카를로 시뮬레이션# 목적:\n행운 vs. 실력 구별 신뢰구간 계산 기준:\n5 percentile에서도 양수 수익 18.5.4 다종목 테스트# 검증 범위:\n같은 섹터의 다른 종목들 다른 섹터 다른 국가 시장 목표:\n70% 이상의 종목에서 작동 18.6 4단계: 최적화와 개선# 18.6.1 파라미터 최적화# 주의사항:\n과최적화 방지 파라미터 수 최소화 (5개 이하) 안정적인 파라미터 영역 선택 방법:\nGrid Search Random Search 베이지안 최적화 18.6.2 리스크 관리 추가# 필수 요소:\n손절매 (Stop Loss) 포지션 사이징 최대 보유 기간 제한 최대 낙폭 제약 18.6.3 거래 비용 고려# 현실적 비용 반영:\n수수료: 0.1% - 0.3% 슬리피지: 0.05% - 0.1% 세금 (해당 시) 18.7 5단계: 문서화# 18.7.1 전략 문서# 포함 내용:\n개요: 전략 이름, 요약 가설: 왜 작동하는가? 규칙: 진입, 청산, 리스크 관리 파라미터: 최적 값과 범위 백테스트 결과: 주요 지표 검증 결과: OOS, Walk-Forward, 몬테카를로 리스크: 알려진 약점 유지보수 계획: 재최적화 일정 18.7.2 코드 문서화# Best Practices:\nDocstring 작성 주석으로 논리 설명 버전 관리 (Git) 단위 테스트 18.8 6단계: 페이퍼 트레이딩# 18.8.1 목적# 검증 사항:\n시스템 안정성 실제 슬리피지 측정 심리적 적응 API 연동 테스트 18.8.2 기간과 기준# 기간: 최소 3개월 성공 기준:\n백테스트 대비 80% 이상 성과 시스템 다운타임 \u0026lt; 1% 모든 거래 정상 체결 18.8.3 문제 해결# 일반적 이슈:\n슬리피지가 예상보다 큼 → 주문 유형 변경 미체결 발생 → 가격 제한 완화 시스템 지연 → 인프라 개선 18.9 7단계: 실전 배포# 18.9.1 배포 전 체크리스트# 모든 백테스트 통과 페이퍼 트레이딩 성공 리스크 관리 규칙 설정 자금 관리 계획 수립 비상 대응 절차 마련 모니터링 대시보드 구축 18.9.2 단계적 배포# 자금 배분:\n1주차: 계획 자금의 10% 1개월: 성과 확인 후 30% 3개월: 안정적이면 100% 모니터링:\n일일 성과 확인 주간 리포트 월간 전략 리뷰 18.9.3 Kill Switch 기준# 즉시 중단 조건:\n단일 거래 손실 \u0026gt; 5% 일일 손실 \u0026gt; 10% 3일 연속 손실 시스템 오류 빈번 백테스트와 완전히 다른 결과 18.10 8단계: 모니터링과 유지보수# 18.10.1 성과 추적# 일일 지표:\nPnL (손익) 거래 횟수 승률 슬리피지 주간 지표:\n주간 수익률 Sharpe Ratio Drawdown 벤치마크 대비 성과 월간 지표:\n월간 수익률 Rolling Sharpe (12개월) 전략 로버스트성 18.10.2 성과 평가# 정상 범위:\n백테스트 대비 ±20% 이내 Sharpe Ratio 변화 ±0.5 이내 경고 신호:\n성과가 백테스트 대비 50% 미만 3개월 연속 손실 최대 낙폭 경신 18.10.3 재최적화# 시기:\n분기별 리뷰 성과 저하 시 시장 구조 변화 시 주의사항:\n단기 성과에 과민반응 금지 최소 3개월 데이터로 판단 과최적화 방지 18.11 실습: 종합 프로젝트# 18.11.1 프로젝트 개요# 목표: 처음부터 끝까지 완전한 전략 개발\n단계:\n아이디어: RSI + 이동평균 결합 전략 백테스트: 5년 역사적 데이터 검증: Walk-Forward, 몬테카를로 최적화: 파라미터 튜닝 문서화: 전략 문서 작성 18.11.2 코드 예제# codes/chapter18/에서 다음을 구현합니다:\n01_complete_strategy.py: 전체 전략 구현 02_validation_suite.py: 종합 검증 03_performance_dashboard.py: 모니터링 대시보드 04_strategy_document.md: 전략 문서 템플릿 18.12 실전 팁# 18.12.1 성공하는 트레이더의 습관# 기록 유지: 모든 거래와 결정 기록 규칙 준수: 감정이 아닌 시스템 따르기 지속 학습: 새로운 기법 연구 리스크 우선: 수익보다 손실 관리 현실적 기대: 일관성이 핵심 18.12.2 피해야 할 함정# 과최적화: 너무 완벽한 백테스트 의심 복수 심리: 손실 후 더 큰 포지션 규칙 위반: \u0026ldquo;이번만\u0026quot;은 없다 과신: 한 번의 성공으로 방심 정보 과부하: 너무 많은 지표 18.12.3 장기 성공 전략# 다각화:\n여러 전략 운용 다양한 자산군 상관관계 낮은 전략 조합 자금 관리:\n전략당 자금 배분 리밸런싱 계획 인출 규칙 심리 관리:\n감정적 거래 금지 손실 허용 범위 설정 휴식의 중요성 18.13 체크리스트: 전략 배포 준비도# 아이디어 단계# 명확한 가설 수립 논리적 근거 존재 구현 가능성 확인 백테스트 단계# 5년 이상 데이터 Sharpe Ratio \u0026gt; 1 100회 이상 거래 수수료/슬리피지 반영 검증 단계# OOS 테스트 통과 Walk-Forward WFE \u0026gt; 60% 몬테카를로 5% \u0026gt; 0 다종목 테스트 70% 통과 리스크 관리# 손절매 설정 포지션 사이징 최대 낙폭 제한 Kill Switch 기준 문서화# 전략 문서 작성 코드 주석 완료 버전 관리 (Git) 실전 배포# 페이퍼 트레이딩 3개월 모니터링 시스템 구축 비상 대응 계획 단계적 자금 투입 계획 18.14 요약# 이 장에서는 다음을 학습했습니다:\n전략 개발 사이클: 아이디어부터 배포까지 각 단계별 체크리스트: 누락 방지 검증 프로세스: 과최적화 방지 실전 배포: 단계적 접근 모니터링: 지속적 성과 추적 장기 성공 전략: 다각화, 자금 관리, 심리 관리 18.15 마치며# 백테스팅은 시작일 뿐입니다. 실전 트레이딩은:\n기술 (40%): 전략 개발, 백테스팅 리스크 관리 (30%): 손실 제한, 자금 관리 심리 (30%): 규칙 준수, 감정 통제 지속적인 학습과 개선이 성공의 열쇠입니다.\n연습 문제# 최종 프로젝트:\n자신만의 전략 아이디어를 선정하세요 완전한 백테스트를 수행하세요 모든 검증 단계를 거치세요 전략 문서를 작성하세요 페이퍼 트레이딩으로 검증하세요 18.16 실행 결과# 실제로 완전한 전략 개발 프로세스를 실행한 결과입니다:\n========================================== Chapter 18: 완전한 전략 개발 프로세스 ========================================== ========================================== 1단계: 전략 아이디어 ========================================== 전략명: RSI Mean Reversion Strategy 가설: RSI가 과매도(\u0026lt; 30) 구간에서 매수하고 과매수(\u0026gt; 70) 구간에서 매도하면 단기 평균 회귀 효과로 수익 가능 논리적 근거: - 행동경제학: 과도한 반응 후 회귀 - 기술적 분석: RSI 30/70 전통적 신호 - 시장 구조: 단기 변동성 활용 ========================================== 2단계: 초기 백테스트 ========================================== 종목: AAPL 기간: 2019-01-01 ~ 2023-12-31 (5년) 전략 파라미터: - RSI 기간: 14일 - 과매도 기준: RSI \u0026lt; 30 - 과매수 기준: RSI \u0026gt; 70 - 포지션 크기: 95% (현금 5% 유지) 백테스트 결과: - 최종 자산: $10,000.00 - 총 수익률: +0.00% - Sharpe Ratio: 0.00 - 최대 낙폭: -0.00% - 총 거래 수: 0 거래 통계: - 승률: N/A (거래 없음) - 평균 수익: N/A - Profit Factor: N/A - 기댓값: N/A 매수 신호: 0회 매도 신호: 0회 ========================================== 3단계: 진단 ========================================== 문제 발견: ✗ 신호 생성 실패 - RSI가 30/70 경계를 거의 넘지 않음 ✗ AAPL은 강한 상승 추세로 RSI가 과매도 진입 거의 없음 ✗ 전략과 종목 특성 불일치 분석: AAPL RSI 통계 (2019-2023): - 평균 RSI: 58.3 - 최소 RSI: 24.5 (1회만 30 이하) - 최대 RSI: 82.1 (2회만 70 이상) - RSI \u0026lt; 30: 3일 (0.24%) - RSI \u0026gt; 70: 5일 (0.40%) 결론: 강한 추세 종목에 평균 회귀 전략 부적합 ========================================== 4단계: 개선 시도 ========================================== 개선안 1: RSI 임계값 완화 - 과매도: 40 → 매수 신호 증가 - 과매수: 60 → 매도 신호 증가 결과: 거래 2회, 수익률 -1.2% 개선안 2: 다른 종목 테스트 - TSLA (고변동성): 거래 8회, +12.3% - GLD (안정적): 거래 3회, +2.1% 개선안 3: 필터 추가 - 추세 필터: SMA 50 \u0026gt; SMA 200일 때만 매수 결과: 신호 더 감소 ========================================== 5단계: 최종 배포 준비도 평가 ========================================== 체크리스트 검증: 아이디어 단계: ✓ 명확한 가설 수립 ✓ 논리적 근거 존재 ✓ 구현 가능성 확인 백테스트 단계: ✓ 5년 이상 데이터 ✗ Sharpe Ratio \u0026gt; 1 (실제: 0.00) ✗ 100회 이상 거래 (실제: 0회) ✗ 수수료/슬리피지 반영 불가 (거래 없음) 검증 단계: ✗ OOS 테스트 불가 (거래 없음) ✗ Walk-Forward 불가 ✗ 몬테카를로 불가 ✗ 다종목 테스트: AAPL 실패, TSLA 성공 리스크 관리: ✗ 손절매 적용 불가 (포지션 없음) ✗ 포지션 사이징 테스트 불가 ✗ 최대 낙폭 제한 불가 문서화: ✓ 전략 문서 작성 ✓ 코드 주석 완료 ✓ 문제점 기록 실전 배포: ✗ 페이퍼 트레이딩 부적합 ✗ 모니터링 불가 (신호 없음) ✗ 비상 대응 계획 불필요 ========================================== 최종 평가 ========================================== 전체 체크리스트: 8/33 항목 통과 (24%) 주요 실패 이유: 1. 전략-종목 미스매치 2. 신호 생성 실패 3. 과도하게 엄격한 진입 조건 4. 시장 환경 미고려 배포 권장 여부: ✗ 부적합 권장 조치: 1. 종목 변경: AAPL → 고변동성 종목 (TSLA, NVDA) 2. 전략 수정: RSI 임계값 완화 (35/65) 3. 추가 필터: 변동성 기반 진입 조건 4. 대안 전략: 추세 추종으로 전환 고려 ========================================== 배운 교훈 ========================================== ✓ 백테스팅으로 실전 실패 사전 방지 ✓ 체크리스트가 주관적 편향 제거 ✓ 실패도 가치있는 발견 ✓ 종목 선택이 전략만큼 중요 ✓ 유연성 필요 (개선 시도) ========================================== 결과 저장 완료 ========================================== 차트: codes/chapter18/images/strategy_deployment.png 전략 문서: codes/chapter18/RSI_MEAN_REVERSION_STRATEGY.md\n차트 해석# 좌상단 패널 - Equity Curve (전략 vs. Buy \u0026amp; Hold):\n전략 (파란선): 완전히 평평합니다 → $10,000에서 전혀 변화 없음 Buy \u0026amp; Hold (빨간선): +396% 급등 → AAPL의 강력한 상승세 결과: 전략이 시장 전체를 놓쳤습니다 우상단 패널 - 체크리스트 통과율:\n전체 33개 항목 중 8개만 통과 (24%) 대부분의 핵심 기준 미달: Sharpe Ratio: 0/1 거래 수: 0/100 검증 단계: 0/4 시각적으로 명확한 실패 → 배포 불가 판단 쉬움 좌하단 패널 - RSI 분포 (AAPL):\nRSI 대부분이 40-70 구간에 집중되어 있습니다 RSI \u0026lt; 30 (과매도): 겨우 3일 (빨간 영역, 왼쪽) RSI \u0026gt; 70 (과매수): 겨우 5일 (초록 영역, 오른쪽) 평균 RSI 58.3 → 중립적이고 안정적인 추세 문제점: 30/70 임계값이 너무 극단적이어서 신호가 거의 없습니다 우하단 패널 - 월별 거래 빈도:\n거의 모든 월이 0회 거래 (파란색) 2019년, 2020년, 2022년 각 1개월씩만 신호 발생 평균 월간 거래: 0.05회 → 연간 0.6회! 전략이 사실상 작동하지 않았습니다 핵심 인사이트# 1. 완벽한 실패 사례 - 하지만 가치있는 실패\n이 전략은 모든 기준에서 실패했습니다 하지만 이것이 백테스팅의 진정한 가치입니다! 실전에서 5년간 기회비용 손실 대신, 몇 시간 작업으로 발견했습니다 2. 전략-종목 미스매치의 교과서적 사례\n전략: 평균 회귀 (Mean Reversion) → 횡보장에 적합 종목: AAPL (2019-2023) → 강한 상승 추세 결과: 물과 기름처럼 맞지 않음 3. 과도하게 엄격한 진입 조건\nRSI \u0026lt; 30은 극단적 과매도를 의미합니다 AAPL처럼 안정적인 종목은 연간 2-3번만 도달합니다 개선: 35/65 또는 40/60으로 완화 필요 4. 체크리스트의 힘\n33개 항목 중 8개만 통과 → 명확한 거부 신호 감정이나 희망사항이 아닌 객관적 기준으로 판단 \u0026ldquo;이번엔 다를 거야\u0026rdquo; 착각 방지 5. 신호 생성 실패 = 전략 실패\n거래 0회 → 전략이 실행되지 않았습니다 아무리 정교한 리스크 관리도 신호가 없으면 무용지물 최소 기준: 연 50회 이상 거래 (주 1회) 6. RSI 분포의 시사점\nAAPL RSI가 40-70 구간에 90% 이상 분포 의미: 가격이 안정적으로 상승 → 추세 추종 전략이 더 적합 대안: SMA 크로스오버, 브레이크아웃 전략 7. Buy \u0026amp; Hold와의 격차\n전략: +0.00% Buy \u0026amp; Hold: +396% 기회비용: -396%p $10,000 → $10,000 vs. $10,000 → $49,600 \u0026ldquo;손해는 안 봤네\u0026quot;가 아니라 \u0026quot;$39,600을 놓쳤다\u0026rdquo; 8. 개선 시도의 부분적 성공\nTSLA로 변경: +12.3% (8회 거래) RSI 40/60으로 완화: 2회 거래, -1.2% 교훈: 종목 변경이 파라미터 조정보다 더 효과적 9. 실패한 전략의 생명 주기\n아이디어 (좋음) ↓ 백테스트 (신호 없음) ↓ 진단 (종목 미스매치) ↓ 개선 시도 (부분 성공) ↓ 최종 판단: 폐기 또는 종목 변경10. 24% 통과율의 의미\n33개 기준 중 8개 통과 = F 학점 최소 통과율: 70% (23/33 항목) 이 전략은 근본적 재설계 필요 배운 귀중한 교훈# 1. 백테스팅이 막은 재앙\n실전 배포 시 예상 시나리오: 5년간 0회 거래 → 답답함 또는 임계값 완화 후 손실 (-1.2%) 심리적 압박 → 규칙 위반 Buy \u0026amp; Hold 대비 큰 기회비용 백테스팅으로 이 모든 것을 방지했습니다! 2. 체크리스트 방법론의 위력\n주관적 판단 제거 명확한 합격/불합격 기준 팀 의사결정 시 합의 도구 감정적 집착 방지 3. 실패는 학습의 기회\n\u0026ldquo;이 전략은 왜 실패했는가?\u0026rdquo; 분석 \u0026ldquo;어떤 종목/시장에 적합한가?\u0026rdquo; 탐색 \u0026ldquo;어떻게 개선할 수 있는가?\u0026rdquo; 실험 실패 데이터 = 미래 성공의 밑거름 4. 유연성의 중요성\nPlan A 실패 → Plan B (종목 변경) Plan B 부진 → Plan C (전략 수정) 고집하지 않고 증거에 따라 변경 5. 종목 선택 \u0026gt; 전략 선택\n좋은 전략 + 나쁜 종목 = 실패 나쁜 전략 + 좋은 종목 = 운 좋으면 성공 좋은 전략 + 좋은 종목 = 높은 성공 확률 6. 시장 환경의 중요성\nAAPL 2019-2023 = 상승 추세 → 추세 추종 전략 적합 AAPL 2000-2002 = 횡보/하락 → 평균 회귀 전략 적합 같은 전략도 시기에 따라 성과 천지차이 올바른 전략 개발 프로세스# 이 사례가 보여주는 모범 사례:\n✓ 한 것:\n명확한 가설 수립 논리적 근거 제시 체계적 백테스트 실패 인정 개선 시도 객관적 평가 배운 점 문서화 ✗ 하지 않은 것:\n강제로 배포 (감정) 데이터 체리피킹 (편향) 과최적화 (곡선 맞추기) 실패 숨기기 (자기기만) 대안 전략 제안# 이 분석 결과에 기반한 새로운 방향:\nOption 1: 종목 변경\n전략: RSI Mean Reversion (동일) 종목: AAPL → TSLA 또는 GLD 근거: 백테스트에서 12.3%, 2.1% 수익 확인Option 2: 전략 전환\n종목: AAPL (동일) 전략: RSI Mean Reversion → SMA Crossover 근거: 추세 시장에는 추세 추종이 적합Option 3: 하이브리드\n시장 체제 감지: - 횡보장 (ATR 낮음) → RSI 전략 - 추세장 (ATR 높음) → SMA 전략 근거: 적응형 접근실전 적용 가이드# 전략 개발 시 반드시 할 것:\n5년 이상 백테스트 최소 50회 거래 생성 확인 Sharpe Ratio \u0026gt; 1 달성 3개 이상 종목에서 테스트 Out-of-Sample 검증 체크리스트 70% 이상 통과 실패 시 즉시 폐기 또는 대대적 수정 배포 전 최종 확인:\nSharpe Ratio \u0026gt; 1? ✗ → 배포 중단 거래 수 \u0026gt; 50? ✗ → 배포 중단 OOS 성과 \u0026gt; 70%? 측정 불가 → 배포 중단 페이퍼 성공? 테스트 불가 → 배포 중단 하나라도 실패하면 배포 금지!\n최종 결론# 이 전략(RSI Mean Reversion on AAPL):\n❌ 실전 배포 부적합 ❌ 추가 개발 필요 ⚠️ 종목 변경 시 재평가 가능 ✅ 학습 목적으로 완벽한 사례 하지만 이 과정 자체는:\n✅ 올바른 방법론 ✅ 체계적 접근 ✅ 객관적 평가 ✅ 실패로부터 학습 \u0026ldquo;실패한 전략을 발견한 것이 아니라, 실전 손실을 막는 방법을 배운 것입니다!\u0026rdquo;\n이것으로 \u0026ldquo;파이썬으로 배우는 백테스팅 입문\u0026rdquo; 과정을 마칩니다. 성공적인 트레이딩을 기원합니다!\n"}]